/**
 * Data Integration API
 * Use the Data Integration Service APIs to perform common extract, load, and transform (ETL) tasks.
 * OpenAPI spec version: 20200430
 * Contact: di_dis_ww_grp@oracle.com
 *
 * NOTE: This class is auto generated by OracleSDKGenerator.
 * Do not edit the class manually.
 *
 * Copyright (c) 2020, Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */

import common = require("oci-common");
import * as requests from "./request";
import * as models from "./model";
import * as responses from "./response";
import { paginateRecords, paginateResponses } from "oci-common";
import { DataIntegrationWaiter } from "./dataintegration-waiter";
import { composeResponse, composeRequest } from "oci-common";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum DataIntegrationApiKeys {}

export class DataIntegrationClient {
  protected static serviceEndpointTemplate =
    "https://dataintegration.{region}.oci.{secondLevelDomain}";
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": DataIntegrationWaiter;

  protected _httpClient: common.HttpClient;

  constructor(params: common.AuthParams) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._httpClient = params.httpClient || new common.FetchHttpClient(requestSigner);

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20200430";
    if (this.logger) this.logger.info(`DataIntegrationClient endpoint set to ${this._endpoint}`);
  }

  public get logger() {
    return common.LOG.logger;
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      DataIntegrationClient.serviceEndpointTemplate,
      region
    );
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      DataIntegrationClient.serviceEndpointTemplate,
      regionId
    );
  }

  /**
   * Creates a new DataIntegrationWaiter for resources for this service.
   *
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(config?: common.WaiterConfiguration): DataIntegrationWaiter {
    this._waiters = new DataIntegrationWaiter(this, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): DataIntegrationWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * The workspace will be moved to the desired compartment.
   *
   * @param ChangeCompartmentRequest
   * @return ChangeCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeCompartment(
    changeCompartmentRequest: requests.ChangeCompartmentRequest
  ): Promise<responses.ChangeCompartmentResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataIntegrationClient#changeCompartment.");
    const pathParams = {
      "{workspaceId}": changeCompartmentRequest.workspaceId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": changeCompartmentRequest.ifMatch,
      "opc-request-id": changeCompartmentRequest.opcRequestId,
      "opc-retry-token": changeCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeCompartmentRequest.changeCompartmentDetails,
        "ChangeCompartmentDetails",
        models.ChangeCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates an application.
   *
   * @param CreateApplicationRequest
   * @return CreateApplicationResponse
   * @throws OciError when an error occurs
   */
  public async createApplication(
    createApplicationRequest: requests.CreateApplicationRequest
  ): Promise<responses.CreateApplicationResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataIntegrationClient#createApplication.");
    const pathParams = {
      "{workspaceId}": createApplicationRequest.workspaceId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createApplicationRequest.opcRequestId,
      "opc-retry-token": createApplicationRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/applications",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createApplicationRequest.createApplicationDetails,
        "CreateApplicationDetails",
        models.CreateApplicationDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateApplicationResponse>{},
        body: await response.json(),
        bodyKey: "application",
        bodyModel: "model.Application",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a connection under an existing data asset.
   * @param CreateConnectionRequest
   * @return CreateConnectionResponse
   * @throws OciError when an error occurs
   */
  public async createConnection(
    createConnectionRequest: requests.CreateConnectionRequest
  ): Promise<responses.CreateConnectionResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#createConnection.");
    const pathParams = {
      "{workspaceId}": createConnectionRequest.workspaceId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createConnectionRequest.opcRequestId,
      "opc-retry-token": createConnectionRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/connections",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createConnectionRequest.createConnectionDetails,
        "CreateConnectionDetails",
        models.CreateConnectionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateConnectionResponse>{},
        body: await response.json(),
        bodyKey: "connection",
        bodyModel: "model.Connection",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a connection validation.
   * @param CreateConnectionValidationRequest
   * @return CreateConnectionValidationResponse
   * @throws OciError when an error occurs
   */
  public async createConnectionValidation(
    createConnectionValidationRequest: requests.CreateConnectionValidationRequest
  ): Promise<responses.CreateConnectionValidationResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataIntegrationClient#createConnectionValidation.");
    const pathParams = {
      "{workspaceId}": createConnectionValidationRequest.workspaceId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createConnectionValidationRequest.opcRequestId,
      "opc-retry-token": createConnectionValidationRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/connectionValidations",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createConnectionValidationRequest.createConnectionValidationDetails,
        "CreateConnectionValidationDetails",
        models.CreateConnectionValidationDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateConnectionValidationResponse>{},
        body: await response.json(),
        bodyKey: "connectionValidation",
        bodyModel: "model.ConnectionValidation",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a data asset with default connection.
   * @param CreateDataAssetRequest
   * @return CreateDataAssetResponse
   * @throws OciError when an error occurs
   */
  public async createDataAsset(
    createDataAssetRequest: requests.CreateDataAssetRequest
  ): Promise<responses.CreateDataAssetResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#createDataAsset.");
    const pathParams = {
      "{workspaceId}": createDataAssetRequest.workspaceId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createDataAssetRequest.opcRequestId,
      "opc-retry-token": createDataAssetRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/dataAssets",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createDataAssetRequest.createDataAssetDetails,
        "CreateDataAssetDetails",
        models.CreateDataAssetDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateDataAssetResponse>{},
        body: await response.json(),
        bodyKey: "dataAsset",
        bodyModel: "model.DataAsset",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new data flow in a project or folder ready for performing data integrations.
   *
   * @param CreateDataFlowRequest
   * @return CreateDataFlowResponse
   * @throws OciError when an error occurs
   */
  public async createDataFlow(
    createDataFlowRequest: requests.CreateDataFlowRequest
  ): Promise<responses.CreateDataFlowResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#createDataFlow.");
    const pathParams = {
      "{workspaceId}": createDataFlowRequest.workspaceId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createDataFlowRequest.opcRetryToken,
      "opc-request-id": createDataFlowRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/dataFlows",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createDataFlowRequest.createDataFlowDetails,
        "CreateDataFlowDetails",
        models.CreateDataFlowDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateDataFlowResponse>{},
        body: await response.json(),
        bodyKey: "dataFlow",
        bodyModel: "model.DataFlow",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * The endpoint accepts the DataFlow object definition in the request payload and creates a DataFlow object validation.
   *
   * @param CreateDataFlowValidationRequest
   * @return CreateDataFlowValidationResponse
   * @throws OciError when an error occurs
   */
  public async createDataFlowValidation(
    createDataFlowValidationRequest: requests.CreateDataFlowValidationRequest
  ): Promise<responses.CreateDataFlowValidationResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataIntegrationClient#createDataFlowValidation.");
    const pathParams = {
      "{workspaceId}": createDataFlowValidationRequest.workspaceId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createDataFlowValidationRequest.opcRequestId,
      "opc-retry-token": createDataFlowValidationRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/dataFlowValidations",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createDataFlowValidationRequest.createDataFlowValidationDetails,
        "CreateDataFlowValidationDetails",
        models.CreateDataFlowValidationDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateDataFlowValidationResponse>{},
        body: await response.json(),
        bodyKey: "dataFlowValidation",
        bodyModel: "model.DataFlowValidation",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves the data entity shape from the end data system. The input can specify the data entity to get the shape for. For databases, this can be retrieved from the database data dictionary. For files, some hints as to the file properties can also be supplied in the input.
   * @param CreateEntityShapeRequest
   * @return CreateEntityShapeResponse
   * @throws OciError when an error occurs
   */
  public async createEntityShape(
    createEntityShapeRequest: requests.CreateEntityShapeRequest
  ): Promise<responses.CreateEntityShapeResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataIntegrationClient#createEntityShape.");
    const pathParams = {
      "{workspaceId}": createEntityShapeRequest.workspaceId,
      "{connectionKey}": createEntityShapeRequest.connectionKey,
      "{schemaResourceName}": createEntityShapeRequest.schemaResourceName
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createEntityShapeRequest.opcRequestId,
      "opc-retry-token": createEntityShapeRequest.opcRetryToken,
      "if-match": createEntityShapeRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/workspaces/{workspaceId}/connections/{connectionKey}/schemas/{schemaResourceName}/entityShapes",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createEntityShapeRequest.createEntityShapeDetails,
        "CreateEntityShapeDetails",
        models.CreateEntityShapeDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateEntityShapeResponse>{},
        body: await response.json(),
        bodyKey: "entityShape",
        bodyModel: "model.EntityShape",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a folder in a project or in another folder, limited to two levels of folders. |
   * Folders are used to organize your design-time resources, such as tasks or data flows.
   *
   * @param CreateFolderRequest
   * @return CreateFolderResponse
   * @throws OciError when an error occurs
   */
  public async createFolder(
    createFolderRequest: requests.CreateFolderRequest
  ): Promise<responses.CreateFolderResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#createFolder.");
    const pathParams = {
      "{workspaceId}": createFolderRequest.workspaceId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createFolderRequest.opcRetryToken,
      "opc-request-id": createFolderRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/folders",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createFolderRequest.createFolderDetails,
        "CreateFolderDetails",
        models.CreateFolderDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateFolderResponse>{},
        body: await response.json(),
        bodyKey: "folder",
        bodyModel: "model.Folder",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a patch in an application.
   * @param CreatePatchRequest
   * @return CreatePatchResponse
   * @throws OciError when an error occurs
   */
  public async createPatch(
    createPatchRequest: requests.CreatePatchRequest
  ): Promise<responses.CreatePatchResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#createPatch.");
    const pathParams = {
      "{workspaceId}": createPatchRequest.workspaceId,
      "{applicationKey}": createPatchRequest.applicationKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createPatchRequest.opcRequestId,
      "opc-retry-token": createPatchRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/applications/{applicationKey}/patches",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createPatchRequest.createPatchDetails,
        "CreatePatchDetails",
        models.CreatePatchDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreatePatchResponse>{},
        body: await response.json(),
        bodyKey: "patch",
        bodyModel: "model.Patch",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a project. Projects are organizational constructs within a workspace that you use to organize your design-time resources, such as tasks or data flows. Projects can be organized into folders.
   *
   * @param CreateProjectRequest
   * @return CreateProjectResponse
   * @throws OciError when an error occurs
   */
  public async createProject(
    createProjectRequest: requests.CreateProjectRequest
  ): Promise<responses.CreateProjectResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#createProject.");
    const pathParams = {
      "{workspaceId}": createProjectRequest.workspaceId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createProjectRequest.opcRetryToken,
      "opc-request-id": createProjectRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/projects",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createProjectRequest.createProjectDetails,
        "CreateProjectDetails",
        models.CreateProjectDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateProjectResponse>{},
        body: await response.json(),
        bodyKey: "project",
        bodyModel: "model.Project",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new task ready for performing data integrations. There are specialized types of tasks that include data loader and integration tasks.
   *
   * @param CreateTaskRequest
   * @return CreateTaskResponse
   * @throws OciError when an error occurs
   */
  public async createTask(
    createTaskRequest: requests.CreateTaskRequest
  ): Promise<responses.CreateTaskResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#createTask.");
    const pathParams = {
      "{workspaceId}": createTaskRequest.workspaceId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createTaskRequest.opcRetryToken,
      "opc-request-id": createTaskRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/tasks",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createTaskRequest.createTaskDetails,
        "CreateTaskDetails",
        models.CreateTaskDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateTaskResponse>{},
        body: await response.json(),
        bodyKey: "task",
        bodyModel: "model.Task",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a data integration task or task run. The task can be based on a dataflow design or a task.
   * @param CreateTaskRunRequest
   * @return CreateTaskRunResponse
   * @throws OciError when an error occurs
   */
  public async createTaskRun(
    createTaskRunRequest: requests.CreateTaskRunRequest
  ): Promise<responses.CreateTaskRunResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#createTaskRun.");
    const pathParams = {
      "{workspaceId}": createTaskRunRequest.workspaceId,
      "{applicationKey}": createTaskRunRequest.applicationKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createTaskRunRequest.opcRetryToken,
      "opc-request-id": createTaskRunRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/applications/{applicationKey}/taskRuns",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createTaskRunRequest.createTaskRunDetails,
        "CreateTaskRunDetails",
        models.CreateTaskRunDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateTaskRunResponse>{},
        body: await response.json(),
        bodyKey: "taskRun",
        bodyModel: "model.TaskRun",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Validates a specific task.
   * @param CreateTaskValidationRequest
   * @return CreateTaskValidationResponse
   * @throws OciError when an error occurs
   */
  public async createTaskValidation(
    createTaskValidationRequest: requests.CreateTaskValidationRequest
  ): Promise<responses.CreateTaskValidationResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataIntegrationClient#createTaskValidation.");
    const pathParams = {
      "{workspaceId}": createTaskValidationRequest.workspaceId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createTaskValidationRequest.opcRequestId,
      "opc-retry-token": createTaskValidationRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/taskValidations",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createTaskValidationRequest.createTaskValidationDetails,
        "CreateTaskValidationDetails",
        models.CreateTaskValidationDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateTaskValidationResponse>{},
        body: await response.json(),
        bodyKey: "taskValidation",
        bodyModel: "model.TaskValidation",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new Data Integration Workspace ready for performing data integration.
   *
   * @param CreateWorkspaceRequest
   * @return CreateWorkspaceResponse
   * @throws OciError when an error occurs
   */
  public async createWorkspace(
    createWorkspaceRequest: requests.CreateWorkspaceRequest
  ): Promise<responses.CreateWorkspaceResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#createWorkspace.");
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createWorkspaceRequest.opcRetryToken,
      "opc-request-id": createWorkspaceRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createWorkspaceRequest.createWorkspaceDetails,
        "CreateWorkspaceDetails",
        models.CreateWorkspaceDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateWorkspaceResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Removes an application using the specified identifier.
   * @param DeleteApplicationRequest
   * @return DeleteApplicationResponse
   * @throws OciError when an error occurs
   */
  public async deleteApplication(
    deleteApplicationRequest: requests.DeleteApplicationRequest
  ): Promise<responses.DeleteApplicationResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataIntegrationClient#deleteApplication.");
    const pathParams = {
      "{workspaceId}": deleteApplicationRequest.workspaceId,
      "{applicationKey}": deleteApplicationRequest.applicationKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteApplicationRequest.ifMatch,
      "opc-request-id": deleteApplicationRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/applications/{applicationKey}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteApplicationResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Removes a connection using the specified identifier.
   * @param DeleteConnectionRequest
   * @return DeleteConnectionResponse
   * @throws OciError when an error occurs
   */
  public async deleteConnection(
    deleteConnectionRequest: requests.DeleteConnectionRequest
  ): Promise<responses.DeleteConnectionResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#deleteConnection.");
    const pathParams = {
      "{workspaceId}": deleteConnectionRequest.workspaceId,
      "{connectionKey}": deleteConnectionRequest.connectionKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteConnectionRequest.ifMatch,
      "opc-request-id": deleteConnectionRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/connections/{connectionKey}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteConnectionResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Successfully accepted the delete request. The connection validation will be deleted.
   * @param DeleteConnectionValidationRequest
   * @return DeleteConnectionValidationResponse
   * @throws OciError when an error occurs
   */
  public async deleteConnectionValidation(
    deleteConnectionValidationRequest: requests.DeleteConnectionValidationRequest
  ): Promise<responses.DeleteConnectionValidationResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataIntegrationClient#deleteConnectionValidation.");
    const pathParams = {
      "{workspaceId}": deleteConnectionValidationRequest.workspaceId,
      "{connectionValidationKey}": deleteConnectionValidationRequest.connectionValidationKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteConnectionValidationRequest.ifMatch,
      "opc-request-id": deleteConnectionValidationRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/connectionValidations/{connectionValidationKey}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteConnectionValidationResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Removes a data asset using the specified identifier.
   * @param DeleteDataAssetRequest
   * @return DeleteDataAssetResponse
   * @throws OciError when an error occurs
   */
  public async deleteDataAsset(
    deleteDataAssetRequest: requests.DeleteDataAssetRequest
  ): Promise<responses.DeleteDataAssetResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#deleteDataAsset.");
    const pathParams = {
      "{workspaceId}": deleteDataAssetRequest.workspaceId,
      "{dataAssetKey}": deleteDataAssetRequest.dataAssetKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteDataAssetRequest.ifMatch,
      "opc-request-id": deleteDataAssetRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/dataAssets/{dataAssetKey}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteDataAssetResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Removes a data flow from a project or folder using the specified identifier.
   * @param DeleteDataFlowRequest
   * @return DeleteDataFlowResponse
   * @throws OciError when an error occurs
   */
  public async deleteDataFlow(
    deleteDataFlowRequest: requests.DeleteDataFlowRequest
  ): Promise<responses.DeleteDataFlowResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#deleteDataFlow.");
    const pathParams = {
      "{workspaceId}": deleteDataFlowRequest.workspaceId,
      "{dataFlowKey}": deleteDataFlowRequest.dataFlowKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteDataFlowRequest.ifMatch,
      "opc-request-id": deleteDataFlowRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/dataFlows/{dataFlowKey}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteDataFlowResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Removes a data flow validation using the specified identifier.
   * @param DeleteDataFlowValidationRequest
   * @return DeleteDataFlowValidationResponse
   * @throws OciError when an error occurs
   */
  public async deleteDataFlowValidation(
    deleteDataFlowValidationRequest: requests.DeleteDataFlowValidationRequest
  ): Promise<responses.DeleteDataFlowValidationResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataIntegrationClient#deleteDataFlowValidation.");
    const pathParams = {
      "{workspaceId}": deleteDataFlowValidationRequest.workspaceId,
      "{dataFlowValidationKey}": deleteDataFlowValidationRequest.dataFlowValidationKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteDataFlowValidationRequest.ifMatch,
      "opc-request-id": deleteDataFlowValidationRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/dataFlowValidations/{dataFlowValidationKey}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteDataFlowValidationResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Removes a folder from a project using the specified identifier.
   * @param DeleteFolderRequest
   * @return DeleteFolderResponse
   * @throws OciError when an error occurs
   */
  public async deleteFolder(
    deleteFolderRequest: requests.DeleteFolderRequest
  ): Promise<responses.DeleteFolderResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#deleteFolder.");
    const pathParams = {
      "{workspaceId}": deleteFolderRequest.workspaceId,
      "{folderKey}": deleteFolderRequest.folderKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteFolderRequest.ifMatch,
      "opc-request-id": deleteFolderRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/folders/{folderKey}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteFolderResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Removes a patch using the specified identifier.
   * @param DeletePatchRequest
   * @return DeletePatchResponse
   * @throws OciError when an error occurs
   */
  public async deletePatch(
    deletePatchRequest: requests.DeletePatchRequest
  ): Promise<responses.DeletePatchResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#deletePatch.");
    const pathParams = {
      "{workspaceId}": deletePatchRequest.workspaceId,
      "{applicationKey}": deletePatchRequest.applicationKey,
      "{patchKey}": deletePatchRequest.patchKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deletePatchRequest.ifMatch,
      "opc-request-id": deletePatchRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/applications/{applicationKey}/patches/{patchKey}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeletePatchResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Removes a project from the workspace using the specified identifier.
   * @param DeleteProjectRequest
   * @return DeleteProjectResponse
   * @throws OciError when an error occurs
   */
  public async deleteProject(
    deleteProjectRequest: requests.DeleteProjectRequest
  ): Promise<responses.DeleteProjectResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#deleteProject.");
    const pathParams = {
      "{workspaceId}": deleteProjectRequest.workspaceId,
      "{projectKey}": deleteProjectRequest.projectKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteProjectRequest.ifMatch,
      "opc-request-id": deleteProjectRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/projects/{projectKey}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteProjectResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Removes a task using the specified identifier.
   * @param DeleteTaskRequest
   * @return DeleteTaskResponse
   * @throws OciError when an error occurs
   */
  public async deleteTask(
    deleteTaskRequest: requests.DeleteTaskRequest
  ): Promise<responses.DeleteTaskResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#deleteTask.");
    const pathParams = {
      "{workspaceId}": deleteTaskRequest.workspaceId,
      "{taskKey}": deleteTaskRequest.taskKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteTaskRequest.ifMatch,
      "opc-request-id": deleteTaskRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/tasks/{taskKey}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteTaskResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes a task run using the specified identifier.
   * @param DeleteTaskRunRequest
   * @return DeleteTaskRunResponse
   * @throws OciError when an error occurs
   */
  public async deleteTaskRun(
    deleteTaskRunRequest: requests.DeleteTaskRunRequest
  ): Promise<responses.DeleteTaskRunResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#deleteTaskRun.");
    const pathParams = {
      "{workspaceId}": deleteTaskRunRequest.workspaceId,
      "{applicationKey}": deleteTaskRunRequest.applicationKey,
      "{taskRunKey}": deleteTaskRunRequest.taskRunKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteTaskRunRequest.ifMatch,
      "opc-request-id": deleteTaskRunRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/applications/{applicationKey}/taskRuns/{taskRunKey}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteTaskRunResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Removes a task validation using the specified identifier.
   *
   * @param DeleteTaskValidationRequest
   * @return DeleteTaskValidationResponse
   * @throws OciError when an error occurs
   */
  public async deleteTaskValidation(
    deleteTaskValidationRequest: requests.DeleteTaskValidationRequest
  ): Promise<responses.DeleteTaskValidationResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataIntegrationClient#deleteTaskValidation.");
    const pathParams = {
      "{workspaceId}": deleteTaskValidationRequest.workspaceId,
      "{taskValidationKey}": deleteTaskValidationRequest.taskValidationKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteTaskValidationRequest.ifMatch,
      "opc-request-id": deleteTaskValidationRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/taskValidations/{taskValidationKey}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteTaskValidationResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes a Data Integration Workspace resource by identifier
   * @param DeleteWorkspaceRequest
   * @return DeleteWorkspaceResponse
   * @throws OciError when an error occurs
   */
  public async deleteWorkspace(
    deleteWorkspaceRequest: requests.DeleteWorkspaceRequest
  ): Promise<responses.DeleteWorkspaceResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#deleteWorkspace.");
    const pathParams = {
      "{workspaceId}": deleteWorkspaceRequest.workspaceId
    };

    const queryParams = {
      "quiesceTimeout": deleteWorkspaceRequest.quiesceTimeout,
      "isForceOperation": deleteWorkspaceRequest.isForceOperation
    };

    let headerParams = {
      "if-match": deleteWorkspaceRequest.ifMatch,
      "opc-request-id": deleteWorkspaceRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteWorkspaceResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves an application using the specified identifier.
   * @param GetApplicationRequest
   * @return GetApplicationResponse
   * @throws OciError when an error occurs
   */
  public async getApplication(
    getApplicationRequest: requests.GetApplicationRequest
  ): Promise<responses.GetApplicationResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#getApplication.");
    const pathParams = {
      "{workspaceId}": getApplicationRequest.workspaceId,
      "{applicationKey}": getApplicationRequest.applicationKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getApplicationRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/applications/{applicationKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetApplicationResponse>{},
        body: await response.json(),
        bodyKey: "application",
        bodyModel: "model.Application",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves the connection details using the specified identifier.
   * @param GetConnectionRequest
   * @return GetConnectionResponse
   * @throws OciError when an error occurs
   */
  public async getConnection(
    getConnectionRequest: requests.GetConnectionRequest
  ): Promise<responses.GetConnectionResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#getConnection.");
    const pathParams = {
      "{workspaceId}": getConnectionRequest.workspaceId,
      "{connectionKey}": getConnectionRequest.connectionKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getConnectionRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/connections/{connectionKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetConnectionResponse>{},
        body: await response.json(),
        bodyKey: "connection",
        bodyModel: "model.Connection",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves a connection validation using the specified identifier.
   * @param GetConnectionValidationRequest
   * @return GetConnectionValidationResponse
   * @throws OciError when an error occurs
   */
  public async getConnectionValidation(
    getConnectionValidationRequest: requests.GetConnectionValidationRequest
  ): Promise<responses.GetConnectionValidationResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataIntegrationClient#getConnectionValidation.");
    const pathParams = {
      "{workspaceId}": getConnectionValidationRequest.workspaceId,
      "{connectionValidationKey}": getConnectionValidationRequest.connectionValidationKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getConnectionValidationRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/connectionValidations/{connectionValidationKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetConnectionValidationResponse>{},
        body: await response.json(),
        bodyKey: "connectionValidation",
        bodyModel: "model.ConnectionValidation",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves statistics on a workspace. It returns an object with an array of property values, such as the number of projects, |
   *        applications, data assets, and so on.
   *
   * @param GetCountStatisticRequest
   * @return GetCountStatisticResponse
   * @throws OciError when an error occurs
   */
  public async getCountStatistic(
    getCountStatisticRequest: requests.GetCountStatisticRequest
  ): Promise<responses.GetCountStatisticResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataIntegrationClient#getCountStatistic.");
    const pathParams = {
      "{workspaceId}": getCountStatisticRequest.workspaceId,
      "{countStatisticKey}": getCountStatisticRequest.countStatisticKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getCountStatisticRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/countStatistics/{countStatisticKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetCountStatisticResponse>{},
        body: await response.json(),
        bodyKey: "countStatistic",
        bodyModel: "model.CountStatistic",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves details of a data asset using the specified identifier.
   * @param GetDataAssetRequest
   * @return GetDataAssetResponse
   * @throws OciError when an error occurs
   */
  public async getDataAsset(
    getDataAssetRequest: requests.GetDataAssetRequest
  ): Promise<responses.GetDataAssetResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#getDataAsset.");
    const pathParams = {
      "{workspaceId}": getDataAssetRequest.workspaceId,
      "{dataAssetKey}": getDataAssetRequest.dataAssetKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getDataAssetRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/dataAssets/{dataAssetKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetDataAssetResponse>{},
        body: await response.json(),
        bodyKey: "dataAsset",
        bodyModel: "model.DataAsset",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves the data entity details with the given name from live schema.
   * @param GetDataEntityRequest
   * @return GetDataEntityResponse
   * @throws OciError when an error occurs
   */
  public async getDataEntity(
    getDataEntityRequest: requests.GetDataEntityRequest
  ): Promise<responses.GetDataEntityResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#getDataEntity.");
    const pathParams = {
      "{workspaceId}": getDataEntityRequest.workspaceId,
      "{connectionKey}": getDataEntityRequest.connectionKey,
      "{schemaResourceName}": getDataEntityRequest.schemaResourceName,
      "{dataEntityKey}": getDataEntityRequest.dataEntityKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getDataEntityRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/workspaces/{workspaceId}/connections/{connectionKey}/schemas/{schemaResourceName}/dataEntities/{dataEntityKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetDataEntityResponse>{},
        body: await response.json(),
        bodyKey: "dataEntity",
        bodyModel: "model.DataEntity",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves a data flow using the specified identifier.
   * @param GetDataFlowRequest
   * @return GetDataFlowResponse
   * @throws OciError when an error occurs
   */
  public async getDataFlow(
    getDataFlowRequest: requests.GetDataFlowRequest
  ): Promise<responses.GetDataFlowResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#getDataFlow.");
    const pathParams = {
      "{workspaceId}": getDataFlowRequest.workspaceId,
      "{dataFlowKey}": getDataFlowRequest.dataFlowKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getDataFlowRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/dataFlows/{dataFlowKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetDataFlowResponse>{},
        body: await response.json(),
        bodyKey: "dataFlow",
        bodyModel: "model.DataFlow",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves a data flow validation using the specified identifier.
   * @param GetDataFlowValidationRequest
   * @return GetDataFlowValidationResponse
   * @throws OciError when an error occurs
   */
  public async getDataFlowValidation(
    getDataFlowValidationRequest: requests.GetDataFlowValidationRequest
  ): Promise<responses.GetDataFlowValidationResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataIntegrationClient#getDataFlowValidation.");
    const pathParams = {
      "{workspaceId}": getDataFlowValidationRequest.workspaceId,
      "{dataFlowValidationKey}": getDataFlowValidationRequest.dataFlowValidationKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getDataFlowValidationRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/dataFlowValidations/{dataFlowValidationKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetDataFlowValidationResponse>{},
        body: await response.json(),
        bodyKey: "dataFlowValidation",
        bodyModel: "model.DataFlowValidation",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves the details of a dependent object from an application.
   * @param GetDependentObjectRequest
   * @return GetDependentObjectResponse
   * @throws OciError when an error occurs
   */
  public async getDependentObject(
    getDependentObjectRequest: requests.GetDependentObjectRequest
  ): Promise<responses.GetDependentObjectResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataIntegrationClient#getDependentObject.");
    const pathParams = {
      "{workspaceId}": getDependentObjectRequest.workspaceId,
      "{applicationKey}": getDependentObjectRequest.applicationKey,
      "{dependentObjectKey}": getDependentObjectRequest.dependentObjectKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getDependentObjectRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/workspaces/{workspaceId}/applications/{applicationKey}/dependentObjects/{dependentObjectKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetDependentObjectResponse>{},
        body: await response.json(),
        bodyKey: "dependentObject",
        bodyModel: "model.DependentObject",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves a folder using the specified identifier.
   * @param GetFolderRequest
   * @return GetFolderResponse
   * @throws OciError when an error occurs
   */
  public async getFolder(
    getFolderRequest: requests.GetFolderRequest
  ): Promise<responses.GetFolderResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#getFolder.");
    const pathParams = {
      "{workspaceId}": getFolderRequest.workspaceId,
      "{folderKey}": getFolderRequest.folderKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getFolderRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/folders/{folderKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetFolderResponse>{},
        body: await response.json(),
        bodyKey: "folder",
        bodyModel: "model.Folder",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves a patch in an application using the specified identifier.
   * @param GetPatchRequest
   * @return GetPatchResponse
   * @throws OciError when an error occurs
   */
  public async getPatch(
    getPatchRequest: requests.GetPatchRequest
  ): Promise<responses.GetPatchResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#getPatch.");
    const pathParams = {
      "{workspaceId}": getPatchRequest.workspaceId,
      "{applicationKey}": getPatchRequest.applicationKey,
      "{patchKey}": getPatchRequest.patchKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getPatchRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/applications/{applicationKey}/patches/{patchKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetPatchResponse>{},
        body: await response.json(),
        bodyKey: "patch",
        bodyModel: "model.Patch",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves a project using the specified identifier.
   * @param GetProjectRequest
   * @return GetProjectResponse
   * @throws OciError when an error occurs
   */
  public async getProject(
    getProjectRequest: requests.GetProjectRequest
  ): Promise<responses.GetProjectResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#getProject.");
    const pathParams = {
      "{workspaceId}": getProjectRequest.workspaceId,
      "{projectKey}": getProjectRequest.projectKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getProjectRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/projects/{projectKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetProjectResponse>{},
        body: await response.json(),
        bodyKey: "project",
        bodyModel: "model.Project",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves the details of a published object from an application.
   * @param GetPublishedObjectRequest
   * @return GetPublishedObjectResponse
   * @throws OciError when an error occurs
   */
  public async getPublishedObject(
    getPublishedObjectRequest: requests.GetPublishedObjectRequest
  ): Promise<responses.GetPublishedObjectResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataIntegrationClient#getPublishedObject.");
    const pathParams = {
      "{workspaceId}": getPublishedObjectRequest.workspaceId,
      "{applicationKey}": getPublishedObjectRequest.applicationKey,
      "{publishedObjectKey}": getPublishedObjectRequest.publishedObjectKey
    };

    const queryParams = {
      "expandReferences": getPublishedObjectRequest.expandReferences
    };

    let headerParams = {
      "opc-request-id": getPublishedObjectRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/workspaces/{workspaceId}/applications/{applicationKey}/publishedObjects/{publishedObjectKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetPublishedObjectResponse>{},
        body: await response.json(),
        bodyKey: "publishedObject",
        bodyModel: "model.PublishedObject",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves a schema that can be accessed using the specified connection.
   * @param GetSchemaRequest
   * @return GetSchemaResponse
   * @throws OciError when an error occurs
   */
  public async getSchema(
    getSchemaRequest: requests.GetSchemaRequest
  ): Promise<responses.GetSchemaResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#getSchema.");
    const pathParams = {
      "{workspaceId}": getSchemaRequest.workspaceId,
      "{connectionKey}": getSchemaRequest.connectionKey,
      "{schemaResourceName}": getSchemaRequest.schemaResourceName
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getSchemaRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/connections/{connectionKey}/schemas/{schemaResourceName}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetSchemaResponse>{},
        body: await response.json(),
        bodyKey: "schema",
        bodyModel: "model.Schema",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves a task using the specified identifier.
   * @param GetTaskRequest
   * @return GetTaskResponse
   * @throws OciError when an error occurs
   */
  public async getTask(
    getTaskRequest: requests.GetTaskRequest
  ): Promise<responses.GetTaskResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#getTask.");
    const pathParams = {
      "{workspaceId}": getTaskRequest.workspaceId,
      "{taskKey}": getTaskRequest.taskKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getTaskRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/tasks/{taskKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetTaskResponse>{},
        body: await response.json(),
        bodyKey: "task",
        bodyModel: "model.Task",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves a task run using the specified identifier.
   * @param GetTaskRunRequest
   * @return GetTaskRunResponse
   * @throws OciError when an error occurs
   */
  public async getTaskRun(
    getTaskRunRequest: requests.GetTaskRunRequest
  ): Promise<responses.GetTaskRunResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#getTaskRun.");
    const pathParams = {
      "{workspaceId}": getTaskRunRequest.workspaceId,
      "{applicationKey}": getTaskRunRequest.applicationKey,
      "{taskRunKey}": getTaskRunRequest.taskRunKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getTaskRunRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/applications/{applicationKey}/taskRuns/{taskRunKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetTaskRunResponse>{},
        body: await response.json(),
        bodyKey: "taskRun",
        bodyModel: "model.TaskRun",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves a task validation using the specified identifier.
   *
   * @param GetTaskValidationRequest
   * @return GetTaskValidationResponse
   * @throws OciError when an error occurs
   */
  public async getTaskValidation(
    getTaskValidationRequest: requests.GetTaskValidationRequest
  ): Promise<responses.GetTaskValidationResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataIntegrationClient#getTaskValidation.");
    const pathParams = {
      "{workspaceId}": getTaskValidationRequest.workspaceId,
      "{taskValidationKey}": getTaskValidationRequest.taskValidationKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getTaskValidationRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/taskValidations/{taskValidationKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetTaskValidationResponse>{},
        body: await response.json(),
        bodyKey: "taskValidation",
        bodyModel: "model.TaskValidation",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the status of the work request with the given ID.
   * @param GetWorkRequestRequest
   * @return GetWorkRequestResponse
   * @throws OciError when an error occurs
   */
  public async getWorkRequest(
    getWorkRequestRequest: requests.GetWorkRequestRequest
  ): Promise<responses.GetWorkRequestResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#getWorkRequest.");
    const pathParams = {
      "{workRequestId}": getWorkRequestRequest.workRequestId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getWorkRequestRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests/{workRequestId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetWorkRequestResponse>{},
        body: await response.json(),
        bodyKey: "workRequest",
        bodyModel: "model.WorkRequest",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("retry-after"),
            key: "retryAfter",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets a Data Integration Workspace by identifier
   * @param GetWorkspaceRequest
   * @return GetWorkspaceResponse
   * @throws OciError when an error occurs
   */
  public async getWorkspace(
    getWorkspaceRequest: requests.GetWorkspaceRequest
  ): Promise<responses.GetWorkspaceResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#getWorkspace.");
    const pathParams = {
      "{workspaceId}": getWorkspaceRequest.workspaceId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getWorkspaceRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetWorkspaceResponse>{},
        body: await response.json(),
        bodyKey: "workspace",
        bodyModel: "model.Workspace",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves a list of applications and provides options to filter the list.
   * @param ListApplicationsRequest
   * @return ListApplicationsResponse
   * @throws OciError when an error occurs
   */
  public async listApplications(
    listApplicationsRequest: requests.ListApplicationsRequest
  ): Promise<responses.ListApplicationsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#listApplications.");
    const pathParams = {
      "{workspaceId}": listApplicationsRequest.workspaceId
    };

    const queryParams = {
      "name": listApplicationsRequest.name,
      "identifier": listApplicationsRequest.identifier,
      "fields": listApplicationsRequest.fields,
      "limit": listApplicationsRequest.limit,
      "page": listApplicationsRequest.page,
      "sortOrder": listApplicationsRequest.sortOrder,
      "sortBy": listApplicationsRequest.sortBy
    };

    let headerParams = {
      "opc-request-id": listApplicationsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/applications",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListApplicationsResponse>{},
        body: await response.json(),
        bodyKey: "applicationSummaryCollection",
        bodyModel: "model.ApplicationSummaryCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves a list of connection validations within the specified workspace.
   * @param ListConnectionValidationsRequest
   * @return ListConnectionValidationsResponse
   * @throws OciError when an error occurs
   */
  public async listConnectionValidations(
    listConnectionValidationsRequest: requests.ListConnectionValidationsRequest
  ): Promise<responses.ListConnectionValidationsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataIntegrationClient#listConnectionValidations.");
    const pathParams = {
      "{workspaceId}": listConnectionValidationsRequest.workspaceId
    };

    const queryParams = {
      "key": listConnectionValidationsRequest.key,
      "name": listConnectionValidationsRequest.name,
      "identifier": listConnectionValidationsRequest.identifier,
      "fields": listConnectionValidationsRequest.fields,
      "page": listConnectionValidationsRequest.page,
      "limit": listConnectionValidationsRequest.limit,
      "sortBy": listConnectionValidationsRequest.sortBy,
      "sortOrder": listConnectionValidationsRequest.sortOrder
    };

    let headerParams = {
      "opc-request-id": listConnectionValidationsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/connectionValidations",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListConnectionValidationsResponse>{},
        body: await response.json(),
        bodyKey: "connectionValidationSummaryCollection",
        bodyModel: "model.ConnectionValidationSummaryCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves a list of all connections.
   * @param ListConnectionsRequest
   * @return ListConnectionsResponse
   * @throws OciError when an error occurs
   */
  public async listConnections(
    listConnectionsRequest: requests.ListConnectionsRequest
  ): Promise<responses.ListConnectionsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#listConnections.");
    const pathParams = {
      "{workspaceId}": listConnectionsRequest.workspaceId
    };

    const queryParams = {
      "dataAssetKey": listConnectionsRequest.dataAssetKey,
      "name": listConnectionsRequest.name,
      "page": listConnectionsRequest.page,
      "limit": listConnectionsRequest.limit,
      "fields": listConnectionsRequest.fields,
      "type": listConnectionsRequest.type,
      "sortBy": listConnectionsRequest.sortBy,
      "sortOrder": listConnectionsRequest.sortOrder
    };

    let headerParams = {
      "opc-request-id": listConnectionsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/connections",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListConnectionsResponse>{},
        body: await response.json(),
        bodyKey: "connectionSummaryCollection",
        bodyModel: "model.ConnectionSummaryCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * This endpoint can be used to list all data asset summaries
   *
   * @param ListDataAssetsRequest
   * @return ListDataAssetsResponse
   * @throws OciError when an error occurs
   */
  public async listDataAssets(
    listDataAssetsRequest: requests.ListDataAssetsRequest
  ): Promise<responses.ListDataAssetsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#listDataAssets.");
    const pathParams = {
      "{workspaceId}": listDataAssetsRequest.workspaceId
    };

    const queryParams = {
      "page": listDataAssetsRequest.page,
      "limit": listDataAssetsRequest.limit,
      "fields": listDataAssetsRequest.fields,
      "type": listDataAssetsRequest.type,
      "sortBy": listDataAssetsRequest.sortBy,
      "sortOrder": listDataAssetsRequest.sortOrder,
      "name": listDataAssetsRequest.name
    };

    let headerParams = {
      "opc-request-id": listDataAssetsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/dataAssets",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListDataAssetsResponse>{},
        body: await response.json(),
        bodyKey: "dataAssetSummaryCollection",
        bodyModel: "model.DataAssetSummaryCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves a list of summaries of data entities present in the schema identified by schema name. |
   * A live query is run on the data asset identified via the connection specified.
   *
   * @param ListDataEntitiesRequest
   * @return ListDataEntitiesResponse
   * @throws OciError when an error occurs
   */
  public async listDataEntities(
    listDataEntitiesRequest: requests.ListDataEntitiesRequest
  ): Promise<responses.ListDataEntitiesResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#listDataEntities.");
    const pathParams = {
      "{workspaceId}": listDataEntitiesRequest.workspaceId,
      "{connectionKey}": listDataEntitiesRequest.connectionKey,
      "{schemaResourceName}": listDataEntitiesRequest.schemaResourceName
    };

    const queryParams = {
      "name": listDataEntitiesRequest.name,
      "page": listDataEntitiesRequest.page,
      "type": listDataEntitiesRequest.type,
      "limit": listDataEntitiesRequest.limit,
      "fields": listDataEntitiesRequest.fields,
      "sortBy": listDataEntitiesRequest.sortBy,
      "sortOrder": listDataEntitiesRequest.sortOrder
    };

    let headerParams = {
      "opc-request-id": listDataEntitiesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/workspaces/{workspaceId}/connections/{connectionKey}/schemas/{schemaResourceName}/dataEntities",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListDataEntitiesResponse>{},
        body: await response.json(),
        bodyKey: "dataEntitySummaryCollection",
        bodyModel: "model.DataEntitySummaryCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves a list of data flow validations within the specified workspace
   * @param ListDataFlowValidationsRequest
   * @return ListDataFlowValidationsResponse
   * @throws OciError when an error occurs
   */
  public async listDataFlowValidations(
    listDataFlowValidationsRequest: requests.ListDataFlowValidationsRequest
  ): Promise<responses.ListDataFlowValidationsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataIntegrationClient#listDataFlowValidations.");
    const pathParams = {
      "{workspaceId}": listDataFlowValidationsRequest.workspaceId
    };

    const queryParams = {
      "key": listDataFlowValidationsRequest.key,
      "name": listDataFlowValidationsRequest.name,
      "identifier": listDataFlowValidationsRequest.identifier,
      "fields": listDataFlowValidationsRequest.fields,
      "page": listDataFlowValidationsRequest.page,
      "limit": listDataFlowValidationsRequest.limit,
      "sortBy": listDataFlowValidationsRequest.sortBy,
      "sortOrder": listDataFlowValidationsRequest.sortOrder
    };

    let headerParams = {
      "opc-request-id": listDataFlowValidationsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/dataFlowValidations",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListDataFlowValidationsResponse>{},
        body: await response.json(),
        bodyKey: "dataFlowValidationSummaryCollection",
        bodyModel: "model.DataFlowValidationSummaryCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves a list of data flows in a project or folder.
   *
   * @param ListDataFlowsRequest
   * @return ListDataFlowsResponse
   * @throws OciError when an error occurs
   */
  public async listDataFlows(
    listDataFlowsRequest: requests.ListDataFlowsRequest
  ): Promise<responses.ListDataFlowsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#listDataFlows.");
    const pathParams = {
      "{workspaceId}": listDataFlowsRequest.workspaceId
    };

    const queryParams = {
      "folderId": listDataFlowsRequest.folderId,
      "fields": listDataFlowsRequest.fields,
      "name": listDataFlowsRequest.name,
      "identifier": listDataFlowsRequest.identifier,
      "limit": listDataFlowsRequest.limit,
      "page": listDataFlowsRequest.page,
      "sortOrder": listDataFlowsRequest.sortOrder,
      "sortBy": listDataFlowsRequest.sortBy
    };

    let headerParams = {
      "opc-request-id": listDataFlowsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/dataFlows",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListDataFlowsResponse>{},
        body: await response.json(),
        bodyKey: "dataFlowSummaryCollection",
        bodyModel: "model.DataFlowSummaryCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves a list of all dependent objects for a specific application.
   * @param ListDependentObjectsRequest
   * @return ListDependentObjectsResponse
   * @throws OciError when an error occurs
   */
  public async listDependentObjects(
    listDependentObjectsRequest: requests.ListDependentObjectsRequest
  ): Promise<responses.ListDependentObjectsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataIntegrationClient#listDependentObjects.");
    const pathParams = {
      "{workspaceId}": listDependentObjectsRequest.workspaceId,
      "{applicationKey}": listDependentObjectsRequest.applicationKey
    };

    const queryParams = {
      "fields": listDependentObjectsRequest.fields,
      "name": listDependentObjectsRequest.name,
      "identifier": listDependentObjectsRequest.identifier,
      "type": listDependentObjectsRequest.type,
      "typeInSubtree": listDependentObjectsRequest.typeInSubtree,
      "limit": listDependentObjectsRequest.limit,
      "page": listDependentObjectsRequest.page,
      "sortOrder": listDependentObjectsRequest.sortOrder,
      "sortBy": listDependentObjectsRequest.sortBy
    };

    let headerParams = {
      "opc-request-id": listDependentObjectsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/applications/{applicationKey}/dependentObjects",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListDependentObjectsResponse>{},
        body: await response.json(),
        bodyKey: "dependentObjectSummaryCollection",
        bodyModel: "model.DependentObjectSummaryCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves a list of folders in a project and provides options to filter the list.
   *
   * @param ListFoldersRequest
   * @return ListFoldersResponse
   * @throws OciError when an error occurs
   */
  public async listFolders(
    listFoldersRequest: requests.ListFoldersRequest
  ): Promise<responses.ListFoldersResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#listFolders.");
    const pathParams = {
      "{workspaceId}": listFoldersRequest.workspaceId
    };

    const queryParams = {
      "aggregatorKey": listFoldersRequest.aggregatorKey,
      "fields": listFoldersRequest.fields,
      "name": listFoldersRequest.name,
      "identifier": listFoldersRequest.identifier,
      "page": listFoldersRequest.page,
      "limit": listFoldersRequest.limit,
      "sortOrder": listFoldersRequest.sortOrder,
      "sortBy": listFoldersRequest.sortBy
    };

    let headerParams = {
      "opc-request-id": listFoldersRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/folders",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListFoldersResponse>{},
        body: await response.json(),
        bodyKey: "folderSummaryCollection",
        bodyModel: "model.FolderSummaryCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves a list of patches in an application and provides options to filter the list.
   * @param ListPatchesRequest
   * @return ListPatchesResponse
   * @throws OciError when an error occurs
   */
  public async listPatches(
    listPatchesRequest: requests.ListPatchesRequest
  ): Promise<responses.ListPatchesResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#listPatches.");
    const pathParams = {
      "{workspaceId}": listPatchesRequest.workspaceId,
      "{applicationKey}": listPatchesRequest.applicationKey
    };

    const queryParams = {
      "name": listPatchesRequest.name,
      "identifier": listPatchesRequest.identifier,
      "fields": listPatchesRequest.fields,
      "limit": listPatchesRequest.limit,
      "page": listPatchesRequest.page,
      "sortOrder": listPatchesRequest.sortOrder,
      "sortBy": listPatchesRequest.sortBy
    };

    let headerParams = {
      "opc-request-id": listPatchesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/applications/{applicationKey}/patches",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListPatchesResponse>{},
        body: await response.json(),
        bodyKey: "patchSummaryCollection",
        bodyModel: "model.PatchSummaryCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves a lists of projects in a workspace and provides options to filter the list.
   *
   * @param ListProjectsRequest
   * @return ListProjectsResponse
   * @throws OciError when an error occurs
   */
  public async listProjects(
    listProjectsRequest: requests.ListProjectsRequest
  ): Promise<responses.ListProjectsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#listProjects.");
    const pathParams = {
      "{workspaceId}": listProjectsRequest.workspaceId
    };

    const queryParams = {
      "fields": listProjectsRequest.fields,
      "name": listProjectsRequest.name,
      "identifier": listProjectsRequest.identifier,
      "page": listProjectsRequest.page,
      "limit": listProjectsRequest.limit,
      "sortOrder": listProjectsRequest.sortOrder,
      "sortBy": listProjectsRequest.sortBy
    };

    let headerParams = {
      "opc-request-id": listProjectsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/projects",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListProjectsResponse>{},
        body: await response.json(),
        bodyKey: "projectSummaryCollection",
        bodyModel: "model.ProjectSummaryCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves a list of all the published objects for a specified application.
   * @param ListPublishedObjectsRequest
   * @return ListPublishedObjectsResponse
   * @throws OciError when an error occurs
   */
  public async listPublishedObjects(
    listPublishedObjectsRequest: requests.ListPublishedObjectsRequest
  ): Promise<responses.ListPublishedObjectsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataIntegrationClient#listPublishedObjects.");
    const pathParams = {
      "{workspaceId}": listPublishedObjectsRequest.workspaceId,
      "{applicationKey}": listPublishedObjectsRequest.applicationKey
    };

    const queryParams = {
      "fields": listPublishedObjectsRequest.fields,
      "name": listPublishedObjectsRequest.name,
      "identifier": listPublishedObjectsRequest.identifier,
      "type": listPublishedObjectsRequest.type,
      "typeInSubtree": listPublishedObjectsRequest.typeInSubtree,
      "limit": listPublishedObjectsRequest.limit,
      "page": listPublishedObjectsRequest.page,
      "sortOrder": listPublishedObjectsRequest.sortOrder,
      "sortBy": listPublishedObjectsRequest.sortBy
    };

    let headerParams = {
      "opc-request-id": listPublishedObjectsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/applications/{applicationKey}/publishedObjects",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListPublishedObjectsResponse>{},
        body: await response.json(),
        bodyKey: "publishedObjectSummaryCollection",
        bodyModel: "model.PublishedObjectSummaryCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves a list of all the schemas that can be accessed using the specified connection.
   * @param ListSchemasRequest
   * @return ListSchemasResponse
   * @throws OciError when an error occurs
   */
  public async listSchemas(
    listSchemasRequest: requests.ListSchemasRequest
  ): Promise<responses.ListSchemasResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#listSchemas.");
    const pathParams = {
      "{workspaceId}": listSchemasRequest.workspaceId,
      "{connectionKey}": listSchemasRequest.connectionKey
    };

    const queryParams = {
      "page": listSchemasRequest.page,
      "limit": listSchemasRequest.limit,
      "fields": listSchemasRequest.fields,
      "sortBy": listSchemasRequest.sortBy,
      "sortOrder": listSchemasRequest.sortOrder,
      "schemaResourceName": listSchemasRequest.schemaResourceName,
      "name": listSchemasRequest.name
    };

    let headerParams = {
      "opc-request-id": listSchemasRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/connections/{connectionKey}/schemas",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListSchemasResponse>{},
        body: await response.json(),
        bodyKey: "schemaSummaryCollection",
        bodyModel: "model.SchemaSummaryCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Get log entries for task runs using its key
   * @param ListTaskRunLogsRequest
   * @return ListTaskRunLogsResponse
   * @throws OciError when an error occurs
   */
  public async listTaskRunLogs(
    listTaskRunLogsRequest: requests.ListTaskRunLogsRequest
  ): Promise<responses.ListTaskRunLogsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#listTaskRunLogs.");
    const pathParams = {
      "{workspaceId}": listTaskRunLogsRequest.workspaceId,
      "{applicationKey}": listTaskRunLogsRequest.applicationKey,
      "{taskRunKey}": listTaskRunLogsRequest.taskRunKey
    };

    const queryParams = {
      "page": listTaskRunLogsRequest.page,
      "limit": listTaskRunLogsRequest.limit,
      "sortOrder": listTaskRunLogsRequest.sortOrder,
      "sortBy": listTaskRunLogsRequest.sortBy
    };

    let headerParams = {
      "opc-request-id": listTaskRunLogsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/applications/{applicationKey}/taskRuns/{taskRunKey}/logs",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListTaskRunLogsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "TaskRunLogSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.TaskRunLogSummary objects
   * contained in responses from the listTaskRunLogs operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllTaskRunLogs(
    request: requests.ListTaskRunLogsRequest
  ): AsyncIterableIterator<models.TaskRunLogSummary> {
    return paginateRecords(request, req => this.listTaskRunLogs(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listTaskRunLogs operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllTaskRunLogsResponses(
    request: requests.ListTaskRunLogsRequest
  ): AsyncIterableIterator<responses.ListTaskRunLogsResponse> {
    return paginateResponses(request, req => this.listTaskRunLogs(req));
  }

  /**
   * Retrieves a list of task runs and provides options to filter the list.
   * @param ListTaskRunsRequest
   * @return ListTaskRunsResponse
   * @throws OciError when an error occurs
   */
  public async listTaskRuns(
    listTaskRunsRequest: requests.ListTaskRunsRequest
  ): Promise<responses.ListTaskRunsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#listTaskRuns.");
    const pathParams = {
      "{workspaceId}": listTaskRunsRequest.workspaceId,
      "{applicationKey}": listTaskRunsRequest.applicationKey
    };

    const queryParams = {
      "fields": listTaskRunsRequest.fields,
      "name": listTaskRunsRequest.name,
      "identifier": listTaskRunsRequest.identifier,
      "page": listTaskRunsRequest.page,
      "limit": listTaskRunsRequest.limit,
      "sortOrder": listTaskRunsRequest.sortOrder,
      "sortBy": listTaskRunsRequest.sortBy
    };

    let headerParams = {
      "opc-request-id": listTaskRunsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/applications/{applicationKey}/taskRuns",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListTaskRunsResponse>{},
        body: await response.json(),
        bodyKey: "taskRunSummaryCollection",
        bodyModel: "model.TaskRunSummaryCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves a list of task validations within the specified workspace.
   *
   * @param ListTaskValidationsRequest
   * @return ListTaskValidationsResponse
   * @throws OciError when an error occurs
   */
  public async listTaskValidations(
    listTaskValidationsRequest: requests.ListTaskValidationsRequest
  ): Promise<responses.ListTaskValidationsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataIntegrationClient#listTaskValidations.");
    const pathParams = {
      "{workspaceId}": listTaskValidationsRequest.workspaceId
    };

    const queryParams = {
      "key": listTaskValidationsRequest.key,
      "name": listTaskValidationsRequest.name,
      "identifier": listTaskValidationsRequest.identifier,
      "fields": listTaskValidationsRequest.fields,
      "page": listTaskValidationsRequest.page,
      "limit": listTaskValidationsRequest.limit,
      "sortBy": listTaskValidationsRequest.sortBy,
      "sortOrder": listTaskValidationsRequest.sortOrder
    };

    let headerParams = {
      "opc-request-id": listTaskValidationsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/taskValidations",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListTaskValidationsResponse>{},
        body: await response.json(),
        bodyKey: "taskValidationSummaryCollection",
        bodyModel: "model.TaskValidationSummaryCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves a list of all tasks in a specified project or folder.
   *
   * @param ListTasksRequest
   * @return ListTasksResponse
   * @throws OciError when an error occurs
   */
  public async listTasks(
    listTasksRequest: requests.ListTasksRequest
  ): Promise<responses.ListTasksResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#listTasks.");
    const pathParams = {
      "{workspaceId}": listTasksRequest.workspaceId
    };

    const queryParams = {
      "folderId": listTasksRequest.folderId,
      "fields": listTasksRequest.fields,
      "name": listTasksRequest.name,
      "key": listTasksRequest.key,
      "identifier": listTasksRequest.identifier,
      "type": listTasksRequest.type,
      "limit": listTasksRequest.limit,
      "page": listTasksRequest.page,
      "sortOrder": listTasksRequest.sortOrder,
      "sortBy": listTasksRequest.sortBy
    };

    let headerParams = {
      "opc-request-id": listTasksRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/tasks",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListTasksResponse>{},
        body: await response.json(),
        bodyKey: "taskSummaryCollection",
        bodyModel: "model.TaskSummaryCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Return a (paginated) list of errors for a given work request.
   *
   * @param ListWorkRequestErrorsRequest
   * @return ListWorkRequestErrorsResponse
   * @throws OciError when an error occurs
   */
  public async listWorkRequestErrors(
    listWorkRequestErrorsRequest: requests.ListWorkRequestErrorsRequest
  ): Promise<responses.ListWorkRequestErrorsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataIntegrationClient#listWorkRequestErrors.");
    const pathParams = {
      "{workRequestId}": listWorkRequestErrorsRequest.workRequestId
    };

    const queryParams = {
      "page": listWorkRequestErrorsRequest.page,
      "limit": listWorkRequestErrorsRequest.limit,
      "sortOrder": listWorkRequestErrorsRequest.sortOrder,
      "sortBy": listWorkRequestErrorsRequest.sortBy
    };

    let headerParams = {
      "opc-request-id": listWorkRequestErrorsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests/{workRequestId}/workRequestErrors",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListWorkRequestErrorsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "WorkRequestError[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.WorkRequestError objects
   * contained in responses from the listWorkRequestErrors operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequestErrors(
    request: requests.ListWorkRequestErrorsRequest
  ): AsyncIterableIterator<models.WorkRequestError> {
    return paginateRecords(request, req => this.listWorkRequestErrors(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listWorkRequestErrors operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequestErrorsResponses(
    request: requests.ListWorkRequestErrorsRequest
  ): AsyncIterableIterator<responses.ListWorkRequestErrorsResponse> {
    return paginateResponses(request, req => this.listWorkRequestErrors(req));
  }

  /**
   * Return a (paginated) list of logs for a given work request.
   *
   * @param ListWorkRequestLogsRequest
   * @return ListWorkRequestLogsResponse
   * @throws OciError when an error occurs
   */
  public async listWorkRequestLogs(
    listWorkRequestLogsRequest: requests.ListWorkRequestLogsRequest
  ): Promise<responses.ListWorkRequestLogsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataIntegrationClient#listWorkRequestLogs.");
    const pathParams = {
      "{workRequestId}": listWorkRequestLogsRequest.workRequestId
    };

    const queryParams = {
      "page": listWorkRequestLogsRequest.page,
      "limit": listWorkRequestLogsRequest.limit,
      "sortOrder": listWorkRequestLogsRequest.sortOrder,
      "sortBy": listWorkRequestLogsRequest.sortBy
    };

    let headerParams = {
      "opc-request-id": listWorkRequestLogsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests/{workRequestId}/logs",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListWorkRequestLogsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "WorkRequestLogEntry[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.WorkRequestLogEntry objects
   * contained in responses from the listWorkRequestLogs operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequestLogs(
    request: requests.ListWorkRequestLogsRequest
  ): AsyncIterableIterator<models.WorkRequestLogEntry> {
    return paginateRecords(request, req => this.listWorkRequestLogs(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listWorkRequestLogs operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequestLogsResponses(
    request: requests.ListWorkRequestLogsRequest
  ): AsyncIterableIterator<responses.ListWorkRequestLogsResponse> {
    return paginateResponses(request, req => this.listWorkRequestLogs(req));
  }

  /**
   * Lists the work requests in a compartment.
   *
   * @param ListWorkRequestsRequest
   * @return ListWorkRequestsResponse
   * @throws OciError when an error occurs
   */
  public async listWorkRequests(
    listWorkRequestsRequest: requests.ListWorkRequestsRequest
  ): Promise<responses.ListWorkRequestsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#listWorkRequests.");
    const pathParams = {};

    const queryParams = {
      "compartmentId": listWorkRequestsRequest.compartmentId,
      "workRequestStatus": listWorkRequestsRequest.workRequestStatus,
      "page": listWorkRequestsRequest.page,
      "limit": listWorkRequestsRequest.limit,
      "sortOrder": listWorkRequestsRequest.sortOrder,
      "sortBy": listWorkRequestsRequest.sortBy
    };

    let headerParams = {
      "opc-request-id": listWorkRequestsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListWorkRequestsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "WorkRequestSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.WorkRequestSummary objects
   * contained in responses from the listWorkRequests operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequests(
    request: requests.ListWorkRequestsRequest
  ): AsyncIterableIterator<models.WorkRequestSummary> {
    return paginateRecords(request, req => this.listWorkRequests(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listWorkRequests operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequestsResponses(
    request: requests.ListWorkRequestsRequest
  ): AsyncIterableIterator<responses.ListWorkRequestsResponse> {
    return paginateResponses(request, req => this.listWorkRequests(req));
  }

  /**
   * Returns a list of Data Integration Workspaces.
   *
   * @param ListWorkspacesRequest
   * @return ListWorkspacesResponse
   * @throws OciError when an error occurs
   */
  public async listWorkspaces(
    listWorkspacesRequest: requests.ListWorkspacesRequest
  ): Promise<responses.ListWorkspacesResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#listWorkspaces.");
    const pathParams = {};

    const queryParams = {
      "compartmentId": listWorkspacesRequest.compartmentId,
      "name": listWorkspacesRequest.name,
      "limit": listWorkspacesRequest.limit,
      "page": listWorkspacesRequest.page,
      "lifecycleState": listWorkspacesRequest.lifecycleState,
      "sortOrder": listWorkspacesRequest.sortOrder,
      "sortBy": listWorkspacesRequest.sortBy
    };

    let headerParams = {
      "opc-request-id": listWorkspacesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListWorkspacesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "WorkspaceSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.WorkspaceSummary objects
   * contained in responses from the listWorkspaces operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkspaces(
    request: requests.ListWorkspacesRequest
  ): AsyncIterableIterator<models.WorkspaceSummary> {
    return paginateRecords(request, req => this.listWorkspaces(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listWorkspaces operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkspacesResponses(
    request: requests.ListWorkspacesRequest
  ): AsyncIterableIterator<responses.ListWorkspacesResponse> {
    return paginateResponses(request, req => this.listWorkspaces(req));
  }

  /**
   * The workspace will be started.
   *
   * @param StartWorkspaceRequest
   * @return StartWorkspaceResponse
   * @throws OciError when an error occurs
   */
  public async startWorkspace(
    startWorkspaceRequest: requests.StartWorkspaceRequest
  ): Promise<responses.StartWorkspaceResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#startWorkspace.");
    const pathParams = {
      "{workspaceId}": startWorkspaceRequest.workspaceId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": startWorkspaceRequest.ifMatch,
      "opc-request-id": startWorkspaceRequest.opcRequestId,
      "opc-retry-token": startWorkspaceRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/actions/start",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.StartWorkspaceResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * The workspace will be stopped.
   *
   * @param StopWorkspaceRequest
   * @return StopWorkspaceResponse
   * @throws OciError when an error occurs
   */
  public async stopWorkspace(
    stopWorkspaceRequest: requests.StopWorkspaceRequest
  ): Promise<responses.StopWorkspaceResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#stopWorkspace.");
    const pathParams = {
      "{workspaceId}": stopWorkspaceRequest.workspaceId
    };

    const queryParams = {
      "quiesceTimeout": stopWorkspaceRequest.quiesceTimeout,
      "isForceOperation": stopWorkspaceRequest.isForceOperation
    };

    let headerParams = {
      "if-match": stopWorkspaceRequest.ifMatch,
      "opc-request-id": stopWorkspaceRequest.opcRequestId,
      "opc-retry-token": stopWorkspaceRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/actions/stop",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.StopWorkspaceResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates an application.
   * @param UpdateApplicationRequest
   * @return UpdateApplicationResponse
   * @throws OciError when an error occurs
   */
  public async updateApplication(
    updateApplicationRequest: requests.UpdateApplicationRequest
  ): Promise<responses.UpdateApplicationResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataIntegrationClient#updateApplication.");
    const pathParams = {
      "{workspaceId}": updateApplicationRequest.workspaceId,
      "{applicationKey}": updateApplicationRequest.applicationKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateApplicationRequest.ifMatch,
      "opc-request-id": updateApplicationRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/applications/{applicationKey}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateApplicationRequest.updateApplicationDetails,
        "UpdateApplicationDetails",
        models.UpdateApplicationDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateApplicationResponse>{},
        body: await response.json(),
        bodyKey: "application",
        bodyModel: "model.Application",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates a connection under a data asset.
   * @param UpdateConnectionRequest
   * @return UpdateConnectionResponse
   * @throws OciError when an error occurs
   */
  public async updateConnection(
    updateConnectionRequest: requests.UpdateConnectionRequest
  ): Promise<responses.UpdateConnectionResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#updateConnection.");
    const pathParams = {
      "{workspaceId}": updateConnectionRequest.workspaceId,
      "{connectionKey}": updateConnectionRequest.connectionKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": updateConnectionRequest.opcRequestId,
      "if-match": updateConnectionRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/connections/{connectionKey}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateConnectionRequest.updateConnectionDetails,
        "UpdateConnectionDetails",
        models.UpdateConnectionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateConnectionResponse>{},
        body: await response.json(),
        bodyKey: "connection",
        bodyModel: "model.Connection",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates a specific data asset with default connection.
   * @param UpdateDataAssetRequest
   * @return UpdateDataAssetResponse
   * @throws OciError when an error occurs
   */
  public async updateDataAsset(
    updateDataAssetRequest: requests.UpdateDataAssetRequest
  ): Promise<responses.UpdateDataAssetResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#updateDataAsset.");
    const pathParams = {
      "{workspaceId}": updateDataAssetRequest.workspaceId,
      "{dataAssetKey}": updateDataAssetRequest.dataAssetKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": updateDataAssetRequest.opcRequestId,
      "if-match": updateDataAssetRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/dataAssets/{dataAssetKey}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateDataAssetRequest.updateDataAssetDetails,
        "UpdateDataAssetDetails",
        models.UpdateDataAssetDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateDataAssetResponse>{},
        body: await response.json(),
        bodyKey: "dataAsset",
        bodyModel: "model.DataAsset",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates a specific data flow.
   * @param UpdateDataFlowRequest
   * @return UpdateDataFlowResponse
   * @throws OciError when an error occurs
   */
  public async updateDataFlow(
    updateDataFlowRequest: requests.UpdateDataFlowRequest
  ): Promise<responses.UpdateDataFlowResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#updateDataFlow.");
    const pathParams = {
      "{workspaceId}": updateDataFlowRequest.workspaceId,
      "{dataFlowKey}": updateDataFlowRequest.dataFlowKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": updateDataFlowRequest.opcRequestId,
      "if-match": updateDataFlowRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/dataFlows/{dataFlowKey}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateDataFlowRequest.updateDataFlowDetails,
        "UpdateDataFlowDetails",
        models.UpdateDataFlowDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateDataFlowResponse>{},
        body: await response.json(),
        bodyKey: "dataFlow",
        bodyModel: "model.DataFlow",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates a specific folder.
   * @param UpdateFolderRequest
   * @return UpdateFolderResponse
   * @throws OciError when an error occurs
   */
  public async updateFolder(
    updateFolderRequest: requests.UpdateFolderRequest
  ): Promise<responses.UpdateFolderResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#updateFolder.");
    const pathParams = {
      "{workspaceId}": updateFolderRequest.workspaceId,
      "{folderKey}": updateFolderRequest.folderKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": updateFolderRequest.opcRequestId,
      "if-match": updateFolderRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/folders/{folderKey}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateFolderRequest.updateFolderDetails,
        "UpdateFolderDetails",
        models.UpdateFolderDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateFolderResponse>{},
        body: await response.json(),
        bodyKey: "folder",
        bodyModel: "model.Folder",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates a specific project.
   * @param UpdateProjectRequest
   * @return UpdateProjectResponse
   * @throws OciError when an error occurs
   */
  public async updateProject(
    updateProjectRequest: requests.UpdateProjectRequest
  ): Promise<responses.UpdateProjectResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#updateProject.");
    const pathParams = {
      "{workspaceId}": updateProjectRequest.workspaceId,
      "{projectKey}": updateProjectRequest.projectKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": updateProjectRequest.opcRequestId,
      "if-match": updateProjectRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/projects/{projectKey}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateProjectRequest.updateProjectDetails,
        "UpdateProjectDetails",
        models.UpdateProjectDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateProjectResponse>{},
        body: await response.json(),
        bodyKey: "project",
        bodyModel: "model.Project",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates a specific task. For example, you can update the task description or move the task to a different folder by changing the `aggregatorKey` to a different folder in the registry.
   * @param UpdateTaskRequest
   * @return UpdateTaskResponse
   * @throws OciError when an error occurs
   */
  public async updateTask(
    updateTaskRequest: requests.UpdateTaskRequest
  ): Promise<responses.UpdateTaskResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#updateTask.");
    const pathParams = {
      "{workspaceId}": updateTaskRequest.workspaceId,
      "{taskKey}": updateTaskRequest.taskKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": updateTaskRequest.opcRequestId,
      "if-match": updateTaskRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/tasks/{taskKey}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateTaskRequest.updateTaskDetails,
        "UpdateTaskDetails",
        models.UpdateTaskDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateTaskResponse>{},
        body: await response.json(),
        bodyKey: "task",
        bodyModel: "model.Task",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the status of the task run. For example, aborts a task run.
   * @param UpdateTaskRunRequest
   * @return UpdateTaskRunResponse
   * @throws OciError when an error occurs
   */
  public async updateTaskRun(
    updateTaskRunRequest: requests.UpdateTaskRunRequest
  ): Promise<responses.UpdateTaskRunResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#updateTaskRun.");
    const pathParams = {
      "{workspaceId}": updateTaskRunRequest.workspaceId,
      "{applicationKey}": updateTaskRunRequest.applicationKey,
      "{taskRunKey}": updateTaskRunRequest.taskRunKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": updateTaskRunRequest.opcRequestId,
      "if-match": updateTaskRunRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}/applications/{applicationKey}/taskRuns/{taskRunKey}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateTaskRunRequest.updateTaskRunDetails,
        "UpdateTaskRunDetails",
        models.UpdateTaskRunDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateTaskRunResponse>{},
        body: await response.json(),
        bodyKey: "taskRunDetails",
        bodyModel: "model.TaskRunDetails",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the Data Integration Workspace
   * @param UpdateWorkspaceRequest
   * @return UpdateWorkspaceResponse
   * @throws OciError when an error occurs
   */
  public async updateWorkspace(
    updateWorkspaceRequest: requests.UpdateWorkspaceRequest
  ): Promise<responses.UpdateWorkspaceResponse> {
    if (this.logger) this.logger.debug("Calling operation DataIntegrationClient#updateWorkspace.");
    const pathParams = {
      "{workspaceId}": updateWorkspaceRequest.workspaceId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateWorkspaceRequest.ifMatch,
      "opc-request-id": updateWorkspaceRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workspaces/{workspaceId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateWorkspaceRequest.updateWorkspaceDetails,
        "UpdateWorkspaceDetails",
        models.UpdateWorkspaceDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateWorkspaceResponse>{},
        body: await response.json(),
        bodyKey: "workspace",
        bodyModel: "model.Workspace",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }
}
