/**
 * LogAnalytics API
 * The LogAnalytics API for the LogAnalytics service.

 * OpenAPI spec version: 20200601
 * 
 *
 * NOTE: This class is auto generated by OracleSDKGenerator.
 * Do not edit the class manually.
 *
 * Copyright (c) 2020, Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */

import common = require("oci-common");
import * as requests from "./request";
import * as models from "./model";
import * as responses from "./response";
import { LogAnalyticsWaiter } from "./loganalytics-waiter";
import { composeResponse, composeRequest, GenericRetrier } from "oci-common";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum LogAnalyticsApiKeys {}

export class LogAnalyticsClient {
  protected static serviceEndpointTemplate =
    "https://loganalytics.{region}.oci.{secondLevelDomain}";
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": LogAnalyticsWaiter;
  protected "_clientConfiguration": common.ClientConfiguration;

  protected _httpClient: common.HttpClient;

  constructor(params: common.AuthParams) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._httpClient = params.httpClient || new common.FetchHttpClient(requestSigner);

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Get the endpoint that is being used to call (ex, https://www.example.com).
   */
  public get endpoint() {
    return this._endpoint;
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20200601";
    if (this.logger) this.logger.info(`LogAnalyticsClient endpoint set to ${this._endpoint}`);
  }

  public get logger() {
    return common.LOG.logger;
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      LogAnalyticsClient.serviceEndpointTemplate,
      region
    );
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      LogAnalyticsClient.serviceEndpointTemplate,
      regionId
    );
  }

  /**
   * Creates a new LogAnalyticsWaiter for resources for this service.
   *
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(config?: common.WaiterConfiguration): LogAnalyticsWaiter {
    this._waiters = new LogAnalyticsWaiter(this, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): LogAnalyticsWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Sets the client configuration for the client
   */
  public set clientConfiguration(clientConfiguration: common.ClientConfiguration) {
    this._clientConfiguration = clientConfiguration;
  }

  /**
   * Adds association between input source log analytics entity and destination entities.
   * @param AddEntityAssociationRequest
   * @return AddEntityAssociationResponse
   * @throws OciError when an error occurs
   */
  public async addEntityAssociation(
    addEntityAssociationRequest: requests.AddEntityAssociationRequest
  ): Promise<responses.AddEntityAssociationResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#addEntityAssociation.");
    const pathParams = {
      "{namespaceName}": addEntityAssociationRequest.namespaceName,
      "{logAnalyticsEntityId}": addEntityAssociationRequest.logAnalyticsEntityId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": addEntityAssociationRequest.opcRequestId,
      "opc-retry-token": addEntityAssociationRequest.opcRetryToken,
      "if-match": addEntityAssociationRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/namespaces/{namespaceName}/logAnalyticsEntities/{logAnalyticsEntityId}/actions/addEntityAssociations",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        addEntityAssociationRequest.addEntityAssociationDetails,
        "AddEntityAssociationDetails",
        models.AddEntityAssociationDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      addEntityAssociationRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.AddEntityAssociationResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * get basic information about a specified set of labels
   * @param BatchGetBasicInfoRequest
   * @return BatchGetBasicInfoResponse
   * @throws OciError when an error occurs
   */
  public async batchGetBasicInfo(
    batchGetBasicInfoRequest: requests.BatchGetBasicInfoRequest
  ): Promise<responses.BatchGetBasicInfoResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#batchGetBasicInfo.");
    const pathParams = {
      "{namespaceName}": batchGetBasicInfoRequest.namespaceName
    };

    const queryParams = {
      "isIncludeDeleted": batchGetBasicInfoRequest.isIncludeDeleted,
      "limit": batchGetBasicInfoRequest.limit,
      "page": batchGetBasicInfoRequest.page,
      "sortOrder": batchGetBasicInfoRequest.sortOrder,
      "basicLabelSortBy": batchGetBasicInfoRequest.basicLabelSortBy
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": batchGetBasicInfoRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/labels/actions/basicInfo",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        batchGetBasicInfoRequest.basicDetails,
        "LabelNames",
        models.LabelNames.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      batchGetBasicInfoRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.BatchGetBasicInfoResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsLabelCollection",
        bodyModel: "model.LogAnalyticsLabelCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Cancel/Remove query job work request.
   * @param CancelQueryWorkRequestRequest
   * @return CancelQueryWorkRequestResponse
   * @throws OciError when an error occurs
   */
  public async cancelQueryWorkRequest(
    cancelQueryWorkRequestRequest: requests.CancelQueryWorkRequestRequest
  ): Promise<responses.CancelQueryWorkRequestResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#cancelQueryWorkRequest.");
    const pathParams = {
      "{namespaceName}": cancelQueryWorkRequestRequest.namespaceName,
      "{workRequestId}": cancelQueryWorkRequestRequest.workRequestId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": cancelQueryWorkRequestRequest.opcRequestId,
      "if-match": cancelQueryWorkRequestRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/queryWorkRequests/{workRequestId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      cancelQueryWorkRequestRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CancelQueryWorkRequestResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Update the compartment of the log analytics entity with the given id.
   * @param ChangeLogAnalyticsEntityCompartmentRequest
   * @return ChangeLogAnalyticsEntityCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeLogAnalyticsEntityCompartment(
    changeLogAnalyticsEntityCompartmentRequest: requests.ChangeLogAnalyticsEntityCompartmentRequest
  ): Promise<responses.ChangeLogAnalyticsEntityCompartmentResponse> {
    if (this.logger)
      this.logger.debug(
        "Calling operation LogAnalyticsClient#changeLogAnalyticsEntityCompartment."
      );
    const pathParams = {
      "{namespaceName}": changeLogAnalyticsEntityCompartmentRequest.namespaceName,
      "{logAnalyticsEntityId}": changeLogAnalyticsEntityCompartmentRequest.logAnalyticsEntityId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": changeLogAnalyticsEntityCompartmentRequest.ifMatch,
      "opc-request-id": changeLogAnalyticsEntityCompartmentRequest.opcRequestId,
      "opc-retry-token": changeLogAnalyticsEntityCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/namespaces/{namespaceName}/logAnalyticsEntities/{logAnalyticsEntityId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeLogAnalyticsEntityCompartmentRequest.changeLogAnalyticsEntityCompartmentDetails,
        "ChangeLogAnalyticsEntityCompartmentDetails",
        models.ChangeLogAnalyticsEntityCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      changeLogAnalyticsEntityCompartmentRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeLogAnalyticsEntityCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Updates the compartment of the Log-Analytics group with the given id.
   * @param ChangeLogAnalyticsLogGroupCompartmentRequest
   * @return ChangeLogAnalyticsLogGroupCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeLogAnalyticsLogGroupCompartment(
    changeLogAnalyticsLogGroupCompartmentRequest: requests.ChangeLogAnalyticsLogGroupCompartmentRequest
  ): Promise<responses.ChangeLogAnalyticsLogGroupCompartmentResponse> {
    if (this.logger)
      this.logger.debug(
        "Calling operation LogAnalyticsClient#changeLogAnalyticsLogGroupCompartment."
      );
    const pathParams = {
      "{namespaceName}": changeLogAnalyticsLogGroupCompartmentRequest.namespaceName,
      "{logAnalyticsLogGroupId}":
        changeLogAnalyticsLogGroupCompartmentRequest.logAnalyticsLogGroupId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": changeLogAnalyticsLogGroupCompartmentRequest.ifMatch,
      "opc-request-id": changeLogAnalyticsLogGroupCompartmentRequest.opcRequestId,
      "opc-retry-token": changeLogAnalyticsLogGroupCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/namespaces/{namespaceName}/logAnalyticsLogGroups/{logAnalyticsLogGroupId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeLogAnalyticsLogGroupCompartmentRequest.changeLogAnalyticsLogGroupCompartmentDetails,
        "ChangeLogAnalyticsLogGroupCompartmentDetails",
        models.ChangeLogAnalyticsLogGroupCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      changeLogAnalyticsLogGroupCompartmentRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeLogAnalyticsLogGroupCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Move the rule from it's current compartment to given compartment.
   * @param ChangeLogAnalyticsObjectCollectionRuleCompartmentRequest
   * @return ChangeLogAnalyticsObjectCollectionRuleCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeLogAnalyticsObjectCollectionRuleCompartment(
    changeLogAnalyticsObjectCollectionRuleCompartmentRequest: requests.ChangeLogAnalyticsObjectCollectionRuleCompartmentRequest
  ): Promise<responses.ChangeLogAnalyticsObjectCollectionRuleCompartmentResponse> {
    if (this.logger)
      this.logger.debug(
        "Calling operation LogAnalyticsClient#changeLogAnalyticsObjectCollectionRuleCompartment."
      );
    const pathParams = {
      "{namespaceName}": changeLogAnalyticsObjectCollectionRuleCompartmentRequest.namespaceName,
      "{logAnalyticsObjectCollectionRuleId}":
        changeLogAnalyticsObjectCollectionRuleCompartmentRequest.logAnalyticsObjectCollectionRuleId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": changeLogAnalyticsObjectCollectionRuleCompartmentRequest.ifMatch,
      "opc-request-id": changeLogAnalyticsObjectCollectionRuleCompartmentRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/namespaces/{namespaceName}/logAnalyticsObjectCollectionRules/{logAnalyticsObjectCollectionRuleId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeLogAnalyticsObjectCollectionRuleCompartmentRequest.changeLogAnalyticsObjectCollectionRuleCompartmentDetails,
        "ChangeLogAnalyticsObjectCollectionRuleCompartmentDetails",
        models.ChangeLogAnalyticsObjectCollectionRuleCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      changeLogAnalyticsObjectCollectionRuleCompartmentRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeLogAnalyticsObjectCollectionRuleCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Move the scheduled task into a different compartment within the same tenancy.
   *
   * @param ChangeScheduledTaskCompartmentRequest
   * @return ChangeScheduledTaskCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeScheduledTaskCompartment(
    changeScheduledTaskCompartmentRequest: requests.ChangeScheduledTaskCompartmentRequest
  ): Promise<responses.ChangeScheduledTaskCompartmentResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#changeScheduledTaskCompartment.");
    const pathParams = {
      "{namespaceName}": changeScheduledTaskCompartmentRequest.namespaceName,
      "{scheduledTaskId}": changeScheduledTaskCompartmentRequest.scheduledTaskId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": changeScheduledTaskCompartmentRequest.ifMatch,
      "opc-request-id": changeScheduledTaskCompartmentRequest.opcRequestId,
      "opc-retry-token": changeScheduledTaskCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/namespaces/{namespaceName}/scheduledTasks/{scheduledTaskId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeScheduledTaskCompartmentRequest.changeScheduledTaskCompartmentDetails,
        "ChangeScheduledTaskCompartmentDetails",
        models.ChangeScheduledTaskCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      changeScheduledTaskCompartmentRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeScheduledTaskCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Clean accumulated acceleration data stored for the accelerated saved search.
   * The ScheduledTask taskType must be ACCELERATION.
   *
   * @param CleanRequest
   * @return CleanResponse
   * @throws OciError when an error occurs
   */
  public async clean(cleanRequest: requests.CleanRequest): Promise<responses.CleanResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#clean.");
    const pathParams = {
      "{namespaceName}": cleanRequest.namespaceName,
      "{scheduledTaskId}": cleanRequest.scheduledTaskId
    };

    const queryParams = {
      "timeStart": cleanRequest.timeStart,
      "timeEnd": cleanRequest.timeEnd
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": cleanRequest.opcRequestId,
      "opc-retry-token": cleanRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/scheduledTasks/{scheduledTaskId}/actions/clean",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      cleanRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CleanResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Create a new log analytics entity.
   * @param CreateLogAnalyticsEntityRequest
   * @return CreateLogAnalyticsEntityResponse
   * @throws OciError when an error occurs
   */
  public async createLogAnalyticsEntity(
    createLogAnalyticsEntityRequest: requests.CreateLogAnalyticsEntityRequest
  ): Promise<responses.CreateLogAnalyticsEntityResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#createLogAnalyticsEntity.");
    const pathParams = {
      "{namespaceName}": createLogAnalyticsEntityRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-retry-token": createLogAnalyticsEntityRequest.opcRetryToken,
      "opc-request-id": createLogAnalyticsEntityRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/logAnalyticsEntities",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createLogAnalyticsEntityRequest.createLogAnalyticsEntityDetails,
        "CreateLogAnalyticsEntityDetails",
        models.CreateLogAnalyticsEntityDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createLogAnalyticsEntityRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateLogAnalyticsEntityResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsEntity",
        bodyModel: "model.LogAnalyticsEntity",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Add custom log analytics entity type.
   * @param CreateLogAnalyticsEntityTypeRequest
   * @return CreateLogAnalyticsEntityTypeResponse
   * @throws OciError when an error occurs
   */
  public async createLogAnalyticsEntityType(
    createLogAnalyticsEntityTypeRequest: requests.CreateLogAnalyticsEntityTypeRequest
  ): Promise<responses.CreateLogAnalyticsEntityTypeResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#createLogAnalyticsEntityType.");
    const pathParams = {
      "{namespaceName}": createLogAnalyticsEntityTypeRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": createLogAnalyticsEntityTypeRequest.opcRequestId,
      "opc-retry-token": createLogAnalyticsEntityTypeRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/logAnalyticsEntityTypes",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createLogAnalyticsEntityTypeRequest.createLogAnalyticsEntityTypeDetails,
        "CreateLogAnalyticsEntityTypeDetails",
        models.CreateLogAnalyticsEntityTypeDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createLogAnalyticsEntityTypeRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateLogAnalyticsEntityTypeResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new Log-Analytics group.
   * @param CreateLogAnalyticsLogGroupRequest
   * @return CreateLogAnalyticsLogGroupResponse
   * @throws OciError when an error occurs
   */
  public async createLogAnalyticsLogGroup(
    createLogAnalyticsLogGroupRequest: requests.CreateLogAnalyticsLogGroupRequest
  ): Promise<responses.CreateLogAnalyticsLogGroupResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#createLogAnalyticsLogGroup.");
    const pathParams = {
      "{namespaceName}": createLogAnalyticsLogGroupRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-retry-token": createLogAnalyticsLogGroupRequest.opcRetryToken,
      "opc-request-id": createLogAnalyticsLogGroupRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/logAnalyticsLogGroups",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createLogAnalyticsLogGroupRequest.createLogAnalyticsLogGroupDetails,
        "CreateLogAnalyticsLogGroupDetails",
        models.CreateLogAnalyticsLogGroupDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createLogAnalyticsLogGroupRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateLogAnalyticsLogGroupResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsLogGroup",
        bodyModel: "model.LogAnalyticsLogGroup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Create a configuration to collect logs from object storage bucket.
   * @param CreateLogAnalyticsObjectCollectionRuleRequest
   * @return CreateLogAnalyticsObjectCollectionRuleResponse
   * @throws OciError when an error occurs
   */
  public async createLogAnalyticsObjectCollectionRule(
    createLogAnalyticsObjectCollectionRuleRequest: requests.CreateLogAnalyticsObjectCollectionRuleRequest
  ): Promise<responses.CreateLogAnalyticsObjectCollectionRuleResponse> {
    if (this.logger)
      this.logger.debug(
        "Calling operation LogAnalyticsClient#createLogAnalyticsObjectCollectionRule."
      );
    const pathParams = {
      "{namespaceName}": createLogAnalyticsObjectCollectionRuleRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": createLogAnalyticsObjectCollectionRuleRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/logAnalyticsObjectCollectionRules",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createLogAnalyticsObjectCollectionRuleRequest.createLogAnalyticsObjectCollectionRuleDetails,
        "CreateLogAnalyticsObjectCollectionRuleDetails",
        models.CreateLogAnalyticsObjectCollectionRuleDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createLogAnalyticsObjectCollectionRuleRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateLogAnalyticsObjectCollectionRuleResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsObjectCollectionRule",
        bodyModel: "model.LogAnalyticsObjectCollectionRule",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Schedule a task as specified and return task info.
   * @param CreateScheduledTaskRequest
   * @return CreateScheduledTaskResponse
   * @throws OciError when an error occurs
   */
  public async createScheduledTask(
    createScheduledTaskRequest: requests.CreateScheduledTaskRequest
  ): Promise<responses.CreateScheduledTaskResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#createScheduledTask.");
    const pathParams = {
      "{namespaceName}": createScheduledTaskRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": createScheduledTaskRequest.opcRequestId,
      "opc-retry-token": createScheduledTaskRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/scheduledTasks",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createScheduledTaskRequest.createScheduledTaskDetails,
        "CreateScheduledTaskDetails",
        models.CreateScheduledTaskDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createScheduledTaskRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateScheduledTaskResponse>{},
        body: await response.json(),
        bodyKey: "scheduledTask",
        bodyModel: "model.ScheduledTask",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * delete associations
   * @param DeleteAssociationsRequest
   * @return DeleteAssociationsResponse
   * @throws OciError when an error occurs
   */
  public async deleteAssociations(
    deleteAssociationsRequest: requests.DeleteAssociationsRequest
  ): Promise<responses.DeleteAssociationsResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#deleteAssociations.");
    const pathParams = {
      "{namespaceName}": deleteAssociationsRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-retry-token": deleteAssociationsRequest.opcRetryToken,
      "opc-request-id": deleteAssociationsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/associations/actions/delete",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        deleteAssociationsRequest.deleteLogAnalyticsAssociationDetails,
        "DeleteLogAnalyticsAssociationDetails",
        models.DeleteLogAnalyticsAssociationDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteAssociationsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteAssociationsResponse>{},
        body: await response.json(),
        bodyKey: "errorDetails",
        bodyModel: "model.ErrorDetails",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * delete field with specified name
   * @param DeleteFieldRequest
   * @return DeleteFieldResponse
   * @throws OciError when an error occurs
   */
  public async deleteField(
    deleteFieldRequest: requests.DeleteFieldRequest
  ): Promise<responses.DeleteFieldResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#deleteField.");
    const pathParams = {
      "{namespaceName}": deleteFieldRequest.namespaceName,
      "{fieldName}": deleteFieldRequest.fieldName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-retry-token": deleteFieldRequest.opcRetryToken,
      "opc-request-id": deleteFieldRequest.opcRequestId,
      "if-match": deleteFieldRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/fields/{fieldName}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteFieldRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteFieldResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * delete a label
   * @param DeleteLabelRequest
   * @return DeleteLabelResponse
   * @throws OciError when an error occurs
   */
  public async deleteLabel(
    deleteLabelRequest: requests.DeleteLabelRequest
  ): Promise<responses.DeleteLabelResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#deleteLabel.");
    const pathParams = {
      "{namespaceName}": deleteLabelRequest.namespaceName,
      "{labelName}": deleteLabelRequest.labelName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-retry-token": deleteLabelRequest.opcRetryToken,
      "opc-request-id": deleteLabelRequest.opcRequestId,
      "if-match": deleteLabelRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/labels/{labelName}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteLabelRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteLabelResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Delete log analytics entity with the given id.
   * @param DeleteLogAnalyticsEntityRequest
   * @return DeleteLogAnalyticsEntityResponse
   * @throws OciError when an error occurs
   */
  public async deleteLogAnalyticsEntity(
    deleteLogAnalyticsEntityRequest: requests.DeleteLogAnalyticsEntityRequest
  ): Promise<responses.DeleteLogAnalyticsEntityResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#deleteLogAnalyticsEntity.");
    const pathParams = {
      "{namespaceName}": deleteLogAnalyticsEntityRequest.namespaceName,
      "{logAnalyticsEntityId}": deleteLogAnalyticsEntityRequest.logAnalyticsEntityId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": deleteLogAnalyticsEntityRequest.ifMatch,
      "opc-request-id": deleteLogAnalyticsEntityRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/logAnalyticsEntities/{logAnalyticsEntityId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteLogAnalyticsEntityRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteLogAnalyticsEntityResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Delete the log analytics entity type with the given name.
   * @param DeleteLogAnalyticsEntityTypeRequest
   * @return DeleteLogAnalyticsEntityTypeResponse
   * @throws OciError when an error occurs
   */
  public async deleteLogAnalyticsEntityType(
    deleteLogAnalyticsEntityTypeRequest: requests.DeleteLogAnalyticsEntityTypeRequest
  ): Promise<responses.DeleteLogAnalyticsEntityTypeResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#deleteLogAnalyticsEntityType.");
    const pathParams = {
      "{namespaceName}": deleteLogAnalyticsEntityTypeRequest.namespaceName,
      "{entityTypeName}": deleteLogAnalyticsEntityTypeRequest.entityTypeName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": deleteLogAnalyticsEntityTypeRequest.ifMatch,
      "opc-request-id": deleteLogAnalyticsEntityTypeRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/logAnalyticsEntityTypes/{entityTypeName}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteLogAnalyticsEntityTypeRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteLogAnalyticsEntityTypeResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes the Log-Analytics group with the given id.
   * @param DeleteLogAnalyticsLogGroupRequest
   * @return DeleteLogAnalyticsLogGroupResponse
   * @throws OciError when an error occurs
   */
  public async deleteLogAnalyticsLogGroup(
    deleteLogAnalyticsLogGroupRequest: requests.DeleteLogAnalyticsLogGroupRequest
  ): Promise<responses.DeleteLogAnalyticsLogGroupResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#deleteLogAnalyticsLogGroup.");
    const pathParams = {
      "{namespaceName}": deleteLogAnalyticsLogGroupRequest.namespaceName,
      "{logAnalyticsLogGroupId}": deleteLogAnalyticsLogGroupRequest.logAnalyticsLogGroupId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": deleteLogAnalyticsLogGroupRequest.ifMatch,
      "opc-request-id": deleteLogAnalyticsLogGroupRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/logAnalyticsLogGroups/{logAnalyticsLogGroupId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteLogAnalyticsLogGroupRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteLogAnalyticsLogGroupResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes a configured object storage bucket based collection rule to stop the log collection of the configured bucket .
   * It will not delete the already collected log data from the configured bucket.
   *
   * @param DeleteLogAnalyticsObjectCollectionRuleRequest
   * @return DeleteLogAnalyticsObjectCollectionRuleResponse
   * @throws OciError when an error occurs
   */
  public async deleteLogAnalyticsObjectCollectionRule(
    deleteLogAnalyticsObjectCollectionRuleRequest: requests.DeleteLogAnalyticsObjectCollectionRuleRequest
  ): Promise<responses.DeleteLogAnalyticsObjectCollectionRuleResponse> {
    if (this.logger)
      this.logger.debug(
        "Calling operation LogAnalyticsClient#deleteLogAnalyticsObjectCollectionRule."
      );
    const pathParams = {
      "{namespaceName}": deleteLogAnalyticsObjectCollectionRuleRequest.namespaceName,
      "{logAnalyticsObjectCollectionRuleId}":
        deleteLogAnalyticsObjectCollectionRuleRequest.logAnalyticsObjectCollectionRuleId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": deleteLogAnalyticsObjectCollectionRuleRequest.opcRequestId,
      "if-match": deleteLogAnalyticsObjectCollectionRuleRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/namespaces/{namespaceName}/logAnalyticsObjectCollectionRules/{logAnalyticsObjectCollectionRuleId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteLogAnalyticsObjectCollectionRuleRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteLogAnalyticsObjectCollectionRuleResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * delete parser with specified name
   * @param DeleteParserRequest
   * @return DeleteParserResponse
   * @throws OciError when an error occurs
   */
  public async deleteParser(
    deleteParserRequest: requests.DeleteParserRequest
  ): Promise<responses.DeleteParserResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#deleteParser.");
    const pathParams = {
      "{namespaceName}": deleteParserRequest.namespaceName,
      "{parserName}": deleteParserRequest.parserName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-retry-token": deleteParserRequest.opcRetryToken,
      "opc-request-id": deleteParserRequest.opcRequestId,
      "if-match": deleteParserRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/parsers/{parserName}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteParserRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteParserResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Delete the scheduled task.
   * @param DeleteScheduledTaskRequest
   * @return DeleteScheduledTaskResponse
   * @throws OciError when an error occurs
   */
  public async deleteScheduledTask(
    deleteScheduledTaskRequest: requests.DeleteScheduledTaskRequest
  ): Promise<responses.DeleteScheduledTaskResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#deleteScheduledTask.");
    const pathParams = {
      "{namespaceName}": deleteScheduledTaskRequest.namespaceName,
      "{scheduledTaskId}": deleteScheduledTaskRequest.scheduledTaskId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": deleteScheduledTaskRequest.opcRequestId,
      "if-match": deleteScheduledTaskRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/scheduledTasks/{scheduledTaskId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteScheduledTaskRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteScheduledTaskResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * delete source with specified ID
   * @param DeleteSourceRequest
   * @return DeleteSourceResponse
   * @throws OciError when an error occurs
   */
  public async deleteSource(
    deleteSourceRequest: requests.DeleteSourceRequest
  ): Promise<responses.DeleteSourceResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#deleteSource.");
    const pathParams = {
      "{namespaceName}": deleteSourceRequest.namespaceName,
      "{sourceName}": deleteSourceRequest.sourceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-retry-token": deleteSourceRequest.opcRetryToken,
      "opc-request-id": deleteSourceRequest.opcRequestId,
      "if-match": deleteSourceRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/sources/{sourceName}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteSourceRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteSourceResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes an Upload by its reference.
   * It deletes all the logs in storage asscoiated with the upload and the corresponding upload metadata.
   *
   * @param DeleteUploadRequest
   * @return DeleteUploadResponse
   * @throws OciError when an error occurs
   */
  public async deleteUpload(
    deleteUploadRequest: requests.DeleteUploadRequest
  ): Promise<responses.DeleteUploadResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#deleteUpload.");
    const pathParams = {
      "{namespaceName}": deleteUploadRequest.namespaceName,
      "{uploadReference}": deleteUploadRequest.uploadReference
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": deleteUploadRequest.ifMatch,
      "opc-request-id": deleteUploadRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/uploads/{uploadReference}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteUploadRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteUploadResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-deleted-log-count"),
            key: "opcDeletedLogCount",
            dataType: "number"
          },
          {
            value: response.headers.get("opc-deleted-logfile-count"),
            key: "opcDeletedLogfileCount",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes a specific log file inside an upload by providing upload file reference.
   * It deletes all the logs in storage asscoiated with the upload file and the corresponding upload metadata.
   *
   * @param DeleteUploadFileRequest
   * @return DeleteUploadFileResponse
   * @throws OciError when an error occurs
   */
  public async deleteUploadFile(
    deleteUploadFileRequest: requests.DeleteUploadFileRequest
  ): Promise<responses.DeleteUploadFileResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#deleteUploadFile.");
    const pathParams = {
      "{namespaceName}": deleteUploadFileRequest.namespaceName,
      "{uploadReference}": deleteUploadFileRequest.uploadReference,
      "{fileReference}": deleteUploadFileRequest.fileReference
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": deleteUploadFileRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/uploads/{uploadReference}/files/{fileReference}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteUploadFileRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteUploadFileResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-deleted-log-count"),
            key: "opcDeletedLogCount",
            dataType: "number"
          },
          {
            value: response.headers.get("opc-deleted-logfile-count"),
            key: "opcDeletedLogfileCount",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Suppresses a specific warning inside an upload.
   *
   * @param DeleteUploadWarningRequest
   * @return DeleteUploadWarningResponse
   * @throws OciError when an error occurs
   */
  public async deleteUploadWarning(
    deleteUploadWarningRequest: requests.DeleteUploadWarningRequest
  ): Promise<responses.DeleteUploadWarningResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#deleteUploadWarning.");
    const pathParams = {
      "{namespaceName}": deleteUploadWarningRequest.namespaceName,
      "{uploadReference}": deleteUploadWarningRequest.uploadReference,
      "{warningReference}": deleteUploadWarningRequest.warningReference
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": deleteUploadWarningRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/uploads/{uploadReference}/warnings/{warningReference}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteUploadWarningRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteUploadWarningResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * disable archiving
   *
   * @param DisableArchivingRequest
   * @return DisableArchivingResponse
   * @throws OciError when an error occurs
   */
  public async disableArchiving(
    disableArchivingRequest: requests.DisableArchivingRequest
  ): Promise<responses.DisableArchivingResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#disableArchiving.");
    const pathParams = {
      "{namespaceName}": disableArchivingRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": disableArchivingRequest.opcRequestId,
      "if-match": disableArchivingRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/storage/actions/disableArchiving",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      disableArchivingRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DisableArchivingResponse>{},
        body: await response.json(),
        bodyKey: "success",
        bodyModel: "model.Success",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * enable archiving.
   *
   * @param EnableArchivingRequest
   * @return EnableArchivingResponse
   * @throws OciError when an error occurs
   */
  public async enableArchiving(
    enableArchivingRequest: requests.EnableArchivingRequest
  ): Promise<responses.EnableArchivingResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#enableArchiving.");
    const pathParams = {
      "{namespaceName}": enableArchivingRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": enableArchivingRequest.opcRequestId,
      "if-match": enableArchivingRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/storage/actions/enableArchiving",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      enableArchivingRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.EnableArchivingResponse>{},
        body: await response.json(),
        bodyKey: "success",
        bodyModel: "model.Success",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * estimate the size of data to be purged based on query parameters.
   *
   * @param EstimatePurgeDataSizeRequest
   * @return EstimatePurgeDataSizeResponse
   * @throws OciError when an error occurs
   */
  public async estimatePurgeDataSize(
    estimatePurgeDataSizeRequest: requests.EstimatePurgeDataSizeRequest
  ): Promise<responses.EstimatePurgeDataSizeResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#estimatePurgeDataSize.");
    const pathParams = {
      "{namespaceName}": estimatePurgeDataSizeRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": estimatePurgeDataSizeRequest.opcRequestId,
      "opc-retry-token": estimatePurgeDataSizeRequest.opcRetryToken,
      "if-match": estimatePurgeDataSizeRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/storage/actions/estimatePurgeDataSize",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        estimatePurgeDataSizeRequest.estimatePurgeDataSizeDetails,
        "EstimatePurgeDataSizeDetails",
        models.EstimatePurgeDataSizeDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      estimatePurgeDataSizeRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.EstimatePurgeDataSizeResponse>{},
        body: await response.json(),
        bodyKey: "estimatePurgeDataSizeResult",
        bodyModel: "model.EstimatePurgeDataSizeResult",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * export
   * @param ExportCustomContentRequest
   * @return ExportCustomContentResponse
   * @throws OciError when an error occurs
   */
  public async exportCustomContent(
    exportCustomContentRequest: requests.ExportCustomContentRequest
  ): Promise<responses.ExportCustomContentResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#exportCustomContent.");
    const pathParams = {
      "{namespaceName}": exportCustomContentRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-retry-token": exportCustomContentRequest.opcRetryToken,
      "opc-request-id": exportCustomContentRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/contents/actions/exportCustomContent",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        exportCustomContentRequest.exportCustomContentDetails,
        "ExportContent",
        models.ExportContent.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      exportCustomContentRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ExportCustomContentResponse>{},

        body: response.body!,
        bodyKey: "value",
        bodyModel: "string",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Export data based on query. Endpoint returns a stream of data. Endpoint is synchronous. Queries must deliver first result within 60 seconds or calls are subject to timeout.
   * @param ExportQueryResultRequest
   * @return ExportQueryResultResponse
   * @throws OciError when an error occurs
   */
  public async exportQueryResult(
    exportQueryResultRequest: requests.ExportQueryResultRequest
  ): Promise<responses.ExportQueryResultResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#exportQueryResult.");
    const pathParams = {
      "{namespaceName}": exportQueryResultRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": exportQueryResultRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/search/actions/export",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        exportQueryResultRequest.exportDetails,
        "ExportDetails",
        models.ExportDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      exportQueryResultRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ExportQueryResultResponse>{},

        body: response.body!,
        bodyKey: "value",
        bodyModel: "string",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * structured log fieldpaths
   * @param ExtractStructuredLogFieldPathsRequest
   * @return ExtractStructuredLogFieldPathsResponse
   * @throws OciError when an error occurs
   */
  public async extractStructuredLogFieldPaths(
    extractStructuredLogFieldPathsRequest: requests.ExtractStructuredLogFieldPathsRequest
  ): Promise<responses.ExtractStructuredLogFieldPathsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#extractStructuredLogFieldPaths.");
    const pathParams = {
      "{namespaceName}": extractStructuredLogFieldPathsRequest.namespaceName
    };

    const queryParams = {
      "parserType": extractStructuredLogFieldPathsRequest.parserType
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-retry-token": extractStructuredLogFieldPathsRequest.opcRetryToken,
      "opc-request-id": extractStructuredLogFieldPathsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/parsers/actions/extractLogFieldPaths",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        extractStructuredLogFieldPathsRequest.loganParserDetails,
        "LogAnalyticsParser",
        models.LogAnalyticsParser.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      extractStructuredLogFieldPathsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ExtractStructuredLogFieldPathsResponse>{},
        body: await response.json(),
        bodyKey: "extractLogFieldResults",
        bodyModel: "model.ExtractLogFieldResults",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * structured log header paths
   * @param ExtractStructuredLogHeaderPathsRequest
   * @return ExtractStructuredLogHeaderPathsResponse
   * @throws OciError when an error occurs
   */
  public async extractStructuredLogHeaderPaths(
    extractStructuredLogHeaderPathsRequest: requests.ExtractStructuredLogHeaderPathsRequest
  ): Promise<responses.ExtractStructuredLogHeaderPathsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#extractStructuredLogHeaderPaths.");
    const pathParams = {
      "{namespaceName}": extractStructuredLogHeaderPathsRequest.namespaceName
    };

    const queryParams = {
      "parserType": extractStructuredLogHeaderPathsRequest.parserType
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-retry-token": extractStructuredLogHeaderPathsRequest.opcRetryToken,
      "opc-request-id": extractStructuredLogHeaderPathsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/parsers/actions/extractLogHeaderPaths",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        extractStructuredLogHeaderPathsRequest.loganParserDetails,
        "LogAnalyticsParser",
        models.LogAnalyticsParser.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      extractStructuredLogHeaderPathsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ExtractStructuredLogHeaderPathsResponse>{},
        body: await response.json(),
        bodyKey: "extractLogHeaderResults",
        bodyModel: "model.ExtractLogHeaderResults",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Each filter specifies an operator, a field and one or more values.
   * @param FilterRequest
   * @return FilterResponse
   * @throws OciError when an error occurs
   */
  public async filter(filterRequest: requests.FilterRequest): Promise<responses.FilterResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#filter.");
    const pathParams = {
      "{namespaceName}": filterRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": filterRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/search/actions/filter",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        filterRequest.filterDetails,
        "FilterDetails",
        models.FilterDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      filterRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.FilterResponse>{},
        body: await response.json(),
        bodyKey: "filterOutput",
        bodyModel: "model.FilterOutput",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * association summary
   * @param GetAssociationSummaryRequest
   * @return GetAssociationSummaryResponse
   * @throws OciError when an error occurs
   */
  public async getAssociationSummary(
    getAssociationSummaryRequest: requests.GetAssociationSummaryRequest
  ): Promise<responses.GetAssociationSummaryResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#getAssociationSummary.");
    const pathParams = {
      "{namespaceName}": getAssociationSummaryRequest.namespaceName
    };

    const queryParams = {
      "compartmentId": getAssociationSummaryRequest.compartmentId
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getAssociationSummaryRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/associationSummary",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getAssociationSummaryRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetAssociationSummaryResponse>{},
        body: await response.json(),
        bodyKey: "associationSummaryReport",
        bodyModel: "model.AssociationSummaryReport",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * extract column names from SQL query
   * @param GetColumnNamesRequest
   * @return GetColumnNamesResponse
   * @throws OciError when an error occurs
   */
  public async getColumnNames(
    getColumnNamesRequest: requests.GetColumnNamesRequest
  ): Promise<responses.GetColumnNamesResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#getColumnNames.");
    const pathParams = {
      "{namespaceName}": getColumnNamesRequest.namespaceName
    };

    const queryParams = {
      "sqlQuery": getColumnNamesRequest.sqlQuery
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-retry-token": getColumnNamesRequest.opcRetryToken,
      "opc-request-id": getColumnNamesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/sources/sqlColumnNames",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getColumnNamesRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetColumnNamesResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * association summary by source
   * @param GetConfigWorkRequestRequest
   * @return GetConfigWorkRequestResponse
   * @throws OciError when an error occurs
   */
  public async getConfigWorkRequest(
    getConfigWorkRequestRequest: requests.GetConfigWorkRequestRequest
  ): Promise<responses.GetConfigWorkRequestResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#getConfigWorkRequest.");
    const pathParams = {
      "{namespaceName}": getConfigWorkRequestRequest.namespaceName,
      "{workRequestId}": getConfigWorkRequestRequest.workRequestId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getConfigWorkRequestRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/configWorkRequests/{workRequestId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getConfigWorkRequestRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetConfigWorkRequestResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsConfigWorkRequest",
        bodyModel: "model.LogAnalyticsConfigWorkRequest",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * get common field with specified name
   * @param GetFieldRequest
   * @return GetFieldResponse
   * @throws OciError when an error occurs
   */
  public async getField(
    getFieldRequest: requests.GetFieldRequest
  ): Promise<responses.GetFieldResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#getField.");
    const pathParams = {
      "{namespaceName}": getFieldRequest.namespaceName,
      "{fieldName}": getFieldRequest.fieldName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getFieldRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/fields/{fieldName}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getFieldRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetFieldResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsField",
        bodyModel: "model.LogAnalyticsField",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * get field summary
   * @param GetFieldsSummaryRequest
   * @return GetFieldsSummaryResponse
   * @throws OciError when an error occurs
   */
  public async getFieldsSummary(
    getFieldsSummaryRequest: requests.GetFieldsSummaryRequest
  ): Promise<responses.GetFieldsSummaryResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#getFieldsSummary.");
    const pathParams = {
      "{namespaceName}": getFieldsSummaryRequest.namespaceName
    };

    const queryParams = {
      "isShowDetail": getFieldsSummaryRequest.isShowDetail
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getFieldsSummaryRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/fieldSummary",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getFieldsSummaryRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetFieldsSummaryResponse>{},
        body: await response.json(),
        bodyKey: "fieldSummaryReport",
        bodyModel: "model.FieldSummaryReport",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * get label with specified name
   * @param GetLabelRequest
   * @return GetLabelResponse
   * @throws OciError when an error occurs
   */
  public async getLabel(
    getLabelRequest: requests.GetLabelRequest
  ): Promise<responses.GetLabelResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#getLabel.");
    const pathParams = {
      "{namespaceName}": getLabelRequest.namespaceName,
      "{labelName}": getLabelRequest.labelName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getLabelRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/labels/{labelName}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getLabelRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetLabelResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsLabel",
        bodyModel: "model.LogAnalyticsLabel",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * get total count
   * @param GetLabelSummaryRequest
   * @return GetLabelSummaryResponse
   * @throws OciError when an error occurs
   */
  public async getLabelSummary(
    getLabelSummaryRequest: requests.GetLabelSummaryRequest
  ): Promise<responses.GetLabelSummaryResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#getLabelSummary.");
    const pathParams = {
      "{namespaceName}": getLabelSummaryRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getLabelSummaryRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/labelSummary",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getLabelSummaryRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetLabelSummaryResponse>{},
        body: await response.json(),
        bodyKey: "labelSummaryReport",
        bodyModel: "model.LabelSummaryReport",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns log analytics entities count summary.
   * @param GetLogAnalyticsEntitiesSummaryRequest
   * @return GetLogAnalyticsEntitiesSummaryResponse
   * @throws OciError when an error occurs
   */
  public async getLogAnalyticsEntitiesSummary(
    getLogAnalyticsEntitiesSummaryRequest: requests.GetLogAnalyticsEntitiesSummaryRequest
  ): Promise<responses.GetLogAnalyticsEntitiesSummaryResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#getLogAnalyticsEntitiesSummary.");
    const pathParams = {
      "{namespaceName}": getLogAnalyticsEntitiesSummaryRequest.namespaceName
    };

    const queryParams = {
      "compartmentId": getLogAnalyticsEntitiesSummaryRequest.compartmentId
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getLogAnalyticsEntitiesSummaryRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/logAnalyticsEntities/entitySummary",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getLogAnalyticsEntitiesSummaryRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetLogAnalyticsEntitiesSummaryResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsEntitySummaryReport",
        bodyModel: "model.LogAnalyticsEntitySummaryReport",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Retrieve the log analytics entity with the given id.
   * @param GetLogAnalyticsEntityRequest
   * @return GetLogAnalyticsEntityResponse
   * @throws OciError when an error occurs
   */
  public async getLogAnalyticsEntity(
    getLogAnalyticsEntityRequest: requests.GetLogAnalyticsEntityRequest
  ): Promise<responses.GetLogAnalyticsEntityResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#getLogAnalyticsEntity.");
    const pathParams = {
      "{namespaceName}": getLogAnalyticsEntityRequest.namespaceName,
      "{logAnalyticsEntityId}": getLogAnalyticsEntityRequest.logAnalyticsEntityId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getLogAnalyticsEntityRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/logAnalyticsEntities/{logAnalyticsEntityId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getLogAnalyticsEntityRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetLogAnalyticsEntityResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsEntity",
        bodyModel: "model.LogAnalyticsEntity",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Retrieve the log analytics entity type with the given name.
   * @param GetLogAnalyticsEntityTypeRequest
   * @return GetLogAnalyticsEntityTypeResponse
   * @throws OciError when an error occurs
   */
  public async getLogAnalyticsEntityType(
    getLogAnalyticsEntityTypeRequest: requests.GetLogAnalyticsEntityTypeRequest
  ): Promise<responses.GetLogAnalyticsEntityTypeResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#getLogAnalyticsEntityType.");
    const pathParams = {
      "{namespaceName}": getLogAnalyticsEntityTypeRequest.namespaceName,
      "{entityTypeName}": getLogAnalyticsEntityTypeRequest.entityTypeName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getLogAnalyticsEntityTypeRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/logAnalyticsEntityTypes/{entityTypeName}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getLogAnalyticsEntityTypeRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetLogAnalyticsEntityTypeResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsEntityType",
        bodyModel: "model.LogAnalyticsEntityType",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Retrieves the Log-Analytics group with the given id.
   * @param GetLogAnalyticsLogGroupRequest
   * @return GetLogAnalyticsLogGroupResponse
   * @throws OciError when an error occurs
   */
  public async getLogAnalyticsLogGroup(
    getLogAnalyticsLogGroupRequest: requests.GetLogAnalyticsLogGroupRequest
  ): Promise<responses.GetLogAnalyticsLogGroupResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#getLogAnalyticsLogGroup.");
    const pathParams = {
      "{namespaceName}": getLogAnalyticsLogGroupRequest.namespaceName,
      "{logAnalyticsLogGroupId}": getLogAnalyticsLogGroupRequest.logAnalyticsLogGroupId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getLogAnalyticsLogGroupRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/logAnalyticsLogGroups/{logAnalyticsLogGroupId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getLogAnalyticsLogGroupRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetLogAnalyticsLogGroupResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsLogGroup",
        bodyModel: "model.LogAnalyticsLogGroup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns a count of Log-Analytics groups.
   * @param GetLogAnalyticsLogGroupsSummaryRequest
   * @return GetLogAnalyticsLogGroupsSummaryResponse
   * @throws OciError when an error occurs
   */
  public async getLogAnalyticsLogGroupsSummary(
    getLogAnalyticsLogGroupsSummaryRequest: requests.GetLogAnalyticsLogGroupsSummaryRequest
  ): Promise<responses.GetLogAnalyticsLogGroupsSummaryResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#getLogAnalyticsLogGroupsSummary.");
    const pathParams = {
      "{namespaceName}": getLogAnalyticsLogGroupsSummaryRequest.namespaceName
    };

    const queryParams = {
      "compartmentId": getLogAnalyticsLogGroupsSummaryRequest.compartmentId
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getLogAnalyticsLogGroupsSummaryRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/logAnalyticsLogGroupsSummary",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getLogAnalyticsLogGroupsSummaryRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetLogAnalyticsLogGroupsSummaryResponse>{},
        body: await response.json(),
        bodyKey: "logGroupSummaryReport",
        bodyModel: "model.LogGroupSummaryReport",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets a configured object storage based collection rule by given id
   * @param GetLogAnalyticsObjectCollectionRuleRequest
   * @return GetLogAnalyticsObjectCollectionRuleResponse
   * @throws OciError when an error occurs
   */
  public async getLogAnalyticsObjectCollectionRule(
    getLogAnalyticsObjectCollectionRuleRequest: requests.GetLogAnalyticsObjectCollectionRuleRequest
  ): Promise<responses.GetLogAnalyticsObjectCollectionRuleResponse> {
    if (this.logger)
      this.logger.debug(
        "Calling operation LogAnalyticsClient#getLogAnalyticsObjectCollectionRule."
      );
    const pathParams = {
      "{namespaceName}": getLogAnalyticsObjectCollectionRuleRequest.namespaceName,
      "{logAnalyticsObjectCollectionRuleId}":
        getLogAnalyticsObjectCollectionRuleRequest.logAnalyticsObjectCollectionRuleId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getLogAnalyticsObjectCollectionRuleRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/namespaces/{namespaceName}/logAnalyticsObjectCollectionRules/{logAnalyticsObjectCollectionRuleId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getLogAnalyticsObjectCollectionRuleRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetLogAnalyticsObjectCollectionRuleResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsObjectCollectionRule",
        bodyModel: "model.LogAnalyticsObjectCollectionRule",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Get Namespace of a tenancy already onboarded in Log Analytics Application
   *
   * @param GetNamespaceRequest
   * @return GetNamespaceResponse
   * @throws OciError when an error occurs
   */
  public async getNamespace(
    getNamespaceRequest: requests.GetNamespaceRequest
  ): Promise<responses.GetNamespaceResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#getNamespace.");
    const pathParams = {
      "{namespaceName}": getNamespaceRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getNamespaceRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getNamespaceRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetNamespaceResponse>{},
        body: await response.json(),
        bodyKey: "namespace",
        bodyModel: "model.Namespace",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * get parser with fields by Name
   * @param GetParserRequest
   * @return GetParserResponse
   * @throws OciError when an error occurs
   */
  public async getParser(
    getParserRequest: requests.GetParserRequest
  ): Promise<responses.GetParserResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#getParser.");
    const pathParams = {
      "{namespaceName}": getParserRequest.namespaceName,
      "{parserName}": getParserRequest.parserName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getParserRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/parsers/{parserName}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getParserRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetParserResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsParser",
        bodyModel: "model.LogAnalyticsParser",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * parser summary
   * @param GetParserSummaryRequest
   * @return GetParserSummaryResponse
   * @throws OciError when an error occurs
   */
  public async getParserSummary(
    getParserSummaryRequest: requests.GetParserSummaryRequest
  ): Promise<responses.GetParserSummaryResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#getParserSummary.");
    const pathParams = {
      "{namespaceName}": getParserSummaryRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getParserSummaryRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/parsersSummary",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getParserSummaryRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetParserSummaryResponse>{},
        body: await response.json(),
        bodyKey: "parserSummaryReport",
        bodyModel: "model.ParserSummaryReport",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns the intermediate results for a query that was specified to run asynchronously if the query has not completed,
   * otherwise the final query results identified by a queryWorkRequestId returned when submitting the query execute asynchronously.
   *
   * @param GetQueryResultRequest
   * @return GetQueryResultResponse
   * @throws OciError when an error occurs
   */
  public async getQueryResult(
    getQueryResultRequest: requests.GetQueryResultRequest
  ): Promise<responses.GetQueryResultResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#getQueryResult.");
    const pathParams = {
      "{namespaceName}": getQueryResultRequest.namespaceName
    };

    const queryParams = {
      "workRequestId": getQueryResultRequest.workRequestId,
      "page": getQueryResultRequest.page,
      "limit": getQueryResultRequest.limit,
      "shouldIncludeColumns": getQueryResultRequest.shouldIncludeColumns,
      "shouldIncludeFields": getQueryResultRequest.shouldIncludeFields,
      "outputMode": getQueryResultRequest.outputMode
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getQueryResultRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/search/actions/query",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getQueryResultRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetQueryResultResponse>{},
        body: await response.json(),
        bodyKey: "queryAggregation",
        bodyModel: "model.QueryAggregation",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("retry-after"),
            key: "retryAfter",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Retrieve work request details by workRequestId. This endpoint can be polled for status tracking of work request. Clients should poll using the interval returned in the retry-after header.
   * @param GetQueryWorkRequestRequest
   * @return GetQueryWorkRequestResponse
   * @throws OciError when an error occurs
   */
  public async getQueryWorkRequest(
    getQueryWorkRequestRequest: requests.GetQueryWorkRequestRequest
  ): Promise<responses.GetQueryWorkRequestResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#getQueryWorkRequest.");
    const pathParams = {
      "{namespaceName}": getQueryWorkRequestRequest.namespaceName,
      "{workRequestId}": getQueryWorkRequestRequest.workRequestId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getQueryWorkRequestRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/queryWorkRequests/{workRequestId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getQueryWorkRequestRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetQueryWorkRequestResponse>{},
        body: await response.json(),
        bodyKey: "queryWorkRequest",
        bodyModel: "model.QueryWorkRequest",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("retry-after"),
            key: "retryAfter",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Get the scheduled task for the specified task identifier.
   * @param GetScheduledTaskRequest
   * @return GetScheduledTaskResponse
   * @throws OciError when an error occurs
   */
  public async getScheduledTask(
    getScheduledTaskRequest: requests.GetScheduledTaskRequest
  ): Promise<responses.GetScheduledTaskResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#getScheduledTask.");
    const pathParams = {
      "{namespaceName}": getScheduledTaskRequest.namespaceName,
      "{scheduledTaskId}": getScheduledTaskRequest.scheduledTaskId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getScheduledTaskRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/scheduledTasks/{scheduledTaskId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getScheduledTaskRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetScheduledTaskResponse>{},
        body: await response.json(),
        bodyKey: "scheduledTask",
        bodyModel: "model.ScheduledTask",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * get source with specified name
   * @param GetSourceRequest
   * @return GetSourceResponse
   * @throws OciError when an error occurs
   */
  public async getSource(
    getSourceRequest: requests.GetSourceRequest
  ): Promise<responses.GetSourceResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#getSource.");
    const pathParams = {
      "{namespaceName}": getSourceRequest.namespaceName,
      "{sourceName}": getSourceRequest.sourceName
    };

    const queryParams = {
      "compartmentId": getSourceRequest.compartmentId
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getSourceRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/sources/{sourceName}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getSourceRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetSourceResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsSource",
        bodyModel: "model.LogAnalyticsSource",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * source summary
   * @param GetSourceSummaryRequest
   * @return GetSourceSummaryResponse
   * @throws OciError when an error occurs
   */
  public async getSourceSummary(
    getSourceSummaryRequest: requests.GetSourceSummaryRequest
  ): Promise<responses.GetSourceSummaryResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#getSourceSummary.");
    const pathParams = {
      "{namespaceName}": getSourceSummaryRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getSourceSummaryRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/sourceSummary",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getSourceSummaryRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetSourceSummaryResponse>{},
        body: await response.json(),
        bodyKey: "sourceSummaryReport",
        bodyModel: "model.SourceSummaryReport",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Storage configuration and status.
   *
   * @param GetStorageRequest
   * @return GetStorageResponse
   * @throws OciError when an error occurs
   */
  public async getStorage(
    getStorageRequest: requests.GetStorageRequest
  ): Promise<responses.GetStorageResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#getStorage.");
    const pathParams = {
      "{namespaceName}": getStorageRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getStorageRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/storage",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getStorageRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetStorageResponse>{},
        body: await response.json(),
        bodyKey: "storage",
        bodyModel: "model.Storage",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Storage usage info includes active, archived or recalled data.  The unit of return value is in bytes.
   *
   * @param GetStorageUsageRequest
   * @return GetStorageUsageResponse
   * @throws OciError when an error occurs
   */
  public async getStorageUsage(
    getStorageUsageRequest: requests.GetStorageUsageRequest
  ): Promise<responses.GetStorageUsageResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#getStorageUsage.");
    const pathParams = {
      "{namespaceName}": getStorageUsageRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getStorageUsageRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/storage/usage",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getStorageUsageRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetStorageUsageResponse>{},
        body: await response.json(),
        bodyKey: "storageUsage",
        bodyModel: "model.StorageUsage",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Retrieve work request details by key. This endpoint can be polled for status tracking of work request.
   * Clients should poll using the interval returned in retry-after header.
   *
   * @param GetStorageWorkRequestRequest
   * @return GetStorageWorkRequestResponse
   * @throws OciError when an error occurs
   */
  public async getStorageWorkRequest(
    getStorageWorkRequestRequest: requests.GetStorageWorkRequestRequest
  ): Promise<responses.GetStorageWorkRequestResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#getStorageWorkRequest.");
    const pathParams = {
      "{workRequestId}": getStorageWorkRequestRequest.workRequestId,
      "{namespaceName}": getStorageWorkRequestRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getStorageWorkRequestRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/storageWorkRequests/{workRequestId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getStorageWorkRequestRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetStorageWorkRequestResponse>{},
        body: await response.json(),
        bodyKey: "storageWorkRequest",
        bodyModel: "model.StorageWorkRequest",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("retry-after"),
            key: "retryAfter",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets an On-Demand Upload info by reference
   * @param GetUploadRequest
   * @return GetUploadResponse
   * @throws OciError when an error occurs
   */
  public async getUpload(
    getUploadRequest: requests.GetUploadRequest
  ): Promise<responses.GetUploadResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#getUpload.");
    const pathParams = {
      "{namespaceName}": getUploadRequest.namespaceName,
      "{uploadReference}": getUploadRequest.uploadReference
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getUploadRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/uploads/{uploadReference}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getUploadRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetUploadResponse>{},
        body: await response.json(),
        bodyKey: "upload",
        bodyModel: "model.Upload",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets the status of the work request with the given ID.
   * @param GetWorkRequestRequest
   * @return GetWorkRequestResponse
   * @throws OciError when an error occurs
   */
  public async getWorkRequest(
    getWorkRequestRequest: requests.GetWorkRequestRequest
  ): Promise<responses.GetWorkRequestResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#getWorkRequest.");
    const pathParams = {
      "{namespaceName}": getWorkRequestRequest.namespaceName,
      "{workRequestId}": getWorkRequestRequest.workRequestId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getWorkRequestRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/workRequests/{workRequestId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getWorkRequestRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetWorkRequestResponse>{},
        body: await response.json(),
        bodyKey: "workRequest",
        bodyModel: "model.WorkRequest",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("retry-after"),
            key: "retryAfter",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * register custom content
   * @param ImportCustomContentRequest
   * @return ImportCustomContentResponse
   * @throws OciError when an error occurs
   */
  public async importCustomContent(
    importCustomContentRequest: requests.ImportCustomContentRequest
  ): Promise<responses.ImportCustomContentResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#importCustomContent.");
    const pathParams = {
      "{namespaceName}": importCustomContentRequest.namespaceName
    };

    const queryParams = {
      "isOverwrite": importCustomContentRequest.isOverwrite
    };

    let headerParams = {
      "opc-retry-token": importCustomContentRequest.opcRetryToken,
      "opc-request-id": importCustomContentRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/contents/actions/importCustomContent",
      method: "POST",
      bodyContent: importCustomContentRequest.importCustomContentFileBody,
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      importCustomContentRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ImportCustomContentResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsImportCustomContent",
        bodyModel: "model.LogAnalyticsImportCustomContent",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * list of entities that have been associated to at least one source
   * @param ListAssociatedEntitiesRequest
   * @return ListAssociatedEntitiesResponse
   * @throws OciError when an error occurs
   */
  public async listAssociatedEntities(
    listAssociatedEntitiesRequest: requests.ListAssociatedEntitiesRequest
  ): Promise<responses.ListAssociatedEntitiesResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#listAssociatedEntities.");
    const pathParams = {
      "{namespaceName}": listAssociatedEntitiesRequest.namespaceName
    };

    const queryParams = {
      "entityId": listAssociatedEntitiesRequest.entityId,
      "entityType": listAssociatedEntitiesRequest.entityType,
      "entityTypeDisplayName": listAssociatedEntitiesRequest.entityTypeDisplayName,
      "limit": listAssociatedEntitiesRequest.limit,
      "page": listAssociatedEntitiesRequest.page,
      "sortOrder": listAssociatedEntitiesRequest.sortOrder,
      "sortBy": listAssociatedEntitiesRequest.sortBy,
      "compartmentId": listAssociatedEntitiesRequest.compartmentId
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listAssociatedEntitiesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/associatedEntities",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listAssociatedEntitiesRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListAssociatedEntitiesResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsAssociatedEntityCollection",
        bodyModel: "model.LogAnalyticsAssociatedEntityCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * association summary by source
   * @param ListConfigWorkRequestsRequest
   * @return ListConfigWorkRequestsResponse
   * @throws OciError when an error occurs
   */
  public async listConfigWorkRequests(
    listConfigWorkRequestsRequest: requests.ListConfigWorkRequestsRequest
  ): Promise<responses.ListConfigWorkRequestsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#listConfigWorkRequests.");
    const pathParams = {
      "{namespaceName}": listConfigWorkRequestsRequest.namespaceName
    };

    const queryParams = {
      "compartmentId": listConfigWorkRequestsRequest.compartmentId,
      "sortOrder": listConfigWorkRequestsRequest.sortOrder,
      "sortBy": listConfigWorkRequestsRequest.sortBy,
      "limit": listConfigWorkRequestsRequest.limit,
      "page": listConfigWorkRequestsRequest.page
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/configWorkRequests",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listConfigWorkRequestsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListConfigWorkRequestsResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsConfigWorkRequestCollection",
        bodyModel: "model.LogAnalyticsConfigWorkRequestCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Return a list of log analytics entities associated with input source log analytics entity.
   * @param ListEntityAssociationsRequest
   * @return ListEntityAssociationsResponse
   * @throws OciError when an error occurs
   */
  public async listEntityAssociations(
    listEntityAssociationsRequest: requests.ListEntityAssociationsRequest
  ): Promise<responses.ListEntityAssociationsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#listEntityAssociations.");
    const pathParams = {
      "{namespaceName}": listEntityAssociationsRequest.namespaceName,
      "{logAnalyticsEntityId}": listEntityAssociationsRequest.logAnalyticsEntityId
    };

    const queryParams = {
      "directOrAllAssociations": listEntityAssociationsRequest.directOrAllAssociations,
      "limit": listEntityAssociationsRequest.limit,
      "page": listEntityAssociationsRequest.page,
      "sortOrder": listEntityAssociationsRequest.sortOrder,
      "sortBy": listEntityAssociationsRequest.sortBy
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listEntityAssociationsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/namespaces/{namespaceName}/logAnalyticsEntities/{logAnalyticsEntityId}/entityAssociations",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listEntityAssociationsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListEntityAssociationsResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsEntityCollection",
        bodyModel: "model.LogAnalyticsEntityCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * entity associations summary
   * @param ListEntitySourceAssociationsRequest
   * @return ListEntitySourceAssociationsResponse
   * @throws OciError when an error occurs
   */
  public async listEntitySourceAssociations(
    listEntitySourceAssociationsRequest: requests.ListEntitySourceAssociationsRequest
  ): Promise<responses.ListEntitySourceAssociationsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#listEntitySourceAssociations.");
    const pathParams = {
      "{namespaceName}": listEntitySourceAssociationsRequest.namespaceName
    };

    const queryParams = {
      "entityId": listEntitySourceAssociationsRequest.entityId,
      "entityType": listEntitySourceAssociationsRequest.entityType,
      "entityTypeDisplayName": listEntitySourceAssociationsRequest.entityTypeDisplayName,
      "lifeCycleState": listEntitySourceAssociationsRequest.lifeCycleState,
      "isShowTotal": listEntitySourceAssociationsRequest.isShowTotal,
      "limit": listEntitySourceAssociationsRequest.limit,
      "page": listEntitySourceAssociationsRequest.page,
      "sortOrder": listEntitySourceAssociationsRequest.sortOrder,
      "sortBy": listEntitySourceAssociationsRequest.sortBy,
      "compartmentId": listEntitySourceAssociationsRequest.compartmentId
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listEntitySourceAssociationsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/entityAssociations",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listEntitySourceAssociationsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListEntitySourceAssociationsResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsAssociationCollection",
        bodyModel: "model.LogAnalyticsAssociationCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * get all common field with specified display name and description
   * @param ListFieldsRequest
   * @return ListFieldsResponse
   * @throws OciError when an error occurs
   */
  public async listFields(
    listFieldsRequest: requests.ListFieldsRequest
  ): Promise<responses.ListFieldsResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#listFields.");
    const pathParams = {
      "{namespaceName}": listFieldsRequest.namespaceName
    };

    const queryParams = {
      "isMatchAll": listFieldsRequest.isMatchAll,
      "sourceIds": listFieldsRequest.sourceIds,
      "sourceNames": listFieldsRequest.sourceNames,
      "parserType": listFieldsRequest.parserType,
      "parserIds": listFieldsRequest.parserIds,
      "parserNames": listFieldsRequest.parserNames,
      "isIncludeParser": listFieldsRequest.isIncludeParser,
      "filter": listFieldsRequest.filter,
      "limit": listFieldsRequest.limit,
      "page": listFieldsRequest.page,
      "sortOrder": listFieldsRequest.sortOrder,
      "sortBy": listFieldsRequest.sortBy
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listFieldsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/fields",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listFieldsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListFieldsResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsFieldCollection",
        bodyModel: "model.LogAnalyticsFieldCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * get list of priorities
   * @param ListLabelPrioritiesRequest
   * @return ListLabelPrioritiesResponse
   * @throws OciError when an error occurs
   */
  public async listLabelPriorities(
    listLabelPrioritiesRequest: requests.ListLabelPrioritiesRequest
  ): Promise<responses.ListLabelPrioritiesResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#listLabelPriorities.");
    const pathParams = {
      "{namespaceName}": listLabelPrioritiesRequest.namespaceName
    };

    const queryParams = {
      "limit": listLabelPrioritiesRequest.limit,
      "page": listLabelPrioritiesRequest.page
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listLabelPrioritiesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/labelPriorities",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listLabelPrioritiesRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListLabelPrioritiesResponse>{},
        body: await response.json(),
        bodyKey: "labelPriorityCollection",
        bodyModel: "model.LabelPriorityCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * get details of sources using the label
   * @param ListLabelSourceDetailsRequest
   * @return ListLabelSourceDetailsResponse
   * @throws OciError when an error occurs
   */
  public async listLabelSourceDetails(
    listLabelSourceDetailsRequest: requests.ListLabelSourceDetailsRequest
  ): Promise<responses.ListLabelSourceDetailsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#listLabelSourceDetails.");
    const pathParams = {
      "{namespaceName}": listLabelSourceDetailsRequest.namespaceName
    };

    const queryParams = {
      "labelName": listLabelSourceDetailsRequest.labelName,
      "limit": listLabelSourceDetailsRequest.limit,
      "page": listLabelSourceDetailsRequest.page,
      "sortOrder": listLabelSourceDetailsRequest.sortOrder,
      "labelSourceSortBy": listLabelSourceDetailsRequest.labelSourceSortBy
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listLabelSourceDetailsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/labelSourceDetails",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listLabelSourceDetailsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListLabelSourceDetailsResponse>{},
        body: await response.json(),
        bodyKey: "labelSourceCollection",
        bodyModel: "model.LabelSourceCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * get labels passing specified filter
   * @param ListLabelsRequest
   * @return ListLabelsResponse
   * @throws OciError when an error occurs
   */
  public async listLabels(
    listLabelsRequest: requests.ListLabelsRequest
  ): Promise<responses.ListLabelsResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#listLabels.");
    const pathParams = {
      "{namespaceName}": listLabelsRequest.namespaceName
    };

    const queryParams = {
      "labelName": listLabelsRequest.labelName,
      "labelDisplayText": listLabelsRequest.labelDisplayText,
      "isSystem": listLabelsRequest.isSystem,
      "labelPriority": listLabelsRequest.labelPriority,
      "isCountPop": listLabelsRequest.isCountPop,
      "isAliasPop": listLabelsRequest.isAliasPop,
      "limit": listLabelsRequest.limit,
      "page": listLabelsRequest.page,
      "sortOrder": listLabelsRequest.sortOrder,
      "labelSortBy": listLabelsRequest.labelSortBy
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listLabelsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/labels",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listLabelsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListLabelsResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsLabelCollection",
        bodyModel: "model.LogAnalyticsLabelCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Return a list of log analytics entities.
   * @param ListLogAnalyticsEntitiesRequest
   * @return ListLogAnalyticsEntitiesResponse
   * @throws OciError when an error occurs
   */
  public async listLogAnalyticsEntities(
    listLogAnalyticsEntitiesRequest: requests.ListLogAnalyticsEntitiesRequest
  ): Promise<responses.ListLogAnalyticsEntitiesResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#listLogAnalyticsEntities.");
    const pathParams = {
      "{namespaceName}": listLogAnalyticsEntitiesRequest.namespaceName
    };

    const queryParams = {
      "compartmentId": listLogAnalyticsEntitiesRequest.compartmentId,
      "name": listLogAnalyticsEntitiesRequest.name,
      "nameContains": listLogAnalyticsEntitiesRequest.nameContains,
      "entityTypeName": listLogAnalyticsEntitiesRequest.entityTypeName,
      "cloudResourceId": listLogAnalyticsEntitiesRequest.cloudResourceId,
      "lifecycleState": listLogAnalyticsEntitiesRequest.lifecycleState,
      "lifecycleDetailsContains": listLogAnalyticsEntitiesRequest.lifecycleDetailsContains,
      "isManagementAgentIdNull": listLogAnalyticsEntitiesRequest.isManagementAgentIdNull,
      "hostname": listLogAnalyticsEntitiesRequest.hostname,
      "hostnameContains": listLogAnalyticsEntitiesRequest.hostnameContains,
      "sourceId": listLogAnalyticsEntitiesRequest.sourceId,
      "limit": listLogAnalyticsEntitiesRequest.limit,
      "page": listLogAnalyticsEntitiesRequest.page,
      "sortOrder": listLogAnalyticsEntitiesRequest.sortOrder,
      "sortBy": listLogAnalyticsEntitiesRequest.sortBy
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listLogAnalyticsEntitiesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/logAnalyticsEntities",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listLogAnalyticsEntitiesRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListLogAnalyticsEntitiesResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsEntityCollection",
        bodyModel: "model.LogAnalyticsEntityCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Return a list of log analytics entity types.
   * @param ListLogAnalyticsEntityTypesRequest
   * @return ListLogAnalyticsEntityTypesResponse
   * @throws OciError when an error occurs
   */
  public async listLogAnalyticsEntityTypes(
    listLogAnalyticsEntityTypesRequest: requests.ListLogAnalyticsEntityTypesRequest
  ): Promise<responses.ListLogAnalyticsEntityTypesResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#listLogAnalyticsEntityTypes.");
    const pathParams = {
      "{namespaceName}": listLogAnalyticsEntityTypesRequest.namespaceName
    };

    const queryParams = {
      "name": listLogAnalyticsEntityTypesRequest.name,
      "nameContains": listLogAnalyticsEntityTypesRequest.nameContains,
      "cloudType": listLogAnalyticsEntityTypesRequest.cloudType,
      "lifecycleState": listLogAnalyticsEntityTypesRequest.lifecycleState,
      "limit": listLogAnalyticsEntityTypesRequest.limit,
      "page": listLogAnalyticsEntityTypesRequest.page,
      "sortOrder": listLogAnalyticsEntityTypesRequest.sortOrder,
      "sortBy": listLogAnalyticsEntityTypesRequest.sortBy
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listLogAnalyticsEntityTypesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/logAnalyticsEntityTypes",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listLogAnalyticsEntityTypesRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListLogAnalyticsEntityTypesResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsEntityTypeCollection",
        bodyModel: "model.LogAnalyticsEntityTypeCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns a list of Log-Analytics groups.
   * @param ListLogAnalyticsLogGroupsRequest
   * @return ListLogAnalyticsLogGroupsResponse
   * @throws OciError when an error occurs
   */
  public async listLogAnalyticsLogGroups(
    listLogAnalyticsLogGroupsRequest: requests.ListLogAnalyticsLogGroupsRequest
  ): Promise<responses.ListLogAnalyticsLogGroupsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#listLogAnalyticsLogGroups.");
    const pathParams = {
      "{namespaceName}": listLogAnalyticsLogGroupsRequest.namespaceName
    };

    const queryParams = {
      "compartmentId": listLogAnalyticsLogGroupsRequest.compartmentId,
      "displayName": listLogAnalyticsLogGroupsRequest.displayName,
      "limit": listLogAnalyticsLogGroupsRequest.limit,
      "page": listLogAnalyticsLogGroupsRequest.page,
      "sortOrder": listLogAnalyticsLogGroupsRequest.sortOrder,
      "sortBy": listLogAnalyticsLogGroupsRequest.sortBy
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listLogAnalyticsLogGroupsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/logAnalyticsLogGroups",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listLogAnalyticsLogGroupsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListLogAnalyticsLogGroupsResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsLogGroupSummaryCollection",
        bodyModel: "model.LogAnalyticsLogGroupSummaryCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets list of configuration details of Object Storage based collection rules.
   * @param ListLogAnalyticsObjectCollectionRulesRequest
   * @return ListLogAnalyticsObjectCollectionRulesResponse
   * @throws OciError when an error occurs
   */
  public async listLogAnalyticsObjectCollectionRules(
    listLogAnalyticsObjectCollectionRulesRequest: requests.ListLogAnalyticsObjectCollectionRulesRequest
  ): Promise<responses.ListLogAnalyticsObjectCollectionRulesResponse> {
    if (this.logger)
      this.logger.debug(
        "Calling operation LogAnalyticsClient#listLogAnalyticsObjectCollectionRules."
      );
    const pathParams = {
      "{namespaceName}": listLogAnalyticsObjectCollectionRulesRequest.namespaceName
    };

    const queryParams = {
      "compartmentId": listLogAnalyticsObjectCollectionRulesRequest.compartmentId,
      "name": listLogAnalyticsObjectCollectionRulesRequest.name,
      "lifecycleState": listLogAnalyticsObjectCollectionRulesRequest.lifecycleState,
      "limit": listLogAnalyticsObjectCollectionRulesRequest.limit,
      "page": listLogAnalyticsObjectCollectionRulesRequest.page,
      "sortOrder": listLogAnalyticsObjectCollectionRulesRequest.sortOrder,
      "sortBy": listLogAnalyticsObjectCollectionRulesRequest.sortBy
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listLogAnalyticsObjectCollectionRulesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/logAnalyticsObjectCollectionRules",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listLogAnalyticsObjectCollectionRulesRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListLogAnalyticsObjectCollectionRulesResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsObjectCollectionRuleCollection",
        bodyModel: "model.LogAnalyticsObjectCollectionRuleCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * get all meta source types
   * @param ListMetaSourceTypesRequest
   * @return ListMetaSourceTypesResponse
   * @throws OciError when an error occurs
   */
  public async listMetaSourceTypes(
    listMetaSourceTypesRequest: requests.ListMetaSourceTypesRequest
  ): Promise<responses.ListMetaSourceTypesResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#listMetaSourceTypes.");
    const pathParams = {
      "{namespaceName}": listMetaSourceTypesRequest.namespaceName
    };

    const queryParams = {
      "limit": listMetaSourceTypesRequest.limit,
      "page": listMetaSourceTypesRequest.page,
      "sortBy": listMetaSourceTypesRequest.sortBy,
      "sortOrder": listMetaSourceTypesRequest.sortOrder
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listMetaSourceTypesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/sourceMetaTypes",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listMetaSourceTypesRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListMetaSourceTypesResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsMetaSourceTypeCollection",
        bodyModel: "model.LogAnalyticsMetaSourceTypeCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * List Namespaces.
   * @param ListNamespacesRequest
   * @return ListNamespacesResponse
   * @throws OciError when an error occurs
   */
  public async listNamespaces(
    listNamespacesRequest: requests.ListNamespacesRequest
  ): Promise<responses.ListNamespacesResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#listNamespaces.");
    const pathParams = {};

    const queryParams = {
      "compartmentId": listNamespacesRequest.compartmentId
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listNamespacesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listNamespacesRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListNamespacesResponse>{},
        body: await response.json(),
        bodyKey: "namespaceCollection",
        bodyModel: "model.NamespaceCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * get pre-process plugin instance
   * @param ListParserFunctionsRequest
   * @return ListParserFunctionsResponse
   * @throws OciError when an error occurs
   */
  public async listParserFunctions(
    listParserFunctionsRequest: requests.ListParserFunctionsRequest
  ): Promise<responses.ListParserFunctionsResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#listParserFunctions.");
    const pathParams = {
      "{namespaceName}": listParserFunctionsRequest.namespaceName
    };

    const queryParams = {
      "parserName": listParserFunctionsRequest.parserName,
      "limit": listParserFunctionsRequest.limit,
      "page": listParserFunctionsRequest.page,
      "sortBy": listParserFunctionsRequest.sortBy,
      "sortOrder": listParserFunctionsRequest.sortOrder
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listParserFunctionsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/parserFunctions",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listParserFunctionsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListParserFunctionsResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsParserFunctionCollection",
        bodyModel: "model.LogAnalyticsParserFunctionCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * get pre-process Meta plugins
   * @param ListParserMetaPluginsRequest
   * @return ListParserMetaPluginsResponse
   * @throws OciError when an error occurs
   */
  public async listParserMetaPlugins(
    listParserMetaPluginsRequest: requests.ListParserMetaPluginsRequest
  ): Promise<responses.ListParserMetaPluginsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#listParserMetaPlugins.");
    const pathParams = {
      "{namespaceName}": listParserMetaPluginsRequest.namespaceName
    };

    const queryParams = {
      "limit": listParserMetaPluginsRequest.limit,
      "page": listParserMetaPluginsRequest.page,
      "sortBy": listParserMetaPluginsRequest.sortBy,
      "sortOrder": listParserMetaPluginsRequest.sortOrder
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listParserMetaPluginsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/parserMetaPlugins",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listParserMetaPluginsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListParserMetaPluginsResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsParserMetaPluginCollection",
        bodyModel: "model.LogAnalyticsParserMetaPluginCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * List parsers passing specified filter
   * @param ListParsersRequest
   * @return ListParsersResponse
   * @throws OciError when an error occurs
   */
  public async listParsers(
    listParsersRequest: requests.ListParsersRequest
  ): Promise<responses.ListParsersResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#listParsers.");
    const pathParams = {
      "{namespaceName}": listParsersRequest.namespaceName
    };

    const queryParams = {
      "isMatchAll": listParsersRequest.isMatchAll,
      "sourceType": listParsersRequest.sourceType,
      "parserName": listParsersRequest.parserName,
      "parserDisplayText": listParsersRequest.parserDisplayText,
      "parserType": listParsersRequest.parserType,
      "isSystem": listParsersRequest.isSystem,
      "limit": listParsersRequest.limit,
      "page": listParsersRequest.page,
      "sortOrder": listParsersRequest.sortOrder,
      "sortBy": listParsersRequest.sortBy
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listParsersRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/parsers",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listParsersRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListParsersResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsParserCollection",
        bodyModel: "model.LogAnalyticsParserCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * List active asynchronous queries.
   * @param ListQueryWorkRequestsRequest
   * @return ListQueryWorkRequestsResponse
   * @throws OciError when an error occurs
   */
  public async listQueryWorkRequests(
    listQueryWorkRequestsRequest: requests.ListQueryWorkRequestsRequest
  ): Promise<responses.ListQueryWorkRequestsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#listQueryWorkRequests.");
    const pathParams = {
      "{namespaceName}": listQueryWorkRequestsRequest.namespaceName
    };

    const queryParams = {
      "mode": listQueryWorkRequestsRequest.mode,
      "compartmentId": listQueryWorkRequestsRequest.compartmentId,
      "limit": listQueryWorkRequestsRequest.limit,
      "page": listQueryWorkRequestsRequest.page,
      "sortOrder": listQueryWorkRequestsRequest.sortOrder,
      "sortBy": listQueryWorkRequestsRequest.sortBy
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listQueryWorkRequestsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/queryWorkRequests",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listQueryWorkRequestsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListQueryWorkRequestsResponse>{},
        body: await response.json(),
        bodyKey: "queryWorkRequestCollection",
        bodyModel: "model.QueryWorkRequestCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Lists scheduled tasks.
   * @param ListScheduledTasksRequest
   * @return ListScheduledTasksResponse
   * @throws OciError when an error occurs
   */
  public async listScheduledTasks(
    listScheduledTasksRequest: requests.ListScheduledTasksRequest
  ): Promise<responses.ListScheduledTasksResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#listScheduledTasks.");
    const pathParams = {
      "{namespaceName}": listScheduledTasksRequest.namespaceName
    };

    const queryParams = {
      "taskType": listScheduledTasksRequest.taskType,
      "compartmentId": listScheduledTasksRequest.compartmentId,
      "limit": listScheduledTasksRequest.limit,
      "page": listScheduledTasksRequest.page,
      "displayName": listScheduledTasksRequest.displayName,
      "sortOrder": listScheduledTasksRequest.sortOrder,
      "sortBy": listScheduledTasksRequest.sortBy
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listScheduledTasksRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/scheduledTasks",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listScheduledTasksRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListScheduledTasksResponse>{},
        body: await response.json(),
        bodyKey: "scheduledTaskCollection",
        bodyModel: "model.ScheduledTaskCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * association summary by source
   * @param ListSourceAssociationsRequest
   * @return ListSourceAssociationsResponse
   * @throws OciError when an error occurs
   */
  public async listSourceAssociations(
    listSourceAssociationsRequest: requests.ListSourceAssociationsRequest
  ): Promise<responses.ListSourceAssociationsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#listSourceAssociations.");
    const pathParams = {
      "{namespaceName}": listSourceAssociationsRequest.namespaceName
    };

    const queryParams = {
      "sourceName": listSourceAssociationsRequest.sourceName,
      "entityId": listSourceAssociationsRequest.entityId,
      "lifeCycleState": listSourceAssociationsRequest.lifeCycleState,
      "isShowTotal": listSourceAssociationsRequest.isShowTotal,
      "compartmentId": listSourceAssociationsRequest.compartmentId,
      "limit": listSourceAssociationsRequest.limit,
      "page": listSourceAssociationsRequest.page,
      "sortOrder": listSourceAssociationsRequest.sortOrder,
      "sortBy": listSourceAssociationsRequest.sortBy
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listSourceAssociationsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/sourceAssociations",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listSourceAssociationsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListSourceAssociationsResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsAssociationCollection",
        bodyModel: "model.LogAnalyticsAssociationCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * get source extended fields for source with specified Id
   * @param ListSourceExtendedFieldDefinitionsRequest
   * @return ListSourceExtendedFieldDefinitionsResponse
   * @throws OciError when an error occurs
   */
  public async listSourceExtendedFieldDefinitions(
    listSourceExtendedFieldDefinitionsRequest: requests.ListSourceExtendedFieldDefinitionsRequest
  ): Promise<responses.ListSourceExtendedFieldDefinitionsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#listSourceExtendedFieldDefinitions.");
    const pathParams = {
      "{namespaceName}": listSourceExtendedFieldDefinitionsRequest.namespaceName,
      "{sourceName}": listSourceExtendedFieldDefinitionsRequest.sourceName
    };

    const queryParams = {
      "limit": listSourceExtendedFieldDefinitionsRequest.limit,
      "page": listSourceExtendedFieldDefinitionsRequest.page,
      "sortBy": listSourceExtendedFieldDefinitionsRequest.sortBy,
      "sortOrder": listSourceExtendedFieldDefinitionsRequest.sortOrder
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listSourceExtendedFieldDefinitionsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/sources/{sourceName}/extendedFieldDefinitions",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listSourceExtendedFieldDefinitionsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListSourceExtendedFieldDefinitionsResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsSourceExtendedFieldDefinitionCollection",
        bodyModel: "model.LogAnalyticsSourceExtendedFieldDefinitionCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * list source label operators
   * @param ListSourceLabelOperatorsRequest
   * @return ListSourceLabelOperatorsResponse
   * @throws OciError when an error occurs
   */
  public async listSourceLabelOperators(
    listSourceLabelOperatorsRequest: requests.ListSourceLabelOperatorsRequest
  ): Promise<responses.ListSourceLabelOperatorsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#listSourceLabelOperators.");
    const pathParams = {
      "{namespaceName}": listSourceLabelOperatorsRequest.namespaceName
    };

    const queryParams = {
      "limit": listSourceLabelOperatorsRequest.limit,
      "page": listSourceLabelOperatorsRequest.page,
      "sortBy": listSourceLabelOperatorsRequest.sortBy,
      "sortOrder": listSourceLabelOperatorsRequest.sortOrder
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listSourceLabelOperatorsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/sourceLabelOperators",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listSourceLabelOperatorsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListSourceLabelOperatorsResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsLabelOperatorCollection",
        bodyModel: "model.LogAnalyticsLabelOperatorCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * get source meta functions
   * @param ListSourceMetaFunctionsRequest
   * @return ListSourceMetaFunctionsResponse
   * @throws OciError when an error occurs
   */
  public async listSourceMetaFunctions(
    listSourceMetaFunctionsRequest: requests.ListSourceMetaFunctionsRequest
  ): Promise<responses.ListSourceMetaFunctionsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#listSourceMetaFunctions.");
    const pathParams = {
      "{namespaceName}": listSourceMetaFunctionsRequest.namespaceName
    };

    const queryParams = {
      "limit": listSourceMetaFunctionsRequest.limit,
      "page": listSourceMetaFunctionsRequest.page,
      "sortBy": listSourceMetaFunctionsRequest.sortBy,
      "sortOrder": listSourceMetaFunctionsRequest.sortOrder
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listSourceMetaFunctionsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/sourceMetaFunctions",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listSourceMetaFunctionsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListSourceMetaFunctionsResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsMetaFunctionCollection",
        bodyModel: "model.LogAnalyticsMetaFunctionCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * get source patterns for source with specified Id
   * @param ListSourcePatternsRequest
   * @return ListSourcePatternsResponse
   * @throws OciError when an error occurs
   */
  public async listSourcePatterns(
    listSourcePatternsRequest: requests.ListSourcePatternsRequest
  ): Promise<responses.ListSourcePatternsResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#listSourcePatterns.");
    const pathParams = {
      "{namespaceName}": listSourcePatternsRequest.namespaceName,
      "{sourceName}": listSourcePatternsRequest.sourceName
    };

    const queryParams = {
      "isInclude": listSourcePatternsRequest.isInclude,
      "limit": listSourcePatternsRequest.limit,
      "page": listSourcePatternsRequest.page,
      "sortBy": listSourcePatternsRequest.sortBy,
      "sortOrder": listSourcePatternsRequest.sortOrder
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listSourcePatternsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/sources/{sourceName}/patterns",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listSourcePatternsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListSourcePatternsResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsSourcePatternCollection",
        bodyModel: "model.LogAnalyticsSourcePatternCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * source list
   * @param ListSourcesRequest
   * @return ListSourcesResponse
   * @throws OciError when an error occurs
   */
  public async listSources(
    listSourcesRequest: requests.ListSourcesRequest
  ): Promise<responses.ListSourcesResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#listSources.");
    const pathParams = {
      "{namespaceName}": listSourcesRequest.namespaceName
    };

    const queryParams = {
      "entityType": listSourcesRequest.entityType,
      "sourceDisplayText": listSourcesRequest.sourceDisplayText,
      "isSystem": listSourcesRequest.isSystem,
      "isAutoAssociated": listSourcesRequest.isAutoAssociated,
      "sortOrder": listSourcesRequest.sortOrder,
      "sortBy": listSourcesRequest.sortBy,
      "limit": listSourcesRequest.limit,
      "page": listSourcesRequest.page,
      "name": listSourcesRequest.name,
      "isSimplified": listSourcesRequest.isSimplified,
      "compartmentId": listSourcesRequest.compartmentId
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listSourcesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/sources",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listSourcesRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListSourcesResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsSourceCollection",
        bodyModel: "model.LogAnalyticsSourceCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Retrieve work request errors if any
   * @param ListStorageWorkRequestErrorsRequest
   * @return ListStorageWorkRequestErrorsResponse
   * @throws OciError when an error occurs
   */
  public async listStorageWorkRequestErrors(
    listStorageWorkRequestErrorsRequest: requests.ListStorageWorkRequestErrorsRequest
  ): Promise<responses.ListStorageWorkRequestErrorsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#listStorageWorkRequestErrors.");
    const pathParams = {
      "{workRequestId}": listStorageWorkRequestErrorsRequest.workRequestId,
      "{namespaceName}": listStorageWorkRequestErrorsRequest.namespaceName
    };

    const queryParams = {
      "compartmentId": listStorageWorkRequestErrorsRequest.compartmentId,
      "limit": listStorageWorkRequestErrorsRequest.limit,
      "page": listStorageWorkRequestErrorsRequest.page,
      "sortOrder": listStorageWorkRequestErrorsRequest.sortOrder,
      "sortBy": listStorageWorkRequestErrorsRequest.sortBy
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listStorageWorkRequestErrorsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/storageWorkRequests/{workRequestId}/errors",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listStorageWorkRequestErrorsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListStorageWorkRequestErrorsResponse>{},
        body: await response.json(),
        bodyKey: "workRequestErrorCollection",
        bodyModel: "model.WorkRequestErrorCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * List non-expired storage manager work requests.
   * @param ListStorageWorkRequestsRequest
   * @return ListStorageWorkRequestsResponse
   * @throws OciError when an error occurs
   */
  public async listStorageWorkRequests(
    listStorageWorkRequestsRequest: requests.ListStorageWorkRequestsRequest
  ): Promise<responses.ListStorageWorkRequestsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#listStorageWorkRequests.");
    const pathParams = {
      "{namespaceName}": listStorageWorkRequestsRequest.namespaceName
    };

    const queryParams = {
      "compartmentId": listStorageWorkRequestsRequest.compartmentId,
      "limit": listStorageWorkRequestsRequest.limit,
      "page": listStorageWorkRequestsRequest.page,
      "sortOrder": listStorageWorkRequestsRequest.sortOrder,
      "sortBy": listStorageWorkRequestsRequest.sortBy,
      "operationType": listStorageWorkRequestsRequest.operationType,
      "status": listStorageWorkRequestsRequest.status,
      "timeStarted": listStorageWorkRequestsRequest.timeStarted,
      "timeFinished": listStorageWorkRequestsRequest.timeFinished,
      "policyName": listStorageWorkRequestsRequest.policyName,
      "policyId": listStorageWorkRequestsRequest.policyId
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listStorageWorkRequestsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/storageWorkRequests",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listStorageWorkRequestsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListStorageWorkRequestsResponse>{},
        body: await response.json(),
        bodyKey: "storageWorkRequestCollection",
        bodyModel: "model.StorageWorkRequestCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets the list of character encodings supported for log files.
   * @param ListSupportedCharEncodingsRequest
   * @return ListSupportedCharEncodingsResponse
   * @throws OciError when an error occurs
   */
  public async listSupportedCharEncodings(
    listSupportedCharEncodingsRequest: requests.ListSupportedCharEncodingsRequest
  ): Promise<responses.ListSupportedCharEncodingsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#listSupportedCharEncodings.");
    const pathParams = {
      "{namespaceName}": listSupportedCharEncodingsRequest.namespaceName
    };

    const queryParams = {
      "limit": listSupportedCharEncodingsRequest.limit,
      "page": listSupportedCharEncodingsRequest.page
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listSupportedCharEncodingsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/supportedCharEncodings",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listSupportedCharEncodingsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListSupportedCharEncodingsResponse>{},
        body: await response.json(),
        bodyKey: "charEncodingCollection",
        bodyModel: "model.CharEncodingCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets timezones that are supported when performing uploads.
   * @param ListSupportedTimezonesRequest
   * @return ListSupportedTimezonesResponse
   * @throws OciError when an error occurs
   */
  public async listSupportedTimezones(
    listSupportedTimezonesRequest: requests.ListSupportedTimezonesRequest
  ): Promise<responses.ListSupportedTimezonesResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#listSupportedTimezones.");
    const pathParams = {
      "{namespaceName}": listSupportedTimezonesRequest.namespaceName
    };

    const queryParams = {
      "limit": listSupportedTimezonesRequest.limit,
      "page": listSupportedTimezonesRequest.page
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listSupportedTimezonesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/supportedTimezones",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listSupportedTimezonesRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListSupportedTimezonesResponse>{},
        body: await response.json(),
        bodyKey: "timezoneCollection",
        bodyModel: "model.TimezoneCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets list of files in an upload.
   * @param ListUploadFilesRequest
   * @return ListUploadFilesResponse
   * @throws OciError when an error occurs
   */
  public async listUploadFiles(
    listUploadFilesRequest: requests.ListUploadFilesRequest
  ): Promise<responses.ListUploadFilesResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#listUploadFiles.");
    const pathParams = {
      "{namespaceName}": listUploadFilesRequest.namespaceName,
      "{uploadReference}": listUploadFilesRequest.uploadReference
    };

    const queryParams = {
      "limit": listUploadFilesRequest.limit,
      "page": listUploadFilesRequest.page,
      "sortOrder": listUploadFilesRequest.sortOrder,
      "sortBy": listUploadFilesRequest.sortBy,
      "searchStr": listUploadFilesRequest.searchStr,
      "status": listUploadFilesRequest.status
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listUploadFilesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/uploads/{uploadReference}/files",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listUploadFilesRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListUploadFilesResponse>{},
        body: await response.json(),
        bodyKey: "uploadFileCollection",
        bodyModel: "model.UploadFileCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets list of warnings in an upload explaining the failures due to incorrect configuration.
   * @param ListUploadWarningsRequest
   * @return ListUploadWarningsResponse
   * @throws OciError when an error occurs
   */
  public async listUploadWarnings(
    listUploadWarningsRequest: requests.ListUploadWarningsRequest
  ): Promise<responses.ListUploadWarningsResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#listUploadWarnings.");
    const pathParams = {
      "{namespaceName}": listUploadWarningsRequest.namespaceName,
      "{uploadReference}": listUploadWarningsRequest.uploadReference
    };

    const queryParams = {
      "limit": listUploadWarningsRequest.limit,
      "page": listUploadWarningsRequest.page
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listUploadWarningsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/uploads/{uploadReference}/warnings",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listUploadWarningsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListUploadWarningsResponse>{},
        body: await response.json(),
        bodyKey: "uploadWarningCollection",
        bodyModel: "model.UploadWarningCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets a list of all On-demand uploads.
   * To use this and other API operations, you must be authorized in an IAM policy.
   *
   * @param ListUploadsRequest
   * @return ListUploadsResponse
   * @throws OciError when an error occurs
   */
  public async listUploads(
    listUploadsRequest: requests.ListUploadsRequest
  ): Promise<responses.ListUploadsResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#listUploads.");
    const pathParams = {
      "{namespaceName}": listUploadsRequest.namespaceName
    };

    const queryParams = {
      "name": listUploadsRequest.name,
      "nameContains": listUploadsRequest.nameContains,
      "limit": listUploadsRequest.limit,
      "page": listUploadsRequest.page,
      "sortOrder": listUploadsRequest.sortOrder,
      "sortBy": listUploadsRequest.sortBy
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listUploadsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/uploads",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listUploadsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListUploadsResponse>{},
        body: await response.json(),
        bodyKey: "uploadCollection",
        bodyModel: "model.UploadCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Return a (paginated) list of errors for a given work request.
   *
   * @param ListWorkRequestErrorsRequest
   * @return ListWorkRequestErrorsResponse
   * @throws OciError when an error occurs
   */
  public async listWorkRequestErrors(
    listWorkRequestErrorsRequest: requests.ListWorkRequestErrorsRequest
  ): Promise<responses.ListWorkRequestErrorsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#listWorkRequestErrors.");
    const pathParams = {
      "{namespaceName}": listWorkRequestErrorsRequest.namespaceName,
      "{workRequestId}": listWorkRequestErrorsRequest.workRequestId
    };

    const queryParams = {
      "page": listWorkRequestErrorsRequest.page,
      "limit": listWorkRequestErrorsRequest.limit
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listWorkRequestErrorsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/workRequests/{workRequestId}/errors",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listWorkRequestErrorsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListWorkRequestErrorsResponse>{},
        body: await response.json(),
        bodyKey: "workRequestErrorCollection",
        bodyModel: "model.WorkRequestErrorCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Return a (paginated) list of logs for a given work request.
   *
   * @param ListWorkRequestLogsRequest
   * @return ListWorkRequestLogsResponse
   * @throws OciError when an error occurs
   */
  public async listWorkRequestLogs(
    listWorkRequestLogsRequest: requests.ListWorkRequestLogsRequest
  ): Promise<responses.ListWorkRequestLogsResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#listWorkRequestLogs.");
    const pathParams = {
      "{namespaceName}": listWorkRequestLogsRequest.namespaceName,
      "{workRequestId}": listWorkRequestLogsRequest.workRequestId
    };

    const queryParams = {
      "page": listWorkRequestLogsRequest.page,
      "limit": listWorkRequestLogsRequest.limit
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listWorkRequestLogsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/workRequests/{workRequestId}/logs",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listWorkRequestLogsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListWorkRequestLogsResponse>{},
        body: await response.json(),
        bodyKey: "workRequestLogCollection",
        bodyModel: "model.WorkRequestLogCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Lists the work requests in a compartment.
   *
   * @param ListWorkRequestsRequest
   * @return ListWorkRequestsResponse
   * @throws OciError when an error occurs
   */
  public async listWorkRequests(
    listWorkRequestsRequest: requests.ListWorkRequestsRequest
  ): Promise<responses.ListWorkRequestsResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#listWorkRequests.");
    const pathParams = {
      "{namespaceName}": listWorkRequestsRequest.namespaceName
    };

    const queryParams = {
      "compartmentId": listWorkRequestsRequest.compartmentId,
      "page": listWorkRequestsRequest.page,
      "limit": listWorkRequestsRequest.limit
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listWorkRequestsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/workRequests",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listWorkRequestsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListWorkRequestsResponse>{},
        body: await response.json(),
        bodyKey: "workRequestCollection",
        bodyModel: "model.WorkRequestCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Off-boards a tenant from Logging Analytics
   * @param OffboardNamespaceRequest
   * @return OffboardNamespaceResponse
   * @throws OciError when an error occurs
   */
  public async offboardNamespace(
    offboardNamespaceRequest: requests.OffboardNamespaceRequest
  ): Promise<responses.OffboardNamespaceResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#offboardNamespace.");
    const pathParams = {
      "{namespaceName}": offboardNamespaceRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": offboardNamespaceRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/actions/offboard",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      offboardNamespaceRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.OffboardNamespaceResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * On-boards a tenant to Logging Analytics.
   *
   * @param OnboardNamespaceRequest
   * @return OnboardNamespaceResponse
   * @throws OciError when an error occurs
   */
  public async onboardNamespace(
    onboardNamespaceRequest: requests.OnboardNamespaceRequest
  ): Promise<responses.OnboardNamespaceResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#onboardNamespace.");
    const pathParams = {
      "{namespaceName}": onboardNamespaceRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-retry-token": onboardNamespaceRequest.opcRetryToken,
      "opc-request-id": onboardNamespaceRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/actions/onboard",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      onboardNamespaceRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.OnboardNamespaceResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Describe query
   * @param ParseQueryRequest
   * @return ParseQueryResponse
   * @throws OciError when an error occurs
   */
  public async parseQuery(
    parseQueryRequest: requests.ParseQueryRequest
  ): Promise<responses.ParseQueryResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#parseQuery.");
    const pathParams = {
      "{namespaceName}": parseQueryRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": parseQueryRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/search/actions/parse",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        parseQueryRequest.parseQueryDetails,
        "ParseQueryDetails",
        models.ParseQueryDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      parseQueryRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ParseQueryResponse>{},
        body: await response.json(),
        bodyKey: "parseQueryOutput",
        bodyModel: "model.ParseQueryOutput",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * submit work requests to purge old data based on the type.
   *
   * @param PurgeStorageDataRequest
   * @return PurgeStorageDataResponse
   * @throws OciError when an error occurs
   */
  public async purgeStorageData(
    purgeStorageDataRequest: requests.PurgeStorageDataRequest
  ): Promise<responses.PurgeStorageDataResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#purgeStorageData.");
    const pathParams = {
      "{namespaceName}": purgeStorageDataRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": purgeStorageDataRequest.opcRequestId,
      "opc-retry-token": purgeStorageDataRequest.opcRetryToken,
      "if-match": purgeStorageDataRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/storage/actions/purgeData",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        purgeStorageDataRequest.purgeStorageDataDetails,
        "PurgeStorageDataDetails",
        models.PurgeStorageDataDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      purgeStorageDataRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.PurgeStorageDataResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("location"),
            key: "location",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Put the work request specified by {workRequestId} into the background.
   * @param PutQueryWorkRequestBackgroundRequest
   * @return PutQueryWorkRequestBackgroundResponse
   * @throws OciError when an error occurs
   */
  public async putQueryWorkRequestBackground(
    putQueryWorkRequestBackgroundRequest: requests.PutQueryWorkRequestBackgroundRequest
  ): Promise<responses.PutQueryWorkRequestBackgroundResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#putQueryWorkRequestBackground.");
    const pathParams = {
      "{namespaceName}": putQueryWorkRequestBackgroundRequest.namespaceName,
      "{workRequestId}": putQueryWorkRequestBackgroundRequest.workRequestId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": putQueryWorkRequestBackgroundRequest.opcRequestId,
      "if-match": putQueryWorkRequestBackgroundRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/queryWorkRequests/{workRequestId}/actions/background",
      method: "PUT",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      putQueryWorkRequestBackgroundRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.PutQueryWorkRequestBackgroundResponse>{},
        body: await response.json(),
        bodyKey: "queryWorkRequest",
        bodyModel: "model.QueryWorkRequest",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Performs a log analytics search, if shouldRunAsync is false returns the query results once they become available subject to 60 second timeout. If a query is subject to exceed that time then it should be run asynchronously. Asynchronous query submissions return the queryWorkRequestId to use for execution tracking, query submission lifecycle actions and to poll for query results.
   *
   * @param QueryRequest
   * @return QueryResponse
   * @throws OciError when an error occurs
   */
  public async query(queryRequest: requests.QueryRequest): Promise<responses.QueryResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#query.");
    const pathParams = {
      "{namespaceName}": queryRequest.namespaceName
    };

    const queryParams = {
      "page": queryRequest.page,
      "limit": queryRequest.limit
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": queryRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/search/actions/query",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        queryRequest.queryDetails,
        "QueryDetails",
        models.QueryDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      queryRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.QueryResponse>{},
        body: await response.json(),
        bodyKey: "queryAggregation",
        bodyModel: "model.QueryAggregation",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page-id"),
            key: "opcNextPageId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-prev-page-id"),
            key: "opcPrevPageId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("location"),
            key: "location",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * submit work requests to recall archived data.
   *
   * @param RecallArchivedDataRequest
   * @return RecallArchivedDataResponse
   * @throws OciError when an error occurs
   */
  public async recallArchivedData(
    recallArchivedDataRequest: requests.RecallArchivedDataRequest
  ): Promise<responses.RecallArchivedDataResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#recallArchivedData.");
    const pathParams = {
      "{namespaceName}": recallArchivedDataRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": recallArchivedDataRequest.opcRequestId,
      "opc-retry-token": recallArchivedDataRequest.opcRetryToken,
      "if-match": recallArchivedDataRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/storage/actions/recallArchivedData",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        recallArchivedDataRequest.recallArchivedDataDetails,
        "RecallArchivedDataDetails",
        models.RecallArchivedDataDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      recallArchivedDataRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.RecallArchivedDataResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("location"),
            key: "location",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * register lookup
   * @param RegisterLookupRequest
   * @return RegisterLookupResponse
   * @throws OciError when an error occurs
   */
  public async registerLookup(
    registerLookupRequest: requests.RegisterLookupRequest
  ): Promise<responses.RegisterLookupResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#registerLookup.");
    const pathParams = {
      "{namespaceName}": registerLookupRequest.namespaceName
    };

    const queryParams = {
      "name": registerLookupRequest.name,
      "description": registerLookupRequest.description,
      "charEncoding": registerLookupRequest.charEncoding,
      "isHidden": registerLookupRequest.isHidden,
      "type": registerLookupRequest.type
    };

    let headerParams = {
      "opc-retry-token": registerLookupRequest.opcRetryToken,
      "opc-request-id": registerLookupRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/lookups/actions/register",
      method: "POST",
      bodyContent: registerLookupRequest.registerLookupContentFileBody,
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      registerLookupRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.RegisterLookupResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsLookup",
        bodyModel: "model.LogAnalyticsLookup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * submit work requests to release recalled data.
   *
   * @param ReleaseRecalledDataRequest
   * @return ReleaseRecalledDataResponse
   * @throws OciError when an error occurs
   */
  public async releaseRecalledData(
    releaseRecalledDataRequest: requests.ReleaseRecalledDataRequest
  ): Promise<responses.ReleaseRecalledDataResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#releaseRecalledData.");
    const pathParams = {
      "{namespaceName}": releaseRecalledDataRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": releaseRecalledDataRequest.opcRequestId,
      "opc-retry-token": releaseRecalledDataRequest.opcRetryToken,
      "if-match": releaseRecalledDataRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/storage/actions/releaseRecalledData",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        releaseRecalledDataRequest.releaseRecalledDataDetails,
        "ReleaseRecalledDataDetails",
        models.ReleaseRecalledDataDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      releaseRecalledDataRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ReleaseRecalledDataResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("location"),
            key: "location",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Delete association between input source log analytics entity and destination entities.
   * @param RemoveEntityAssociationsRequest
   * @return RemoveEntityAssociationsResponse
   * @throws OciError when an error occurs
   */
  public async removeEntityAssociations(
    removeEntityAssociationsRequest: requests.RemoveEntityAssociationsRequest
  ): Promise<responses.RemoveEntityAssociationsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#removeEntityAssociations.");
    const pathParams = {
      "{namespaceName}": removeEntityAssociationsRequest.namespaceName,
      "{logAnalyticsEntityId}": removeEntityAssociationsRequest.logAnalyticsEntityId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": removeEntityAssociationsRequest.ifMatch,
      "opc-request-id": removeEntityAssociationsRequest.opcRequestId,
      "opc-retry-token": removeEntityAssociationsRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/namespaces/{namespaceName}/logAnalyticsEntities/{logAnalyticsEntityId}/actions/removeEntityAssociations",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        removeEntityAssociationsRequest.removeEntityAssociationsDetails,
        "RemoveEntityAssociationsDetails",
        models.RemoveEntityAssociationsDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      removeEntityAssociationsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.RemoveEntityAssociationsResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Execute the saved search acceleration task in the foreground.
   * The ScheduledTask taskType must be ACCELERATION.
   * Optionally specify time range (timeStart and timeEnd). The default is all time.
   *
   * @param RunRequest
   * @return RunResponse
   * @throws OciError when an error occurs
   */
  public async run(runRequest: requests.RunRequest): Promise<responses.RunResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#run.");
    const pathParams = {
      "{namespaceName}": runRequest.namespaceName,
      "{scheduledTaskId}": runRequest.scheduledTaskId
    };

    const queryParams = {
      "timeStart": runRequest.timeStart,
      "timeEnd": runRequest.timeEnd
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": runRequest.opcRequestId,
      "opc-retry-token": runRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/scheduledTasks/{scheduledTaskId}/actions/run",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      runRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.RunResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns a context specific list of either commands, fields, or values to add to the end of the query string.
   * @param SuggestRequest
   * @return SuggestResponse
   * @throws OciError when an error occurs
   */
  public async suggest(
    suggestRequest: requests.SuggestRequest
  ): Promise<responses.SuggestResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#suggest.");
    const pathParams = {
      "{namespaceName}": suggestRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": suggestRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/search/actions/suggest",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        suggestRequest.suggestDetails,
        "SuggestDetails",
        models.SuggestDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      suggestRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.SuggestResponse>{},
        body: await response.json(),
        bodyKey: "suggestOutput",
        bodyModel: "model.SuggestOutput",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * test parser
   * @param TestParserRequest
   * @return TestParserResponse
   * @throws OciError when an error occurs
   */
  public async testParser(
    testParserRequest: requests.TestParserRequest
  ): Promise<responses.TestParserResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#testParser.");
    const pathParams = {
      "{namespaceName}": testParserRequest.namespaceName
    };

    const queryParams = {
      "scope": testParserRequest.scope,
      "reqOriginModule": testParserRequest.reqOriginModule
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-retry-token": testParserRequest.opcRetryToken,
      "opc-request-id": testParserRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/parsers/actions/test",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        testParserRequest.testParserPayloadDetails,
        "TestParserPayloadDetails",
        models.TestParserPayloadDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      testParserRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.TestParserResponse>{},
        body: await response.json(),
        bodyKey: "parserTestResult",
        bodyModel: "model.ParserTestResult",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Update the log analytics entity with the given id.
   * @param UpdateLogAnalyticsEntityRequest
   * @return UpdateLogAnalyticsEntityResponse
   * @throws OciError when an error occurs
   */
  public async updateLogAnalyticsEntity(
    updateLogAnalyticsEntityRequest: requests.UpdateLogAnalyticsEntityRequest
  ): Promise<responses.UpdateLogAnalyticsEntityResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#updateLogAnalyticsEntity.");
    const pathParams = {
      "{namespaceName}": updateLogAnalyticsEntityRequest.namespaceName,
      "{logAnalyticsEntityId}": updateLogAnalyticsEntityRequest.logAnalyticsEntityId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": updateLogAnalyticsEntityRequest.ifMatch,
      "opc-request-id": updateLogAnalyticsEntityRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/logAnalyticsEntities/{logAnalyticsEntityId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateLogAnalyticsEntityRequest.updateLogAnalyticsEntityDetails,
        "UpdateLogAnalyticsEntityDetails",
        models.UpdateLogAnalyticsEntityDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateLogAnalyticsEntityRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateLogAnalyticsEntityResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsEntity",
        bodyModel: "model.LogAnalyticsEntity",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Update custom log analytics entity type. Out of box entity types cannot be udpated.
   * @param UpdateLogAnalyticsEntityTypeRequest
   * @return UpdateLogAnalyticsEntityTypeResponse
   * @throws OciError when an error occurs
   */
  public async updateLogAnalyticsEntityType(
    updateLogAnalyticsEntityTypeRequest: requests.UpdateLogAnalyticsEntityTypeRequest
  ): Promise<responses.UpdateLogAnalyticsEntityTypeResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#updateLogAnalyticsEntityType.");
    const pathParams = {
      "{namespaceName}": updateLogAnalyticsEntityTypeRequest.namespaceName,
      "{entityTypeName}": updateLogAnalyticsEntityTypeRequest.entityTypeName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": updateLogAnalyticsEntityTypeRequest.opcRequestId,
      "if-match": updateLogAnalyticsEntityTypeRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/logAnalyticsEntityTypes/{entityTypeName}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateLogAnalyticsEntityTypeRequest.updateLogAnalyticsEntityTypeDetails,
        "UpdateLogAnalyticsEntityTypeDetails",
        models.UpdateLogAnalyticsEntityTypeDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateLogAnalyticsEntityTypeRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateLogAnalyticsEntityTypeResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Updates the Log-Analytics group with the given id.
   * @param UpdateLogAnalyticsLogGroupRequest
   * @return UpdateLogAnalyticsLogGroupResponse
   * @throws OciError when an error occurs
   */
  public async updateLogAnalyticsLogGroup(
    updateLogAnalyticsLogGroupRequest: requests.UpdateLogAnalyticsLogGroupRequest
  ): Promise<responses.UpdateLogAnalyticsLogGroupResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#updateLogAnalyticsLogGroup.");
    const pathParams = {
      "{namespaceName}": updateLogAnalyticsLogGroupRequest.namespaceName,
      "{logAnalyticsLogGroupId}": updateLogAnalyticsLogGroupRequest.logAnalyticsLogGroupId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": updateLogAnalyticsLogGroupRequest.ifMatch,
      "opc-request-id": updateLogAnalyticsLogGroupRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/logAnalyticsLogGroups/{logAnalyticsLogGroupId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateLogAnalyticsLogGroupRequest.updateLogAnalyticsLogGroupDetails,
        "UpdateLogAnalyticsLogGroupDetails",
        models.UpdateLogAnalyticsLogGroupDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateLogAnalyticsLogGroupRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateLogAnalyticsLogGroupResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsLogGroup",
        bodyModel: "model.LogAnalyticsLogGroup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Update the rule with the given id.
   * @param UpdateLogAnalyticsObjectCollectionRuleRequest
   * @return UpdateLogAnalyticsObjectCollectionRuleResponse
   * @throws OciError when an error occurs
   */
  public async updateLogAnalyticsObjectCollectionRule(
    updateLogAnalyticsObjectCollectionRuleRequest: requests.UpdateLogAnalyticsObjectCollectionRuleRequest
  ): Promise<responses.UpdateLogAnalyticsObjectCollectionRuleResponse> {
    if (this.logger)
      this.logger.debug(
        "Calling operation LogAnalyticsClient#updateLogAnalyticsObjectCollectionRule."
      );
    const pathParams = {
      "{namespaceName}": updateLogAnalyticsObjectCollectionRuleRequest.namespaceName,
      "{logAnalyticsObjectCollectionRuleId}":
        updateLogAnalyticsObjectCollectionRuleRequest.logAnalyticsObjectCollectionRuleId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": updateLogAnalyticsObjectCollectionRuleRequest.ifMatch,
      "opc-request-id": updateLogAnalyticsObjectCollectionRuleRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/namespaces/{namespaceName}/logAnalyticsObjectCollectionRules/{logAnalyticsObjectCollectionRuleId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateLogAnalyticsObjectCollectionRuleRequest.updateLogAnalyticsObjectCollectionRuleDetails,
        "UpdateLogAnalyticsObjectCollectionRuleDetails",
        models.UpdateLogAnalyticsObjectCollectionRuleDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateLogAnalyticsObjectCollectionRuleRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateLogAnalyticsObjectCollectionRuleResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsObjectCollectionRule",
        bodyModel: "model.LogAnalyticsObjectCollectionRule",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Update the scheduled task. Schedules may be updated only for taskType SAVED_SEARCH and PURGE.
   * @param UpdateScheduledTaskRequest
   * @return UpdateScheduledTaskResponse
   * @throws OciError when an error occurs
   */
  public async updateScheduledTask(
    updateScheduledTaskRequest: requests.UpdateScheduledTaskRequest
  ): Promise<responses.UpdateScheduledTaskResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#updateScheduledTask.");
    const pathParams = {
      "{namespaceName}": updateScheduledTaskRequest.namespaceName,
      "{scheduledTaskId}": updateScheduledTaskRequest.scheduledTaskId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": updateScheduledTaskRequest.opcRequestId,
      "if-match": updateScheduledTaskRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/scheduledTasks/{scheduledTaskId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateScheduledTaskRequest.updateScheduledTaskDetails,
        "UpdateScheduledTaskDetails",
        models.UpdateScheduledTaskDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateScheduledTaskRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateScheduledTaskResponse>{},
        body: await response.json(),
        bodyKey: "scheduledTask",
        bodyModel: "model.ScheduledTask",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * update the archiving configuration
   *
   * @param UpdateStorageRequest
   * @return UpdateStorageResponse
   * @throws OciError when an error occurs
   */
  public async updateStorage(
    updateStorageRequest: requests.UpdateStorageRequest
  ): Promise<responses.UpdateStorageResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#updateStorage.");
    const pathParams = {
      "{namespaceName}": updateStorageRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": updateStorageRequest.opcRequestId,
      "if-match": updateStorageRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/storage",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateStorageRequest.updateStorageDetails,
        "UpdateStorageDetails",
        models.UpdateStorageDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateStorageRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateStorageResponse>{},
        body: await response.json(),
        bodyKey: "storage",
        bodyModel: "model.Storage",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Accepts log data for processing by Log Analytics.
   *
   * @param UploadLogFileRequest
   * @return UploadLogFileResponse
   * @throws OciError when an error occurs
   */
  public async uploadLogFile(
    uploadLogFileRequest: requests.UploadLogFileRequest
  ): Promise<responses.UploadLogFileResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#uploadLogFile.");
    const pathParams = {
      "{namespaceName}": uploadLogFileRequest.namespaceName
    };

    const queryParams = {
      "uploadName": uploadLogFileRequest.uploadName,
      "logSourceName": uploadLogFileRequest.logSourceName,
      "entityId": uploadLogFileRequest.entityId,
      "timezone": uploadLogFileRequest.timezone,
      "charEncoding": uploadLogFileRequest.charEncoding,
      "dateFormat": uploadLogFileRequest.dateFormat,
      "dateYear": uploadLogFileRequest.dateYear,
      "invalidateCache": uploadLogFileRequest.invalidateCache,
      "filename": uploadLogFileRequest.filename
    };

    let headerParams = {
      "opc-request-id": uploadLogFileRequest.opcRequestId,
      "content-md5": uploadLogFileRequest.contentMd5,
      "content-type": uploadLogFileRequest.contentType,
      "opc-meta-loggrpid": uploadLogFileRequest.opcMetaLoggrpid,
      "opc-retry-token": uploadLogFileRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/actions/uploadLogFile",
      method: "POST",
      bodyContent: uploadLogFileRequest.uploadLogFileBody,
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      uploadLogFileRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request, true);
      const sdkResponse = composeResponse({
        responseObject: <responses.UploadLogFileResponse>{},
        body: await response.json(),
        bodyKey: "upload",
        bodyModel: "model.Upload",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-content-md5"),
            key: "opcContentMd5",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-object-id"),
            key: "opcObjectId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * create or update associations for a source
   * @param UpsertAssociationsRequest
   * @return UpsertAssociationsResponse
   * @throws OciError when an error occurs
   */
  public async upsertAssociations(
    upsertAssociationsRequest: requests.UpsertAssociationsRequest
  ): Promise<responses.UpsertAssociationsResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#upsertAssociations.");
    const pathParams = {
      "{namespaceName}": upsertAssociationsRequest.namespaceName
    };

    const queryParams = {
      "isFromRepublish": upsertAssociationsRequest.isFromRepublish
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-retry-token": upsertAssociationsRequest.opcRetryToken,
      "opc-request-id": upsertAssociationsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/associations/actions/upsert",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        upsertAssociationsRequest.upsertLogAnalyticsAssociationDetails,
        "UpsertLogAnalyticsAssociationDetails",
        models.UpsertLogAnalyticsAssociationDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      upsertAssociationsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpsertAssociationsResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Defines or update a field.
   * @param UpsertFieldRequest
   * @return UpsertFieldResponse
   * @throws OciError when an error occurs
   */
  public async upsertField(
    upsertFieldRequest: requests.UpsertFieldRequest
  ): Promise<responses.UpsertFieldResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#upsertField.");
    const pathParams = {
      "{namespaceName}": upsertFieldRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-retry-token": upsertFieldRequest.opcRetryToken,
      "opc-request-id": upsertFieldRequest.opcRequestId,
      "if-match": upsertFieldRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/fields/actions/upsert",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        upsertFieldRequest.upsertLogAnalyticsFieldDetails,
        "UpsertLogAnalyticsFieldDetails",
        models.UpsertLogAnalyticsFieldDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      upsertFieldRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpsertFieldResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsField",
        bodyModel: "model.LogAnalyticsField",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Define or update a label.
   * @param UpsertLabelRequest
   * @return UpsertLabelResponse
   * @throws OciError when an error occurs
   */
  public async upsertLabel(
    upsertLabelRequest: requests.UpsertLabelRequest
  ): Promise<responses.UpsertLabelResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#upsertLabel.");
    const pathParams = {
      "{namespaceName}": upsertLabelRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-retry-token": upsertLabelRequest.opcRetryToken,
      "opc-request-id": upsertLabelRequest.opcRequestId,
      "if-match": upsertLabelRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/labels/actions/upsert",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        upsertLabelRequest.upsertLogAnalyticsLabelDetails,
        "UpsertLogAnalyticsLabelDetails",
        models.UpsertLogAnalyticsLabelDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      upsertLabelRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpsertLabelResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsLabel",
        bodyModel: "model.LogAnalyticsLabel",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Define or update parser
   * @param UpsertParserRequest
   * @return UpsertParserResponse
   * @throws OciError when an error occurs
   */
  public async upsertParser(
    upsertParserRequest: requests.UpsertParserRequest
  ): Promise<responses.UpsertParserResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#upsertParser.");
    const pathParams = {
      "{namespaceName}": upsertParserRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-retry-token": upsertParserRequest.opcRetryToken,
      "opc-request-id": upsertParserRequest.opcRequestId,
      "if-match": upsertParserRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/parsers/actions/upsert",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        upsertParserRequest.upsertLogAnalyticsParserDetails,
        "UpsertLogAnalyticsParserDetails",
        models.UpsertLogAnalyticsParserDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      upsertParserRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpsertParserResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsParser",
        bodyModel: "model.LogAnalyticsParser",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Define or update a source
   * @param UpsertSourceRequest
   * @return UpsertSourceResponse
   * @throws OciError when an error occurs
   */
  public async upsertSource(
    upsertSourceRequest: requests.UpsertSourceRequest
  ): Promise<responses.UpsertSourceResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#upsertSource.");
    const pathParams = {
      "{namespaceName}": upsertSourceRequest.namespaceName
    };

    const queryParams = {
      "createLikeSourceId": upsertSourceRequest.createLikeSourceId,
      "isIncremental": upsertSourceRequest.isIncremental,
      "isIgnoreWarning": upsertSourceRequest.isIgnoreWarning
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-retry-token": upsertSourceRequest.opcRetryToken,
      "opc-request-id": upsertSourceRequest.opcRequestId,
      "if-match": upsertSourceRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/sources/actions/upsert",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        upsertSourceRequest.upsertLogAnalyticsSourceDetails,
        "UpsertLogAnalyticsSourceDetails",
        models.UpsertLogAnalyticsSourceDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      upsertSourceRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpsertSourceResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsSource",
        bodyModel: "model.LogAnalyticsSource",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * association parameter validation
   * @param ValidateAssociationParametersRequest
   * @return ValidateAssociationParametersResponse
   * @throws OciError when an error occurs
   */
  public async validateAssociationParameters(
    validateAssociationParametersRequest: requests.ValidateAssociationParametersRequest
  ): Promise<responses.ValidateAssociationParametersResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#validateAssociationParameters.");
    const pathParams = {
      "{namespaceName}": validateAssociationParametersRequest.namespaceName
    };

    const queryParams = {
      "limit": validateAssociationParametersRequest.limit,
      "page": validateAssociationParametersRequest.page,
      "sortOrder": validateAssociationParametersRequest.sortOrder,
      "sortBy": validateAssociationParametersRequest.sortBy
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-retry-token": validateAssociationParametersRequest.opcRetryToken,
      "opc-request-id": validateAssociationParametersRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/associations/actions/validateParameters",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        validateAssociationParametersRequest.upsertLogAnalyticsAssociationDetails,
        "UpsertLogAnalyticsAssociationDetails",
        models.UpsertLogAnalyticsAssociationDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      validateAssociationParametersRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ValidateAssociationParametersResponse>{},
        body: await response.json(),
        bodyKey: "logAnalyticsAssociationParameterCollection",
        bodyModel: "model.LogAnalyticsAssociationParameterCollection",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Validates a log file to check whether it is eligible to upload or not.
   * @param ValidateFileRequest
   * @return ValidateFileResponse
   * @throws OciError when an error occurs
   */
  public async validateFile(
    validateFileRequest: requests.ValidateFileRequest
  ): Promise<responses.ValidateFileResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#validateFile.");
    const pathParams = {
      "{namespaceName}": validateFileRequest.namespaceName
    };

    const queryParams = {
      "objectLocation": validateFileRequest.objectLocation,
      "filename": validateFileRequest.filename
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": validateFileRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/uploads/actions/validateFile",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      validateFileRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ValidateFileResponse>{},
        body: await response.json(),
        bodyKey: "fileValidationResponse",
        bodyModel: "model.FileValidationResponse",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Pre-define or update a source
   * @param ValidateSourceRequest
   * @return ValidateSourceResponse
   * @throws OciError when an error occurs
   */
  public async validateSource(
    validateSourceRequest: requests.ValidateSourceRequest
  ): Promise<responses.ValidateSourceResponse> {
    if (this.logger) this.logger.debug("Calling operation LogAnalyticsClient#validateSource.");
    const pathParams = {
      "{namespaceName}": validateSourceRequest.namespaceName
    };

    const queryParams = {
      "createLikeSourceId": validateSourceRequest.createLikeSourceId,
      "isIncremental": validateSourceRequest.isIncremental,
      "isIgnoreWarning": validateSourceRequest.isIgnoreWarning
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-retry-token": validateSourceRequest.opcRetryToken,
      "opc-request-id": validateSourceRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/sources/actions/validate",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        validateSourceRequest.upsertLogAnalyticsSourceDetails,
        "UpsertLogAnalyticsSourceDetails",
        models.UpsertLogAnalyticsSourceDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      validateSourceRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ValidateSourceResponse>{},
        body: await response.json(),
        bodyKey: "sourceValidateResults",
        bodyModel: "model.SourceValidateResults",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * test extended fields
   * @param ValidateSourceExtendedFieldDetailsRequest
   * @return ValidateSourceExtendedFieldDetailsResponse
   * @throws OciError when an error occurs
   */
  public async validateSourceExtendedFieldDetails(
    validateSourceExtendedFieldDetailsRequest: requests.ValidateSourceExtendedFieldDetailsRequest
  ): Promise<responses.ValidateSourceExtendedFieldDetailsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#validateSourceExtendedFieldDetails.");
    const pathParams = {
      "{namespaceName}": validateSourceExtendedFieldDetailsRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-retry-token": validateSourceExtendedFieldDetailsRequest.opcRetryToken,
      "opc-request-id": validateSourceExtendedFieldDetailsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/sources/actions/validateExtendedFields",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        validateSourceExtendedFieldDetailsRequest.logAnalyticsSource,
        "LogAnalyticsSource",
        models.LogAnalyticsSource.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      validateSourceExtendedFieldDetailsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ValidateSourceExtendedFieldDetailsResponse>{},
        body: await response.json(),
        bodyKey: "extendedFieldsValidationResult",
        bodyModel: "model.ExtendedFieldsValidationResult",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Validates the source mapping for given file and provides match status and parsed representation of log data.
   * @param ValidateSourceMappingRequest
   * @return ValidateSourceMappingResponse
   * @throws OciError when an error occurs
   */
  public async validateSourceMapping(
    validateSourceMappingRequest: requests.ValidateSourceMappingRequest
  ): Promise<responses.ValidateSourceMappingResponse> {
    if (this.logger)
      this.logger.debug("Calling operation LogAnalyticsClient#validateSourceMapping.");
    const pathParams = {
      "{namespaceName}": validateSourceMappingRequest.namespaceName
    };

    const queryParams = {
      "objectLocation": validateSourceMappingRequest.objectLocation,
      "filename": validateSourceMappingRequest.filename,
      "logSourceName": validateSourceMappingRequest.logSourceName
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": validateSourceMappingRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/namespaces/{namespaceName}/uploads/actions/validateSourceMapping",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      validateSourceMappingRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ValidateSourceMappingResponse>{},
        body: await response.json(),
        bodyKey: "sourceMappingResponse",
        bodyModel: "model.SourceMappingResponse",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }
}
