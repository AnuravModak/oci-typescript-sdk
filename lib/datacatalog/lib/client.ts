/**
 * Data Catalog API
 * Use the Data Catalog APIs to collect, organize, find, access, understand, enrich, and activate technical, business, and operational metadata.
 * OpenAPI spec version: 20190325
 *
 *
 * NOTE: This class is auto generated by OracleSDKGenerator.
 * Do not edit the class manually.
 *
 * Copyright (c) 2020, Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */

import common = require("oci-common");
import * as requests from "./request";
import * as models from "./model";
import * as responses from "./response";
import { paginateRecords, paginateResponses } from "oci-common";
import { DataCatalogWaiter } from "./datacatalog-waiter";
import { composeResponse, composeRequest, GenericRetrier } from "oci-common";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum DataCatalogApiKeys {}

export class DataCatalogClient {
  protected static serviceEndpointTemplate = "https://datacatalog.{region}.oci.{secondLevelDomain}";
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": DataCatalogWaiter;
  protected "_clientConfiguration": common.ClientConfiguration;

  protected _httpClient: common.HttpClient;

  constructor(params: common.AuthParams) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._httpClient = params.httpClient || new common.FetchHttpClient(requestSigner);

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Get the endpoint that is being used to call (ex, https://www.example.com).
   */
  public get endpoint() {
    return this._endpoint;
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20190325";
    if (this.logger) this.logger.info(`DataCatalogClient endpoint set to ${this._endpoint}`);
  }

  public get logger() {
    return common.LOG.logger;
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      DataCatalogClient.serviceEndpointTemplate,
      region
    );
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      DataCatalogClient.serviceEndpointTemplate,
      regionId
    );
  }

  /**
   * Creates a new DataCatalogWaiter for resources for this service.
   *
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(config?: common.WaiterConfiguration): DataCatalogWaiter {
    this._waiters = new DataCatalogWaiter(this, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): DataCatalogWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Sets the client configuration for the client
   */
  public set clientConfiguration(clientConfiguration: common.ClientConfiguration) {
    this._clientConfiguration = clientConfiguration;
  }

  /**
   * Attaches a private reverse connection endpoint resource to a data catalog resource. When provided, 'If-Match' is checked against 'ETag' values of the resource.
   * @param AttachCatalogPrivateEndpointRequest
   * @return AttachCatalogPrivateEndpointResponse
   * @throws OciError when an error occurs
   */
  public async attachCatalogPrivateEndpoint(
    attachCatalogPrivateEndpointRequest: requests.AttachCatalogPrivateEndpointRequest
  ): Promise<responses.AttachCatalogPrivateEndpointResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataCatalogClient#attachCatalogPrivateEndpoint.");
    const pathParams = {
      "{catalogId}": attachCatalogPrivateEndpointRequest.catalogId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": attachCatalogPrivateEndpointRequest.ifMatch,
      "opc-request-id": attachCatalogPrivateEndpointRequest.opcRequestId,
      "opc-retry-token": attachCatalogPrivateEndpointRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/actions/attachCatalogPrivateEndpoint",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        attachCatalogPrivateEndpointRequest.attachCatalogPrivateEndpointDetails,
        "AttachCatalogPrivateEndpointDetails",
        models.AttachCatalogPrivateEndpointDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      attachCatalogPrivateEndpointRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.AttachCatalogPrivateEndpointResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Moves a resource into a different compartment. When provided, 'If-Match' is checked against 'ETag' values of the resource.
   * @param ChangeCatalogCompartmentRequest
   * @return ChangeCatalogCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeCatalogCompartment(
    changeCatalogCompartmentRequest: requests.ChangeCatalogCompartmentRequest
  ): Promise<responses.ChangeCatalogCompartmentResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataCatalogClient#changeCatalogCompartment.");
    const pathParams = {
      "{catalogId}": changeCatalogCompartmentRequest.catalogId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": changeCatalogCompartmentRequest.ifMatch,
      "opc-request-id": changeCatalogCompartmentRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeCatalogCompartmentRequest.changeCatalogCompartmentDetails,
        "ChangeCatalogCompartmentDetails",
        models.ChangeCatalogCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      changeCatalogCompartmentRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeCatalogCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Moves a resource into a different compartment. When provided, 'If-Match' is checked against 'ETag' values of the resource.
   * @param ChangeCatalogPrivateEndpointCompartmentRequest
   * @return ChangeCatalogPrivateEndpointCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeCatalogPrivateEndpointCompartment(
    changeCatalogPrivateEndpointCompartmentRequest: requests.ChangeCatalogPrivateEndpointCompartmentRequest
  ): Promise<responses.ChangeCatalogPrivateEndpointCompartmentResponse> {
    if (this.logger)
      this.logger.debug(
        "Calling operation DataCatalogClient#changeCatalogPrivateEndpointCompartment."
      );
    const pathParams = {
      "{catalogPrivateEndpointId}":
        changeCatalogPrivateEndpointCompartmentRequest.catalogPrivateEndpointId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": changeCatalogPrivateEndpointCompartmentRequest.ifMatch,
      "opc-request-id": changeCatalogPrivateEndpointCompartmentRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogPrivateEndpoints/{catalogPrivateEndpointId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeCatalogPrivateEndpointCompartmentRequest.changeCatalogPrivateEndpointCompartmentDetails,
        "ChangeCatalogPrivateEndpointCompartmentDetails",
        models.ChangeCatalogPrivateEndpointCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      changeCatalogPrivateEndpointCompartmentRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeCatalogPrivateEndpointCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new entity attribute.
   * @param CreateAttributeRequest
   * @return CreateAttributeResponse
   * @throws OciError when an error occurs
   */
  public async createAttribute(
    createAttributeRequest: requests.CreateAttributeRequest
  ): Promise<responses.CreateAttributeResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#createAttribute.");
    const pathParams = {
      "{catalogId}": createAttributeRequest.catalogId,
      "{dataAssetKey}": createAttributeRequest.dataAssetKey,
      "{entityKey}": createAttributeRequest.entityKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createAttributeRequest.opcRequestId,
      "opc-retry-token": createAttributeRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/entities/{entityKey}/attributes",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createAttributeRequest.createAttributeDetails,
        "CreateAttributeDetails",
        models.CreateAttributeDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createAttributeRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateAttributeResponse>{},
        body: await response.json(),
        bodyKey: "attribute",
        bodyModel: "model.Attribute",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new entity attribute tag.
   * @param CreateAttributeTagRequest
   * @return CreateAttributeTagResponse
   * @throws OciError when an error occurs
   */
  public async createAttributeTag(
    createAttributeTagRequest: requests.CreateAttributeTagRequest
  ): Promise<responses.CreateAttributeTagResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#createAttributeTag.");
    const pathParams = {
      "{catalogId}": createAttributeTagRequest.catalogId,
      "{dataAssetKey}": createAttributeTagRequest.dataAssetKey,
      "{entityKey}": createAttributeTagRequest.entityKey,
      "{attributeKey}": createAttributeTagRequest.attributeKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createAttributeTagRequest.opcRequestId,
      "opc-retry-token": createAttributeTagRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/entities/{entityKey}/attributes/{attributeKey}/tags",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createAttributeTagRequest.createAttributeTagDetails,
        "CreateTagDetails",
        models.CreateTagDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createAttributeTagRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateAttributeTagResponse>{},
        body: await response.json(),
        bodyKey: "attributeTag",
        bodyModel: "model.AttributeTag",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new data catalog instance that includes a console and an API URL for managing metadata operations.
   * For more information, please see the documentation.
   *
   * @param CreateCatalogRequest
   * @return CreateCatalogResponse
   * @throws OciError when an error occurs
   */
  public async createCatalog(
    createCatalogRequest: requests.CreateCatalogRequest
  ): Promise<responses.CreateCatalogResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#createCatalog.");
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createCatalogRequest.opcRetryToken,
      "opc-request-id": createCatalogRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createCatalogRequest.createCatalogDetails,
        "CreateCatalogDetails",
        models.CreateCatalogDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createCatalogRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateCatalogResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Create a new private reverse connection endpoint.
   * @param CreateCatalogPrivateEndpointRequest
   * @return CreateCatalogPrivateEndpointResponse
   * @throws OciError when an error occurs
   */
  public async createCatalogPrivateEndpoint(
    createCatalogPrivateEndpointRequest: requests.CreateCatalogPrivateEndpointRequest
  ): Promise<responses.CreateCatalogPrivateEndpointResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataCatalogClient#createCatalogPrivateEndpoint.");
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createCatalogPrivateEndpointRequest.opcRequestId,
      "opc-retry-token": createCatalogPrivateEndpointRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogPrivateEndpoints",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createCatalogPrivateEndpointRequest.createCatalogPrivateEndpointDetails,
        "CreateCatalogPrivateEndpointDetails",
        models.CreateCatalogPrivateEndpointDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createCatalogPrivateEndpointRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateCatalogPrivateEndpointResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new connection.
   * @param CreateConnectionRequest
   * @return CreateConnectionResponse
   * @throws OciError when an error occurs
   */
  public async createConnection(
    createConnectionRequest: requests.CreateConnectionRequest
  ): Promise<responses.CreateConnectionResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#createConnection.");
    const pathParams = {
      "{catalogId}": createConnectionRequest.catalogId,
      "{dataAssetKey}": createConnectionRequest.dataAssetKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createConnectionRequest.opcRequestId,
      "opc-retry-token": createConnectionRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/connections",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createConnectionRequest.createConnectionDetails,
        "CreateConnectionDetails",
        models.CreateConnectionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createConnectionRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateConnectionResponse>{},
        body: await response.json(),
        bodyKey: "connection",
        bodyModel: "model.Connection",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Create a new data asset.
   * @param CreateDataAssetRequest
   * @return CreateDataAssetResponse
   * @throws OciError when an error occurs
   */
  public async createDataAsset(
    createDataAssetRequest: requests.CreateDataAssetRequest
  ): Promise<responses.CreateDataAssetResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#createDataAsset.");
    const pathParams = {
      "{catalogId}": createDataAssetRequest.catalogId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createDataAssetRequest.opcRequestId,
      "opc-retry-token": createDataAssetRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createDataAssetRequest.createDataAssetDetails,
        "CreateDataAssetDetails",
        models.CreateDataAssetDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createDataAssetRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateDataAssetResponse>{},
        body: await response.json(),
        bodyKey: "dataAsset",
        bodyModel: "model.DataAsset",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new data asset tag.
   * @param CreateDataAssetTagRequest
   * @return CreateDataAssetTagResponse
   * @throws OciError when an error occurs
   */
  public async createDataAssetTag(
    createDataAssetTagRequest: requests.CreateDataAssetTagRequest
  ): Promise<responses.CreateDataAssetTagResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#createDataAssetTag.");
    const pathParams = {
      "{catalogId}": createDataAssetTagRequest.catalogId,
      "{dataAssetKey}": createDataAssetTagRequest.dataAssetKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createDataAssetTagRequest.opcRequestId,
      "opc-retry-token": createDataAssetTagRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/tags",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createDataAssetTagRequest.createDataAssetTagDetails,
        "CreateTagDetails",
        models.CreateTagDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createDataAssetTagRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateDataAssetTagResponse>{},
        body: await response.json(),
        bodyKey: "dataAssetTag",
        bodyModel: "model.DataAssetTag",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new data entity.
   * @param CreateEntityRequest
   * @return CreateEntityResponse
   * @throws OciError when an error occurs
   */
  public async createEntity(
    createEntityRequest: requests.CreateEntityRequest
  ): Promise<responses.CreateEntityResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#createEntity.");
    const pathParams = {
      "{catalogId}": createEntityRequest.catalogId,
      "{dataAssetKey}": createEntityRequest.dataAssetKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createEntityRequest.opcRequestId,
      "opc-retry-token": createEntityRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/entities",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createEntityRequest.createEntityDetails,
        "CreateEntityDetails",
        models.CreateEntityDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createEntityRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateEntityResponse>{},
        body: await response.json(),
        bodyKey: "entity",
        bodyModel: "model.Entity",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new entity tag.
   * @param CreateEntityTagRequest
   * @return CreateEntityTagResponse
   * @throws OciError when an error occurs
   */
  public async createEntityTag(
    createEntityTagRequest: requests.CreateEntityTagRequest
  ): Promise<responses.CreateEntityTagResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#createEntityTag.");
    const pathParams = {
      "{catalogId}": createEntityTagRequest.catalogId,
      "{dataAssetKey}": createEntityTagRequest.dataAssetKey,
      "{entityKey}": createEntityTagRequest.entityKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createEntityTagRequest.opcRequestId,
      "opc-retry-token": createEntityTagRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/entities/{entityKey}/tags",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createEntityTagRequest.createEntityTagDetails,
        "CreateTagDetails",
        models.CreateTagDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createEntityTagRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateEntityTagResponse>{},
        body: await response.json(),
        bodyKey: "entityTag",
        bodyModel: "model.EntityTag",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new folder.
   * @param CreateFolderRequest
   * @return CreateFolderResponse
   * @throws OciError when an error occurs
   */
  public async createFolder(
    createFolderRequest: requests.CreateFolderRequest
  ): Promise<responses.CreateFolderResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#createFolder.");
    const pathParams = {
      "{catalogId}": createFolderRequest.catalogId,
      "{dataAssetKey}": createFolderRequest.dataAssetKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createFolderRequest.opcRequestId,
      "opc-retry-token": createFolderRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/folders",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createFolderRequest.createFolderDetails,
        "CreateFolderDetails",
        models.CreateFolderDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createFolderRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateFolderResponse>{},
        body: await response.json(),
        bodyKey: "folder",
        bodyModel: "model.Folder",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new folder tag.
   * @param CreateFolderTagRequest
   * @return CreateFolderTagResponse
   * @throws OciError when an error occurs
   */
  public async createFolderTag(
    createFolderTagRequest: requests.CreateFolderTagRequest
  ): Promise<responses.CreateFolderTagResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#createFolderTag.");
    const pathParams = {
      "{catalogId}": createFolderTagRequest.catalogId,
      "{dataAssetKey}": createFolderTagRequest.dataAssetKey,
      "{folderKey}": createFolderTagRequest.folderKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createFolderTagRequest.opcRequestId,
      "opc-retry-token": createFolderTagRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/folders/{folderKey}/tags",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createFolderTagRequest.createFolderTagDetails,
        "CreateTagDetails",
        models.CreateTagDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createFolderTagRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateFolderTagResponse>{},
        body: await response.json(),
        bodyKey: "folderTag",
        bodyModel: "model.FolderTag",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new glossary.
   * @param CreateGlossaryRequest
   * @return CreateGlossaryResponse
   * @throws OciError when an error occurs
   */
  public async createGlossary(
    createGlossaryRequest: requests.CreateGlossaryRequest
  ): Promise<responses.CreateGlossaryResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#createGlossary.");
    const pathParams = {
      "{catalogId}": createGlossaryRequest.catalogId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createGlossaryRequest.opcRequestId,
      "opc-retry-token": createGlossaryRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/glossaries",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createGlossaryRequest.createGlossaryDetails,
        "CreateGlossaryDetails",
        models.CreateGlossaryDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createGlossaryRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateGlossaryResponse>{},
        body: await response.json(),
        bodyKey: "glossary",
        bodyModel: "model.Glossary",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new job.
   * @param CreateJobRequest
   * @return CreateJobResponse
   * @throws OciError when an error occurs
   */
  public async createJob(
    createJobRequest: requests.CreateJobRequest
  ): Promise<responses.CreateJobResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#createJob.");
    const pathParams = {
      "{catalogId}": createJobRequest.catalogId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createJobRequest.opcRequestId,
      "opc-retry-token": createJobRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/jobs",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createJobRequest.createJobDetails,
        "CreateJobDetails",
        models.CreateJobDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createJobRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateJobResponse>{},
        body: await response.json(),
        bodyKey: "job",
        bodyModel: "model.Job",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new job definition.
   * @param CreateJobDefinitionRequest
   * @return CreateJobDefinitionResponse
   * @throws OciError when an error occurs
   */
  public async createJobDefinition(
    createJobDefinitionRequest: requests.CreateJobDefinitionRequest
  ): Promise<responses.CreateJobDefinitionResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#createJobDefinition.");
    const pathParams = {
      "{catalogId}": createJobDefinitionRequest.catalogId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createJobDefinitionRequest.opcRequestId,
      "opc-retry-token": createJobDefinitionRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/jobDefinitions",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createJobDefinitionRequest.createJobDefinitionDetails,
        "CreateJobDefinitionDetails",
        models.CreateJobDefinitionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createJobDefinitionRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateJobDefinitionResponse>{},
        body: await response.json(),
        bodyKey: "jobDefinition",
        bodyModel: "model.JobDefinition",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new job execution.
   * @param CreateJobExecutionRequest
   * @return CreateJobExecutionResponse
   * @throws OciError when an error occurs
   */
  public async createJobExecution(
    createJobExecutionRequest: requests.CreateJobExecutionRequest
  ): Promise<responses.CreateJobExecutionResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#createJobExecution.");
    const pathParams = {
      "{catalogId}": createJobExecutionRequest.catalogId,
      "{jobKey}": createJobExecutionRequest.jobKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createJobExecutionRequest.opcRequestId,
      "opc-retry-token": createJobExecutionRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/jobs/{jobKey}/executions",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createJobExecutionRequest.createJobExecutionDetails,
        "CreateJobExecutionDetails",
        models.CreateJobExecutionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createJobExecutionRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateJobExecutionResponse>{},
        body: await response.json(),
        bodyKey: "jobExecution",
        bodyModel: "model.JobExecution",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Create a new term within a glossary.
   * @param CreateTermRequest
   * @return CreateTermResponse
   * @throws OciError when an error occurs
   */
  public async createTerm(
    createTermRequest: requests.CreateTermRequest
  ): Promise<responses.CreateTermResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#createTerm.");
    const pathParams = {
      "{catalogId}": createTermRequest.catalogId,
      "{glossaryKey}": createTermRequest.glossaryKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createTermRequest.opcRequestId,
      "opc-retry-token": createTermRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/glossaries/{glossaryKey}/terms",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createTermRequest.createTermDetails,
        "CreateTermDetails",
        models.CreateTermDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createTermRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateTermResponse>{},
        body: await response.json(),
        bodyKey: "term",
        bodyModel: "model.Term",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new term relationship for this term within a glossary.
   * @param CreateTermRelationshipRequest
   * @return CreateTermRelationshipResponse
   * @throws OciError when an error occurs
   */
  public async createTermRelationship(
    createTermRelationshipRequest: requests.CreateTermRelationshipRequest
  ): Promise<responses.CreateTermRelationshipResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataCatalogClient#createTermRelationship.");
    const pathParams = {
      "{catalogId}": createTermRelationshipRequest.catalogId,
      "{glossaryKey}": createTermRelationshipRequest.glossaryKey,
      "{termKey}": createTermRelationshipRequest.termKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createTermRelationshipRequest.opcRequestId,
      "opc-retry-token": createTermRelationshipRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/glossaries/{glossaryKey}/terms/{termKey}/termRelationships",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createTermRelationshipRequest.createTermRelationshipDetails,
        "CreateTermRelationshipDetails",
        models.CreateTermRelationshipDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createTermRelationshipRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateTermRelationshipResponse>{},
        body: await response.json(),
        bodyKey: "termRelationship",
        bodyModel: "model.TermRelationship",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes a specific entity attribute.
   * @param DeleteAttributeRequest
   * @return DeleteAttributeResponse
   * @throws OciError when an error occurs
   */
  public async deleteAttribute(
    deleteAttributeRequest: requests.DeleteAttributeRequest
  ): Promise<responses.DeleteAttributeResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#deleteAttribute.");
    const pathParams = {
      "{catalogId}": deleteAttributeRequest.catalogId,
      "{dataAssetKey}": deleteAttributeRequest.dataAssetKey,
      "{entityKey}": deleteAttributeRequest.entityKey,
      "{attributeKey}": deleteAttributeRequest.attributeKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteAttributeRequest.ifMatch,
      "opc-request-id": deleteAttributeRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/entities/{entityKey}/attributes/{attributeKey}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteAttributeRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteAttributeResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes a specific entity attribute tag.
   * @param DeleteAttributeTagRequest
   * @return DeleteAttributeTagResponse
   * @throws OciError when an error occurs
   */
  public async deleteAttributeTag(
    deleteAttributeTagRequest: requests.DeleteAttributeTagRequest
  ): Promise<responses.DeleteAttributeTagResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#deleteAttributeTag.");
    const pathParams = {
      "{catalogId}": deleteAttributeTagRequest.catalogId,
      "{dataAssetKey}": deleteAttributeTagRequest.dataAssetKey,
      "{entityKey}": deleteAttributeTagRequest.entityKey,
      "{attributeKey}": deleteAttributeTagRequest.attributeKey,
      "{tagKey}": deleteAttributeTagRequest.tagKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteAttributeTagRequest.ifMatch,
      "opc-request-id": deleteAttributeTagRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/entities/{entityKey}/attributes/{attributeKey}/tags/{tagKey}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteAttributeTagRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteAttributeTagResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes a data catalog resource by identifier.
   * @param DeleteCatalogRequest
   * @return DeleteCatalogResponse
   * @throws OciError when an error occurs
   */
  public async deleteCatalog(
    deleteCatalogRequest: requests.DeleteCatalogRequest
  ): Promise<responses.DeleteCatalogResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#deleteCatalog.");
    const pathParams = {
      "{catalogId}": deleteCatalogRequest.catalogId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteCatalogRequest.ifMatch,
      "opc-request-id": deleteCatalogRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteCatalogRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteCatalogResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes a private reverse connection endpoint by identifier.
   * @param DeleteCatalogPrivateEndpointRequest
   * @return DeleteCatalogPrivateEndpointResponse
   * @throws OciError when an error occurs
   */
  public async deleteCatalogPrivateEndpoint(
    deleteCatalogPrivateEndpointRequest: requests.DeleteCatalogPrivateEndpointRequest
  ): Promise<responses.DeleteCatalogPrivateEndpointResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataCatalogClient#deleteCatalogPrivateEndpoint.");
    const pathParams = {
      "{catalogPrivateEndpointId}": deleteCatalogPrivateEndpointRequest.catalogPrivateEndpointId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteCatalogPrivateEndpointRequest.ifMatch,
      "opc-request-id": deleteCatalogPrivateEndpointRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogPrivateEndpoints/{catalogPrivateEndpointId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteCatalogPrivateEndpointRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteCatalogPrivateEndpointResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes a specific connection of a data asset.
   * @param DeleteConnectionRequest
   * @return DeleteConnectionResponse
   * @throws OciError when an error occurs
   */
  public async deleteConnection(
    deleteConnectionRequest: requests.DeleteConnectionRequest
  ): Promise<responses.DeleteConnectionResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#deleteConnection.");
    const pathParams = {
      "{catalogId}": deleteConnectionRequest.catalogId,
      "{dataAssetKey}": deleteConnectionRequest.dataAssetKey,
      "{connectionKey}": deleteConnectionRequest.connectionKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteConnectionRequest.ifMatch,
      "opc-request-id": deleteConnectionRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/connections/{connectionKey}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteConnectionRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteConnectionResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes a specific data asset identified by it's key.
   * @param DeleteDataAssetRequest
   * @return DeleteDataAssetResponse
   * @throws OciError when an error occurs
   */
  public async deleteDataAsset(
    deleteDataAssetRequest: requests.DeleteDataAssetRequest
  ): Promise<responses.DeleteDataAssetResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#deleteDataAsset.");
    const pathParams = {
      "{catalogId}": deleteDataAssetRequest.catalogId,
      "{dataAssetKey}": deleteDataAssetRequest.dataAssetKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteDataAssetRequest.ifMatch,
      "opc-request-id": deleteDataAssetRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteDataAssetRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteDataAssetResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes a specific data asset tag.
   * @param DeleteDataAssetTagRequest
   * @return DeleteDataAssetTagResponse
   * @throws OciError when an error occurs
   */
  public async deleteDataAssetTag(
    deleteDataAssetTagRequest: requests.DeleteDataAssetTagRequest
  ): Promise<responses.DeleteDataAssetTagResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#deleteDataAssetTag.");
    const pathParams = {
      "{catalogId}": deleteDataAssetTagRequest.catalogId,
      "{dataAssetKey}": deleteDataAssetTagRequest.dataAssetKey,
      "{tagKey}": deleteDataAssetTagRequest.tagKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteDataAssetTagRequest.ifMatch,
      "opc-request-id": deleteDataAssetTagRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/tags/{tagKey}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteDataAssetTagRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteDataAssetTagResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes a specific data entity.
   * @param DeleteEntityRequest
   * @return DeleteEntityResponse
   * @throws OciError when an error occurs
   */
  public async deleteEntity(
    deleteEntityRequest: requests.DeleteEntityRequest
  ): Promise<responses.DeleteEntityResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#deleteEntity.");
    const pathParams = {
      "{catalogId}": deleteEntityRequest.catalogId,
      "{dataAssetKey}": deleteEntityRequest.dataAssetKey,
      "{entityKey}": deleteEntityRequest.entityKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteEntityRequest.ifMatch,
      "opc-request-id": deleteEntityRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/entities/{entityKey}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteEntityRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteEntityResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes a specific entity tag.
   * @param DeleteEntityTagRequest
   * @return DeleteEntityTagResponse
   * @throws OciError when an error occurs
   */
  public async deleteEntityTag(
    deleteEntityTagRequest: requests.DeleteEntityTagRequest
  ): Promise<responses.DeleteEntityTagResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#deleteEntityTag.");
    const pathParams = {
      "{catalogId}": deleteEntityTagRequest.catalogId,
      "{dataAssetKey}": deleteEntityTagRequest.dataAssetKey,
      "{entityKey}": deleteEntityTagRequest.entityKey,
      "{tagKey}": deleteEntityTagRequest.tagKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteEntityTagRequest.ifMatch,
      "opc-request-id": deleteEntityTagRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/entities/{entityKey}/tags/{tagKey}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteEntityTagRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteEntityTagResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes a specific folder of a data asset identified by it's key.
   * @param DeleteFolderRequest
   * @return DeleteFolderResponse
   * @throws OciError when an error occurs
   */
  public async deleteFolder(
    deleteFolderRequest: requests.DeleteFolderRequest
  ): Promise<responses.DeleteFolderResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#deleteFolder.");
    const pathParams = {
      "{catalogId}": deleteFolderRequest.catalogId,
      "{dataAssetKey}": deleteFolderRequest.dataAssetKey,
      "{folderKey}": deleteFolderRequest.folderKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteFolderRequest.ifMatch,
      "opc-request-id": deleteFolderRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/folders/{folderKey}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteFolderRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteFolderResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes a specific folder tag.
   * @param DeleteFolderTagRequest
   * @return DeleteFolderTagResponse
   * @throws OciError when an error occurs
   */
  public async deleteFolderTag(
    deleteFolderTagRequest: requests.DeleteFolderTagRequest
  ): Promise<responses.DeleteFolderTagResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#deleteFolderTag.");
    const pathParams = {
      "{catalogId}": deleteFolderTagRequest.catalogId,
      "{dataAssetKey}": deleteFolderTagRequest.dataAssetKey,
      "{folderKey}": deleteFolderTagRequest.folderKey,
      "{tagKey}": deleteFolderTagRequest.tagKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteFolderTagRequest.ifMatch,
      "opc-request-id": deleteFolderTagRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/folders/{folderKey}/tags/{tagKey}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteFolderTagRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteFolderTagResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes a specific glossary identified by it's key.
   * @param DeleteGlossaryRequest
   * @return DeleteGlossaryResponse
   * @throws OciError when an error occurs
   */
  public async deleteGlossary(
    deleteGlossaryRequest: requests.DeleteGlossaryRequest
  ): Promise<responses.DeleteGlossaryResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#deleteGlossary.");
    const pathParams = {
      "{catalogId}": deleteGlossaryRequest.catalogId,
      "{glossaryKey}": deleteGlossaryRequest.glossaryKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteGlossaryRequest.ifMatch,
      "opc-request-id": deleteGlossaryRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/glossaries/{glossaryKey}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteGlossaryRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteGlossaryResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes a specific job identified by it's key.
   * @param DeleteJobRequest
   * @return DeleteJobResponse
   * @throws OciError when an error occurs
   */
  public async deleteJob(
    deleteJobRequest: requests.DeleteJobRequest
  ): Promise<responses.DeleteJobResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#deleteJob.");
    const pathParams = {
      "{catalogId}": deleteJobRequest.catalogId,
      "{jobKey}": deleteJobRequest.jobKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteJobRequest.ifMatch,
      "opc-request-id": deleteJobRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/jobs/{jobKey}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteJobRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteJobResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes a specific job definition identified by it's key.
   * @param DeleteJobDefinitionRequest
   * @return DeleteJobDefinitionResponse
   * @throws OciError when an error occurs
   */
  public async deleteJobDefinition(
    deleteJobDefinitionRequest: requests.DeleteJobDefinitionRequest
  ): Promise<responses.DeleteJobDefinitionResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#deleteJobDefinition.");
    const pathParams = {
      "{catalogId}": deleteJobDefinitionRequest.catalogId,
      "{jobDefinitionKey}": deleteJobDefinitionRequest.jobDefinitionKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteJobDefinitionRequest.ifMatch,
      "opc-request-id": deleteJobDefinitionRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/jobDefinitions/{jobDefinitionKey}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteJobDefinitionRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteJobDefinitionResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes a specific glossary term.
   * @param DeleteTermRequest
   * @return DeleteTermResponse
   * @throws OciError when an error occurs
   */
  public async deleteTerm(
    deleteTermRequest: requests.DeleteTermRequest
  ): Promise<responses.DeleteTermResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#deleteTerm.");
    const pathParams = {
      "{catalogId}": deleteTermRequest.catalogId,
      "{glossaryKey}": deleteTermRequest.glossaryKey,
      "{termKey}": deleteTermRequest.termKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteTermRequest.ifMatch,
      "opc-request-id": deleteTermRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/glossaries/{glossaryKey}/terms/{termKey}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteTermRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteTermResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes a specific glossary term relationship.
   * @param DeleteTermRelationshipRequest
   * @return DeleteTermRelationshipResponse
   * @throws OciError when an error occurs
   */
  public async deleteTermRelationship(
    deleteTermRelationshipRequest: requests.DeleteTermRelationshipRequest
  ): Promise<responses.DeleteTermRelationshipResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataCatalogClient#deleteTermRelationship.");
    const pathParams = {
      "{catalogId}": deleteTermRelationshipRequest.catalogId,
      "{glossaryKey}": deleteTermRelationshipRequest.glossaryKey,
      "{termKey}": deleteTermRelationshipRequest.termKey,
      "{termRelationshipKey}": deleteTermRelationshipRequest.termRelationshipKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteTermRelationshipRequest.ifMatch,
      "opc-request-id": deleteTermRelationshipRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/catalogs/{catalogId}/glossaries/{glossaryKey}/terms/{termKey}/termRelationships/{termRelationshipKey}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteTermRelationshipRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteTermRelationshipResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Detaches a private reverse connection endpoint resource to a data catalog resource. When provided, 'If-Match' is checked against 'ETag' values of the resource.
   * @param DetachCatalogPrivateEndpointRequest
   * @return DetachCatalogPrivateEndpointResponse
   * @throws OciError when an error occurs
   */
  public async detachCatalogPrivateEndpoint(
    detachCatalogPrivateEndpointRequest: requests.DetachCatalogPrivateEndpointRequest
  ): Promise<responses.DetachCatalogPrivateEndpointResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataCatalogClient#detachCatalogPrivateEndpoint.");
    const pathParams = {
      "{catalogId}": detachCatalogPrivateEndpointRequest.catalogId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": detachCatalogPrivateEndpointRequest.ifMatch,
      "opc-request-id": detachCatalogPrivateEndpointRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/actions/detachCatalogPrivateEndpoint",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        detachCatalogPrivateEndpointRequest.detachCatalogPrivateEndpointDetails,
        "DetachCatalogPrivateEndpointDetails",
        models.DetachCatalogPrivateEndpointDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      detachCatalogPrivateEndpointRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DetachCatalogPrivateEndpointResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns the fully expanded tree hierarchy of parent and child terms in this glossary.
   * @param ExpandTreeForGlossaryRequest
   * @return ExpandTreeForGlossaryResponse
   * @throws OciError when an error occurs
   */
  public async expandTreeForGlossary(
    expandTreeForGlossaryRequest: requests.ExpandTreeForGlossaryRequest
  ): Promise<responses.ExpandTreeForGlossaryResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataCatalogClient#expandTreeForGlossary.");
    const pathParams = {
      "{catalogId}": expandTreeForGlossaryRequest.catalogId,
      "{glossaryKey}": expandTreeForGlossaryRequest.glossaryKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": expandTreeForGlossaryRequest.opcRequestId,
      "opc-retry-token": expandTreeForGlossaryRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/glossaries/{glossaryKey}/actions/expandTree",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      expandTreeForGlossaryRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ExpandTreeForGlossaryResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "GlossaryTreeElement[]",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Export the glossary and the terms and return the exported glossary as csv or json.
   * @param ExportGlossaryRequest
   * @return ExportGlossaryResponse
   * @throws OciError when an error occurs
   */
  public async exportGlossary(
    exportGlossaryRequest: requests.ExportGlossaryRequest
  ): Promise<responses.ExportGlossaryResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#exportGlossary.");
    const pathParams = {
      "{catalogId}": exportGlossaryRequest.catalogId,
      "{glossaryKey}": exportGlossaryRequest.glossaryKey
    };

    const queryParams = {
      "isRelationshipExported": exportGlossaryRequest.isRelationshipExported
    };

    let headerParams = {
      "opc-request-id": exportGlossaryRequest.opcRequestId,
      "opc-retry-token": exportGlossaryRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/glossaries/{glossaryKey}/actions/export",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      exportGlossaryRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ExportGlossaryResponse>{},
        body: await response.json(),
        bodyKey: "value",
        bodyModel: "string",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets a specific entity attribute by key.
   * @param GetAttributeRequest
   * @return GetAttributeResponse
   * @throws OciError when an error occurs
   */
  public async getAttribute(
    getAttributeRequest: requests.GetAttributeRequest
  ): Promise<responses.GetAttributeResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#getAttribute.");
    const pathParams = {
      "{catalogId}": getAttributeRequest.catalogId,
      "{dataAssetKey}": getAttributeRequest.dataAssetKey,
      "{entityKey}": getAttributeRequest.entityKey,
      "{attributeKey}": getAttributeRequest.attributeKey
    };

    const queryParams = {
      "fields": getAttributeRequest.fields
    };

    let headerParams = {
      "opc-request-id": getAttributeRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/entities/{entityKey}/attributes/{attributeKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getAttributeRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetAttributeResponse>{},
        body: await response.json(),
        bodyKey: "attribute",
        bodyModel: "model.Attribute",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets a specific entity attribute tag by key.
   * @param GetAttributeTagRequest
   * @return GetAttributeTagResponse
   * @throws OciError when an error occurs
   */
  public async getAttributeTag(
    getAttributeTagRequest: requests.GetAttributeTagRequest
  ): Promise<responses.GetAttributeTagResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#getAttributeTag.");
    const pathParams = {
      "{catalogId}": getAttributeTagRequest.catalogId,
      "{dataAssetKey}": getAttributeTagRequest.dataAssetKey,
      "{entityKey}": getAttributeTagRequest.entityKey,
      "{attributeKey}": getAttributeTagRequest.attributeKey,
      "{tagKey}": getAttributeTagRequest.tagKey
    };

    const queryParams = {
      "fields": getAttributeTagRequest.fields
    };

    let headerParams = {
      "opc-request-id": getAttributeTagRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/entities/{entityKey}/attributes/{attributeKey}/tags/{tagKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getAttributeTagRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetAttributeTagResponse>{},
        body: await response.json(),
        bodyKey: "attributeTag",
        bodyModel: "model.AttributeTag",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets a data catalog by identifier.
   * @param GetCatalogRequest
   * @return GetCatalogResponse
   * @throws OciError when an error occurs
   */
  public async getCatalog(
    getCatalogRequest: requests.GetCatalogRequest
  ): Promise<responses.GetCatalogResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#getCatalog.");
    const pathParams = {
      "{catalogId}": getCatalogRequest.catalogId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getCatalogRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getCatalogRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetCatalogResponse>{},
        body: await response.json(),
        bodyKey: "catalog",
        bodyModel: "model.Catalog",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets a specific private reverse connection by identifier.
   * @param GetCatalogPrivateEndpointRequest
   * @return GetCatalogPrivateEndpointResponse
   * @throws OciError when an error occurs
   */
  public async getCatalogPrivateEndpoint(
    getCatalogPrivateEndpointRequest: requests.GetCatalogPrivateEndpointRequest
  ): Promise<responses.GetCatalogPrivateEndpointResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataCatalogClient#getCatalogPrivateEndpoint.");
    const pathParams = {
      "{catalogPrivateEndpointId}": getCatalogPrivateEndpointRequest.catalogPrivateEndpointId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getCatalogPrivateEndpointRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogPrivateEndpoints/{catalogPrivateEndpointId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getCatalogPrivateEndpointRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetCatalogPrivateEndpointResponse>{},
        body: await response.json(),
        bodyKey: "catalogPrivateEndpoint",
        bodyModel: "model.CatalogPrivateEndpoint",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets a specific data asset connection by key.
   * @param GetConnectionRequest
   * @return GetConnectionResponse
   * @throws OciError when an error occurs
   */
  public async getConnection(
    getConnectionRequest: requests.GetConnectionRequest
  ): Promise<responses.GetConnectionResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#getConnection.");
    const pathParams = {
      "{catalogId}": getConnectionRequest.catalogId,
      "{dataAssetKey}": getConnectionRequest.dataAssetKey,
      "{connectionKey}": getConnectionRequest.connectionKey
    };

    const queryParams = {
      "fields": getConnectionRequest.fields
    };

    let headerParams = {
      "opc-request-id": getConnectionRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/connections/{connectionKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getConnectionRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetConnectionResponse>{},
        body: await response.json(),
        bodyKey: "connection",
        bodyModel: "model.Connection",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets a specific data asset for the given key within a data catalog.
   * @param GetDataAssetRequest
   * @return GetDataAssetResponse
   * @throws OciError when an error occurs
   */
  public async getDataAsset(
    getDataAssetRequest: requests.GetDataAssetRequest
  ): Promise<responses.GetDataAssetResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#getDataAsset.");
    const pathParams = {
      "{catalogId}": getDataAssetRequest.catalogId,
      "{dataAssetKey}": getDataAssetRequest.dataAssetKey
    };

    const queryParams = {
      "fields": getDataAssetRequest.fields
    };

    let headerParams = {
      "opc-request-id": getDataAssetRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getDataAssetRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetDataAssetResponse>{},
        body: await response.json(),
        bodyKey: "dataAsset",
        bodyModel: "model.DataAsset",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets a specific data asset tag by key.
   * @param GetDataAssetTagRequest
   * @return GetDataAssetTagResponse
   * @throws OciError when an error occurs
   */
  public async getDataAssetTag(
    getDataAssetTagRequest: requests.GetDataAssetTagRequest
  ): Promise<responses.GetDataAssetTagResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#getDataAssetTag.");
    const pathParams = {
      "{catalogId}": getDataAssetTagRequest.catalogId,
      "{dataAssetKey}": getDataAssetTagRequest.dataAssetKey,
      "{tagKey}": getDataAssetTagRequest.tagKey
    };

    const queryParams = {
      "fields": getDataAssetTagRequest.fields
    };

    let headerParams = {
      "opc-request-id": getDataAssetTagRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/tags/{tagKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getDataAssetTagRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetDataAssetTagResponse>{},
        body: await response.json(),
        bodyKey: "dataAssetTag",
        bodyModel: "model.DataAssetTag",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets a specific data entity by key for a data asset.
   * @param GetEntityRequest
   * @return GetEntityResponse
   * @throws OciError when an error occurs
   */
  public async getEntity(
    getEntityRequest: requests.GetEntityRequest
  ): Promise<responses.GetEntityResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#getEntity.");
    const pathParams = {
      "{catalogId}": getEntityRequest.catalogId,
      "{dataAssetKey}": getEntityRequest.dataAssetKey,
      "{entityKey}": getEntityRequest.entityKey
    };

    const queryParams = {
      "fields": getEntityRequest.fields
    };

    let headerParams = {
      "opc-request-id": getEntityRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/entities/{entityKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getEntityRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetEntityResponse>{},
        body: await response.json(),
        bodyKey: "entity",
        bodyModel: "model.Entity",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets a specific entity tag by key.
   * @param GetEntityTagRequest
   * @return GetEntityTagResponse
   * @throws OciError when an error occurs
   */
  public async getEntityTag(
    getEntityTagRequest: requests.GetEntityTagRequest
  ): Promise<responses.GetEntityTagResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#getEntityTag.");
    const pathParams = {
      "{catalogId}": getEntityTagRequest.catalogId,
      "{dataAssetKey}": getEntityTagRequest.dataAssetKey,
      "{entityKey}": getEntityTagRequest.entityKey,
      "{tagKey}": getEntityTagRequest.tagKey
    };

    const queryParams = {
      "fields": getEntityTagRequest.fields
    };

    let headerParams = {
      "opc-request-id": getEntityTagRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/entities/{entityKey}/tags/{tagKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getEntityTagRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetEntityTagResponse>{},
        body: await response.json(),
        bodyKey: "entityTag",
        bodyModel: "model.EntityTag",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets a specific data asset folder by key.
   * @param GetFolderRequest
   * @return GetFolderResponse
   * @throws OciError when an error occurs
   */
  public async getFolder(
    getFolderRequest: requests.GetFolderRequest
  ): Promise<responses.GetFolderResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#getFolder.");
    const pathParams = {
      "{catalogId}": getFolderRequest.catalogId,
      "{dataAssetKey}": getFolderRequest.dataAssetKey,
      "{folderKey}": getFolderRequest.folderKey
    };

    const queryParams = {
      "fields": getFolderRequest.fields
    };

    let headerParams = {
      "opc-request-id": getFolderRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/folders/{folderKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getFolderRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetFolderResponse>{},
        body: await response.json(),
        bodyKey: "folder",
        bodyModel: "model.Folder",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets a specific folder tag by key.
   * @param GetFolderTagRequest
   * @return GetFolderTagResponse
   * @throws OciError when an error occurs
   */
  public async getFolderTag(
    getFolderTagRequest: requests.GetFolderTagRequest
  ): Promise<responses.GetFolderTagResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#getFolderTag.");
    const pathParams = {
      "{catalogId}": getFolderTagRequest.catalogId,
      "{dataAssetKey}": getFolderTagRequest.dataAssetKey,
      "{folderKey}": getFolderTagRequest.folderKey,
      "{tagKey}": getFolderTagRequest.tagKey
    };

    const queryParams = {
      "fields": getFolderTagRequest.fields
    };

    let headerParams = {
      "opc-request-id": getFolderTagRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/folders/{folderKey}/tags/{tagKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getFolderTagRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetFolderTagResponse>{},
        body: await response.json(),
        bodyKey: "folderTag",
        bodyModel: "model.FolderTag",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets a specific glossary by key within a data catalog.
   * @param GetGlossaryRequest
   * @return GetGlossaryResponse
   * @throws OciError when an error occurs
   */
  public async getGlossary(
    getGlossaryRequest: requests.GetGlossaryRequest
  ): Promise<responses.GetGlossaryResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#getGlossary.");
    const pathParams = {
      "{catalogId}": getGlossaryRequest.catalogId,
      "{glossaryKey}": getGlossaryRequest.glossaryKey
    };

    const queryParams = {
      "fields": getGlossaryRequest.fields
    };

    let headerParams = {
      "opc-request-id": getGlossaryRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/glossaries/{glossaryKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getGlossaryRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetGlossaryResponse>{},
        body: await response.json(),
        bodyKey: "glossary",
        bodyModel: "model.Glossary",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets a specific job by key within a data catalog.
   * @param GetJobRequest
   * @return GetJobResponse
   * @throws OciError when an error occurs
   */
  public async getJob(getJobRequest: requests.GetJobRequest): Promise<responses.GetJobResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#getJob.");
    const pathParams = {
      "{catalogId}": getJobRequest.catalogId,
      "{jobKey}": getJobRequest.jobKey
    };

    const queryParams = {
      "fields": getJobRequest.fields
    };

    let headerParams = {
      "opc-request-id": getJobRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/jobs/{jobKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getJobRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetJobResponse>{},
        body: await response.json(),
        bodyKey: "job",
        bodyModel: "model.Job",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets a specific job definition by key within a data catalog.
   * @param GetJobDefinitionRequest
   * @return GetJobDefinitionResponse
   * @throws OciError when an error occurs
   */
  public async getJobDefinition(
    getJobDefinitionRequest: requests.GetJobDefinitionRequest
  ): Promise<responses.GetJobDefinitionResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#getJobDefinition.");
    const pathParams = {
      "{catalogId}": getJobDefinitionRequest.catalogId,
      "{jobDefinitionKey}": getJobDefinitionRequest.jobDefinitionKey
    };

    const queryParams = {
      "fields": getJobDefinitionRequest.fields
    };

    let headerParams = {
      "opc-request-id": getJobDefinitionRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/jobDefinitions/{jobDefinitionKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getJobDefinitionRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetJobDefinitionResponse>{},
        body: await response.json(),
        bodyKey: "jobDefinition",
        bodyModel: "model.JobDefinition",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets a specific job execution by key.
   * @param GetJobExecutionRequest
   * @return GetJobExecutionResponse
   * @throws OciError when an error occurs
   */
  public async getJobExecution(
    getJobExecutionRequest: requests.GetJobExecutionRequest
  ): Promise<responses.GetJobExecutionResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#getJobExecution.");
    const pathParams = {
      "{catalogId}": getJobExecutionRequest.catalogId,
      "{jobKey}": getJobExecutionRequest.jobKey,
      "{jobExecutionKey}": getJobExecutionRequest.jobExecutionKey
    };

    const queryParams = {
      "fields": getJobExecutionRequest.fields
    };

    let headerParams = {
      "opc-request-id": getJobExecutionRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/jobs/{jobKey}/executions/{jobExecutionKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getJobExecutionRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetJobExecutionResponse>{},
        body: await response.json(),
        bodyKey: "jobExecution",
        bodyModel: "model.JobExecution",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets a specific job log by key.
   * @param GetJobLogRequest
   * @return GetJobLogResponse
   * @throws OciError when an error occurs
   */
  public async getJobLog(
    getJobLogRequest: requests.GetJobLogRequest
  ): Promise<responses.GetJobLogResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#getJobLog.");
    const pathParams = {
      "{catalogId}": getJobLogRequest.catalogId,
      "{jobKey}": getJobLogRequest.jobKey,
      "{jobExecutionKey}": getJobLogRequest.jobExecutionKey,
      "{jobLogKey}": getJobLogRequest.jobLogKey
    };

    const queryParams = {
      "fields": getJobLogRequest.fields
    };

    let headerParams = {
      "opc-request-id": getJobLogRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/jobs/{jobKey}/executions/{jobExecutionKey}/logs/{jobLogKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getJobLogRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetJobLogResponse>{},
        body: await response.json(),
        bodyKey: "jobLog",
        bodyModel: "model.JobLog",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets a specific job metric by key.
   * @param GetJobMetricsRequest
   * @return GetJobMetricsResponse
   * @throws OciError when an error occurs
   */
  public async getJobMetrics(
    getJobMetricsRequest: requests.GetJobMetricsRequest
  ): Promise<responses.GetJobMetricsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#getJobMetrics.");
    const pathParams = {
      "{catalogId}": getJobMetricsRequest.catalogId,
      "{jobKey}": getJobMetricsRequest.jobKey,
      "{jobExecutionKey}": getJobMetricsRequest.jobExecutionKey,
      "{jobMetricsKey}": getJobMetricsRequest.jobMetricsKey
    };

    const queryParams = {
      "fields": getJobMetricsRequest.fields
    };

    let headerParams = {
      "opc-request-id": getJobMetricsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/catalogs/{catalogId}/jobs/{jobKey}/executions/{jobExecutionKey}/metrics/{jobMetricsKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getJobMetricsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetJobMetricsResponse>{},
        body: await response.json(),
        bodyKey: "jobMetric",
        bodyModel: "model.JobMetric",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets a specific glossary term by key.
   * @param GetTermRequest
   * @return GetTermResponse
   * @throws OciError when an error occurs
   */
  public async getTerm(
    getTermRequest: requests.GetTermRequest
  ): Promise<responses.GetTermResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#getTerm.");
    const pathParams = {
      "{catalogId}": getTermRequest.catalogId,
      "{glossaryKey}": getTermRequest.glossaryKey,
      "{termKey}": getTermRequest.termKey
    };

    const queryParams = {
      "fields": getTermRequest.fields
    };

    let headerParams = {
      "opc-request-id": getTermRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/glossaries/{glossaryKey}/terms/{termKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getTermRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetTermResponse>{},
        body: await response.json(),
        bodyKey: "term",
        bodyModel: "model.Term",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets a specific glossary term relationship by key.
   * @param GetTermRelationshipRequest
   * @return GetTermRelationshipResponse
   * @throws OciError when an error occurs
   */
  public async getTermRelationship(
    getTermRelationshipRequest: requests.GetTermRelationshipRequest
  ): Promise<responses.GetTermRelationshipResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#getTermRelationship.");
    const pathParams = {
      "{catalogId}": getTermRelationshipRequest.catalogId,
      "{glossaryKey}": getTermRelationshipRequest.glossaryKey,
      "{termKey}": getTermRelationshipRequest.termKey,
      "{termRelationshipKey}": getTermRelationshipRequest.termRelationshipKey
    };

    const queryParams = {
      "fields": getTermRelationshipRequest.fields
    };

    let headerParams = {
      "opc-request-id": getTermRelationshipRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/catalogs/{catalogId}/glossaries/{glossaryKey}/terms/{termKey}/termRelationships/{termRelationshipKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getTermRelationshipRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetTermRelationshipResponse>{},
        body: await response.json(),
        bodyKey: "termRelationship",
        bodyModel: "model.TermRelationship",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets a specific type by key within a data catalog.
   * @param GetTypeRequest
   * @return GetTypeResponse
   * @throws OciError when an error occurs
   */
  public async getType(
    getTypeRequest: requests.GetTypeRequest
  ): Promise<responses.GetTypeResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#getType.");
    const pathParams = {
      "{catalogId}": getTypeRequest.catalogId,
      "{typeKey}": getTypeRequest.typeKey
    };

    const queryParams = {
      "fields": getTypeRequest.fields
    };

    let headerParams = {
      "opc-request-id": getTypeRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/types/{typeKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getTypeRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetTypeResponse>{},
        body: await response.json(),
        bodyKey: "type",
        bodyModel: "model.Type",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets the status of the work request with the given OCID.
   * @param GetWorkRequestRequest
   * @return GetWorkRequestResponse
   * @throws OciError when an error occurs
   */
  public async getWorkRequest(
    getWorkRequestRequest: requests.GetWorkRequestRequest
  ): Promise<responses.GetWorkRequestResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#getWorkRequest.");
    const pathParams = {
      "{workRequestId}": getWorkRequestRequest.workRequestId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getWorkRequestRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests/{workRequestId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getWorkRequestRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetWorkRequestResponse>{},
        body: await response.json(),
        bodyKey: "workRequest",
        bodyModel: "model.WorkRequest",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("retry-after"),
            key: "retryAfter",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Import new connection for this data asset.
   * @param ImportConnectionRequest
   * @return ImportConnectionResponse
   * @throws OciError when an error occurs
   */
  public async importConnection(
    importConnectionRequest: requests.ImportConnectionRequest
  ): Promise<responses.ImportConnectionResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#importConnection.");
    const pathParams = {
      "{catalogId}": importConnectionRequest.catalogId,
      "{dataAssetKey}": importConnectionRequest.dataAssetKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": importConnectionRequest.opcRequestId,
      "if-match": importConnectionRequest.ifMatch,
      "opc-retry-token": importConnectionRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/actions/importConnection",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        importConnectionRequest.importConnectionDetails,
        "ImportConnectionDetails",
        models.ImportConnectionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      importConnectionRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ImportConnectionResponse>{},
        body: await response.json(),
        bodyKey: "connection",
        bodyModel: "model.Connection",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Import the glossary and the terms from csv or json files and return the imported glossary resource.
   * @param ImportGlossaryRequest
   * @return ImportGlossaryResponse
   * @throws OciError when an error occurs
   */
  public async importGlossary(
    importGlossaryRequest: requests.ImportGlossaryRequest
  ): Promise<responses.ImportGlossaryResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#importGlossary.");
    const pathParams = {
      "{catalogId}": importGlossaryRequest.catalogId,
      "{glossaryKey}": importGlossaryRequest.glossaryKey
    };

    const queryParams = {
      "isRelationshipImported": importGlossaryRequest.isRelationshipImported
    };

    let headerParams = {
      "opc-request-id": importGlossaryRequest.opcRequestId,
      "opc-retry-token": importGlossaryRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/glossaries/{glossaryKey}/actions/import",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        importGlossaryRequest.importGlossaryDetails,
        "ImportGlossaryDetails",
        models.ImportGlossaryDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      importGlossaryRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ImportGlossaryResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns a list of all tags for an entity attribute.
   * @param ListAttributeTagsRequest
   * @return ListAttributeTagsResponse
   * @throws OciError when an error occurs
   */
  public async listAttributeTags(
    listAttributeTagsRequest: requests.ListAttributeTagsRequest
  ): Promise<responses.ListAttributeTagsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#listAttributeTags.");
    const pathParams = {
      "{catalogId}": listAttributeTagsRequest.catalogId,
      "{dataAssetKey}": listAttributeTagsRequest.dataAssetKey,
      "{entityKey}": listAttributeTagsRequest.entityKey,
      "{attributeKey}": listAttributeTagsRequest.attributeKey
    };

    const queryParams = {
      "name": listAttributeTagsRequest.name,
      "lifecycleState": listAttributeTagsRequest.lifecycleState,
      "termKey": listAttributeTagsRequest.termKey,
      "termPath": listAttributeTagsRequest.termPath,
      "timeCreated": listAttributeTagsRequest.timeCreated,
      "createdById": listAttributeTagsRequest.createdById,
      "fields": listAttributeTagsRequest.fields,
      "sortBy": listAttributeTagsRequest.sortBy,
      "sortOrder": listAttributeTagsRequest.sortOrder,
      "limit": listAttributeTagsRequest.limit,
      "page": listAttributeTagsRequest.page
    };

    let headerParams = {
      "opc-request-id": listAttributeTagsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/entities/{entityKey}/attributes/{attributeKey}/tags",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listAttributeTagsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListAttributeTagsResponse>{},
        body: await response.json(),
        bodyKey: "attributeTagCollection",
        bodyModel: "model.AttributeTagCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns a list of all attributes of an data entity.
   * @param ListAttributesRequest
   * @return ListAttributesResponse
   * @throws OciError when an error occurs
   */
  public async listAttributes(
    listAttributesRequest: requests.ListAttributesRequest
  ): Promise<responses.ListAttributesResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#listAttributes.");
    const pathParams = {
      "{catalogId}": listAttributesRequest.catalogId,
      "{dataAssetKey}": listAttributesRequest.dataAssetKey,
      "{entityKey}": listAttributesRequest.entityKey
    };

    const queryParams = {
      "displayName": listAttributesRequest.displayName,
      "displayNameContains": listAttributesRequest.displayNameContains,
      "lifecycleState": listAttributesRequest.lifecycleState,
      "timeCreated": listAttributesRequest.timeCreated,
      "timeUpdated": listAttributesRequest.timeUpdated,
      "createdById": listAttributesRequest.createdById,
      "updatedById": listAttributesRequest.updatedById,
      "externalKey": listAttributesRequest.externalKey,
      "timeExternal": listAttributesRequest.timeExternal,
      "externalTypeName": listAttributesRequest.externalTypeName,
      "isIncrementalData": listAttributesRequest.isIncrementalData,
      "isNullable": listAttributesRequest.isNullable,
      "length": listAttributesRequest.length,
      "position": listAttributesRequest.position,
      "precision": listAttributesRequest.precision,
      "scale": listAttributesRequest.scale,
      "fields": listAttributesRequest.fields,
      "sortBy": listAttributesRequest.sortBy,
      "sortOrder": listAttributesRequest.sortOrder,
      "limit": listAttributesRequest.limit,
      "page": listAttributesRequest.page
    };

    let headerParams = {
      "opc-request-id": listAttributesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/entities/{entityKey}/attributes",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listAttributesRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListAttributesResponse>{},
        body: await response.json(),
        bodyKey: "attributeCollection",
        bodyModel: "model.AttributeCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns a list of all the catalog private endpoints in the specified compartment.
   *
   * @param ListCatalogPrivateEndpointsRequest
   * @return ListCatalogPrivateEndpointsResponse
   * @throws OciError when an error occurs
   */
  public async listCatalogPrivateEndpoints(
    listCatalogPrivateEndpointsRequest: requests.ListCatalogPrivateEndpointsRequest
  ): Promise<responses.ListCatalogPrivateEndpointsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataCatalogClient#listCatalogPrivateEndpoints.");
    const pathParams = {};

    const queryParams = {
      "compartmentId": listCatalogPrivateEndpointsRequest.compartmentId,
      "displayName": listCatalogPrivateEndpointsRequest.displayName,
      "limit": listCatalogPrivateEndpointsRequest.limit,
      "page": listCatalogPrivateEndpointsRequest.page,
      "lifecycleState": listCatalogPrivateEndpointsRequest.lifecycleState,
      "sortOrder": listCatalogPrivateEndpointsRequest.sortOrder,
      "sortBy": listCatalogPrivateEndpointsRequest.sortBy
    };

    let headerParams = {
      "opc-request-id": listCatalogPrivateEndpointsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogPrivateEndpoints",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listCatalogPrivateEndpointsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListCatalogPrivateEndpointsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "CatalogPrivateEndpointSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.CatalogPrivateEndpointSummary objects
   * contained in responses from the listCatalogPrivateEndpoints operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllCatalogPrivateEndpoints(
    request: requests.ListCatalogPrivateEndpointsRequest
  ): AsyncIterableIterator<models.CatalogPrivateEndpointSummary> {
    return paginateRecords(request, req => this.listCatalogPrivateEndpoints(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listCatalogPrivateEndpoints operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllCatalogPrivateEndpointsResponses(
    request: requests.ListCatalogPrivateEndpointsRequest
  ): AsyncIterableIterator<responses.ListCatalogPrivateEndpointsResponse> {
    return paginateResponses(request, req => this.listCatalogPrivateEndpoints(req));
  }

  /**
   * Returns a list of all the data catalogs in the specified compartment.
   *
   * @param ListCatalogsRequest
   * @return ListCatalogsResponse
   * @throws OciError when an error occurs
   */
  public async listCatalogs(
    listCatalogsRequest: requests.ListCatalogsRequest
  ): Promise<responses.ListCatalogsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#listCatalogs.");
    const pathParams = {};

    const queryParams = {
      "compartmentId": listCatalogsRequest.compartmentId,
      "displayName": listCatalogsRequest.displayName,
      "limit": listCatalogsRequest.limit,
      "page": listCatalogsRequest.page,
      "lifecycleState": listCatalogsRequest.lifecycleState,
      "sortOrder": listCatalogsRequest.sortOrder,
      "sortBy": listCatalogsRequest.sortBy
    };

    let headerParams = {
      "opc-request-id": listCatalogsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listCatalogsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListCatalogsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "CatalogSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.CatalogSummary objects
   * contained in responses from the listCatalogs operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllCatalogs(
    request: requests.ListCatalogsRequest
  ): AsyncIterableIterator<models.CatalogSummary> {
    return paginateRecords(request, req => this.listCatalogs(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listCatalogs operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllCatalogsResponses(
    request: requests.ListCatalogsRequest
  ): AsyncIterableIterator<responses.ListCatalogsResponse> {
    return paginateResponses(request, req => this.listCatalogs(req));
  }

  /**
   * Returns a list of all Connections for a data asset.
   * @param ListConnectionsRequest
   * @return ListConnectionsResponse
   * @throws OciError when an error occurs
   */
  public async listConnections(
    listConnectionsRequest: requests.ListConnectionsRequest
  ): Promise<responses.ListConnectionsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#listConnections.");
    const pathParams = {
      "{catalogId}": listConnectionsRequest.catalogId,
      "{dataAssetKey}": listConnectionsRequest.dataAssetKey
    };

    const queryParams = {
      "displayName": listConnectionsRequest.displayName,
      "displayNameContains": listConnectionsRequest.displayNameContains,
      "lifecycleState": listConnectionsRequest.lifecycleState,
      "timeCreated": listConnectionsRequest.timeCreated,
      "timeUpdated": listConnectionsRequest.timeUpdated,
      "createdById": listConnectionsRequest.createdById,
      "updatedById": listConnectionsRequest.updatedById,
      "externalKey": listConnectionsRequest.externalKey,
      "timeStatusUpdated": listConnectionsRequest.timeStatusUpdated,
      "isDefault": listConnectionsRequest.isDefault,
      "fields": listConnectionsRequest.fields,
      "sortBy": listConnectionsRequest.sortBy,
      "sortOrder": listConnectionsRequest.sortOrder,
      "limit": listConnectionsRequest.limit,
      "page": listConnectionsRequest.page
    };

    let headerParams = {
      "opc-request-id": listConnectionsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/connections",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listConnectionsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListConnectionsResponse>{},
        body: await response.json(),
        bodyKey: "connectionCollection",
        bodyModel: "model.ConnectionCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns a list of all tags for a data asset.
   * @param ListDataAssetTagsRequest
   * @return ListDataAssetTagsResponse
   * @throws OciError when an error occurs
   */
  public async listDataAssetTags(
    listDataAssetTagsRequest: requests.ListDataAssetTagsRequest
  ): Promise<responses.ListDataAssetTagsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#listDataAssetTags.");
    const pathParams = {
      "{catalogId}": listDataAssetTagsRequest.catalogId,
      "{dataAssetKey}": listDataAssetTagsRequest.dataAssetKey
    };

    const queryParams = {
      "name": listDataAssetTagsRequest.name,
      "lifecycleState": listDataAssetTagsRequest.lifecycleState,
      "termKey": listDataAssetTagsRequest.termKey,
      "termPath": listDataAssetTagsRequest.termPath,
      "timeCreated": listDataAssetTagsRequest.timeCreated,
      "createdById": listDataAssetTagsRequest.createdById,
      "fields": listDataAssetTagsRequest.fields,
      "sortBy": listDataAssetTagsRequest.sortBy,
      "sortOrder": listDataAssetTagsRequest.sortOrder,
      "limit": listDataAssetTagsRequest.limit,
      "page": listDataAssetTagsRequest.page
    };

    let headerParams = {
      "opc-request-id": listDataAssetTagsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/tags",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listDataAssetTagsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListDataAssetTagsResponse>{},
        body: await response.json(),
        bodyKey: "dataAssetTagCollection",
        bodyModel: "model.DataAssetTagCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns a list of data assets within a data catalog.
   * @param ListDataAssetsRequest
   * @return ListDataAssetsResponse
   * @throws OciError when an error occurs
   */
  public async listDataAssets(
    listDataAssetsRequest: requests.ListDataAssetsRequest
  ): Promise<responses.ListDataAssetsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#listDataAssets.");
    const pathParams = {
      "{catalogId}": listDataAssetsRequest.catalogId
    };

    const queryParams = {
      "displayName": listDataAssetsRequest.displayName,
      "displayNameContains": listDataAssetsRequest.displayNameContains,
      "lifecycleState": listDataAssetsRequest.lifecycleState,
      "timeCreated": listDataAssetsRequest.timeCreated,
      "timeUpdated": listDataAssetsRequest.timeUpdated,
      "createdById": listDataAssetsRequest.createdById,
      "updatedById": listDataAssetsRequest.updatedById,
      "externalKey": listDataAssetsRequest.externalKey,
      "typeKey": listDataAssetsRequest.typeKey,
      "fields": listDataAssetsRequest.fields,
      "sortBy": listDataAssetsRequest.sortBy,
      "sortOrder": listDataAssetsRequest.sortOrder,
      "limit": listDataAssetsRequest.limit,
      "page": listDataAssetsRequest.page
    };

    let headerParams = {
      "opc-request-id": listDataAssetsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listDataAssetsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListDataAssetsResponse>{},
        body: await response.json(),
        bodyKey: "dataAssetCollection",
        bodyModel: "model.DataAssetCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns a list of all entities of a data asset.
   * @param ListEntitiesRequest
   * @return ListEntitiesResponse
   * @throws OciError when an error occurs
   */
  public async listEntities(
    listEntitiesRequest: requests.ListEntitiesRequest
  ): Promise<responses.ListEntitiesResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#listEntities.");
    const pathParams = {
      "{catalogId}": listEntitiesRequest.catalogId,
      "{dataAssetKey}": listEntitiesRequest.dataAssetKey
    };

    const queryParams = {
      "displayName": listEntitiesRequest.displayName,
      "displayNameContains": listEntitiesRequest.displayNameContains,
      "lifecycleState": listEntitiesRequest.lifecycleState,
      "timeCreated": listEntitiesRequest.timeCreated,
      "timeUpdated": listEntitiesRequest.timeUpdated,
      "createdById": listEntitiesRequest.createdById,
      "updatedById": listEntitiesRequest.updatedById,
      "externalKey": listEntitiesRequest.externalKey,
      "timeExternal": listEntitiesRequest.timeExternal,
      "timeStatusUpdated": listEntitiesRequest.timeStatusUpdated,
      "isLogical": listEntitiesRequest.isLogical,
      "isPartition": listEntitiesRequest.isPartition,
      "folderKey": listEntitiesRequest.folderKey,
      "path": listEntitiesRequest.path,
      "harvestStatus": listEntitiesRequest.harvestStatus,
      "lastJobKey": listEntitiesRequest.lastJobKey,
      "fields": listEntitiesRequest.fields,
      "sortBy": listEntitiesRequest.sortBy,
      "sortOrder": listEntitiesRequest.sortOrder,
      "limit": listEntitiesRequest.limit,
      "page": listEntitiesRequest.page
    };

    let headerParams = {
      "opc-request-id": listEntitiesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/entities",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listEntitiesRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListEntitiesResponse>{},
        body: await response.json(),
        bodyKey: "entityCollection",
        bodyModel: "model.EntityCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns a list of all tags for a data entity.
   * @param ListEntityTagsRequest
   * @return ListEntityTagsResponse
   * @throws OciError when an error occurs
   */
  public async listEntityTags(
    listEntityTagsRequest: requests.ListEntityTagsRequest
  ): Promise<responses.ListEntityTagsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#listEntityTags.");
    const pathParams = {
      "{catalogId}": listEntityTagsRequest.catalogId,
      "{dataAssetKey}": listEntityTagsRequest.dataAssetKey,
      "{entityKey}": listEntityTagsRequest.entityKey
    };

    const queryParams = {
      "name": listEntityTagsRequest.name,
      "lifecycleState": listEntityTagsRequest.lifecycleState,
      "termKey": listEntityTagsRequest.termKey,
      "termPath": listEntityTagsRequest.termPath,
      "timeCreated": listEntityTagsRequest.timeCreated,
      "createdById": listEntityTagsRequest.createdById,
      "fields": listEntityTagsRequest.fields,
      "sortBy": listEntityTagsRequest.sortBy,
      "sortOrder": listEntityTagsRequest.sortOrder,
      "limit": listEntityTagsRequest.limit,
      "page": listEntityTagsRequest.page
    };

    let headerParams = {
      "opc-request-id": listEntityTagsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/entities/{entityKey}/tags",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listEntityTagsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListEntityTagsResponse>{},
        body: await response.json(),
        bodyKey: "entityTagCollection",
        bodyModel: "model.EntityTagCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns a list of all tags for a folder.
   * @param ListFolderTagsRequest
   * @return ListFolderTagsResponse
   * @throws OciError when an error occurs
   */
  public async listFolderTags(
    listFolderTagsRequest: requests.ListFolderTagsRequest
  ): Promise<responses.ListFolderTagsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#listFolderTags.");
    const pathParams = {
      "{catalogId}": listFolderTagsRequest.catalogId,
      "{dataAssetKey}": listFolderTagsRequest.dataAssetKey,
      "{folderKey}": listFolderTagsRequest.folderKey
    };

    const queryParams = {
      "name": listFolderTagsRequest.name,
      "lifecycleState": listFolderTagsRequest.lifecycleState,
      "termKey": listFolderTagsRequest.termKey,
      "termPath": listFolderTagsRequest.termPath,
      "timeCreated": listFolderTagsRequest.timeCreated,
      "createdById": listFolderTagsRequest.createdById,
      "fields": listFolderTagsRequest.fields,
      "sortBy": listFolderTagsRequest.sortBy,
      "sortOrder": listFolderTagsRequest.sortOrder,
      "limit": listFolderTagsRequest.limit,
      "page": listFolderTagsRequest.page
    };

    let headerParams = {
      "opc-request-id": listFolderTagsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/folders/{folderKey}/tags",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listFolderTagsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListFolderTagsResponse>{},
        body: await response.json(),
        bodyKey: "folderTagCollection",
        bodyModel: "model.FolderTagCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns a list of all folders.
   * @param ListFoldersRequest
   * @return ListFoldersResponse
   * @throws OciError when an error occurs
   */
  public async listFolders(
    listFoldersRequest: requests.ListFoldersRequest
  ): Promise<responses.ListFoldersResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#listFolders.");
    const pathParams = {
      "{catalogId}": listFoldersRequest.catalogId,
      "{dataAssetKey}": listFoldersRequest.dataAssetKey
    };

    const queryParams = {
      "displayName": listFoldersRequest.displayName,
      "displayNameContains": listFoldersRequest.displayNameContains,
      "lifecycleState": listFoldersRequest.lifecycleState,
      "parentFolderKey": listFoldersRequest.parentFolderKey,
      "path": listFoldersRequest.path,
      "externalKey": listFoldersRequest.externalKey,
      "timeCreated": listFoldersRequest.timeCreated,
      "timeUpdated": listFoldersRequest.timeUpdated,
      "createdById": listFoldersRequest.createdById,
      "updatedById": listFoldersRequest.updatedById,
      "harvestStatus": listFoldersRequest.harvestStatus,
      "lastJobKey": listFoldersRequest.lastJobKey,
      "fields": listFoldersRequest.fields,
      "sortBy": listFoldersRequest.sortBy,
      "sortOrder": listFoldersRequest.sortOrder,
      "limit": listFoldersRequest.limit,
      "page": listFoldersRequest.page
    };

    let headerParams = {
      "opc-request-id": listFoldersRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/folders",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listFoldersRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListFoldersResponse>{},
        body: await response.json(),
        bodyKey: "folderCollection",
        bodyModel: "model.FolderCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns a list of all glossaries within a data catalog.
   * @param ListGlossariesRequest
   * @return ListGlossariesResponse
   * @throws OciError when an error occurs
   */
  public async listGlossaries(
    listGlossariesRequest: requests.ListGlossariesRequest
  ): Promise<responses.ListGlossariesResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#listGlossaries.");
    const pathParams = {
      "{catalogId}": listGlossariesRequest.catalogId
    };

    const queryParams = {
      "displayName": listGlossariesRequest.displayName,
      "displayNameContains": listGlossariesRequest.displayNameContains,
      "lifecycleState": listGlossariesRequest.lifecycleState,
      "timeCreated": listGlossariesRequest.timeCreated,
      "timeUpdated": listGlossariesRequest.timeUpdated,
      "createdById": listGlossariesRequest.createdById,
      "updatedById": listGlossariesRequest.updatedById,
      "fields": listGlossariesRequest.fields,
      "sortBy": listGlossariesRequest.sortBy,
      "sortOrder": listGlossariesRequest.sortOrder,
      "limit": listGlossariesRequest.limit,
      "page": listGlossariesRequest.page
    };

    let headerParams = {
      "opc-request-id": listGlossariesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/glossaries",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listGlossariesRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListGlossariesResponse>{},
        body: await response.json(),
        bodyKey: "glossaryCollection",
        bodyModel: "model.GlossaryCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns a list of job definitions within a data catalog.
   * @param ListJobDefinitionsRequest
   * @return ListJobDefinitionsResponse
   * @throws OciError when an error occurs
   */
  public async listJobDefinitions(
    listJobDefinitionsRequest: requests.ListJobDefinitionsRequest
  ): Promise<responses.ListJobDefinitionsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#listJobDefinitions.");
    const pathParams = {
      "{catalogId}": listJobDefinitionsRequest.catalogId
    };

    const queryParams = {
      "displayName": listJobDefinitionsRequest.displayName,
      "displayNameContains": listJobDefinitionsRequest.displayNameContains,
      "jobExecutionState": listJobDefinitionsRequest.jobExecutionState,
      "lifecycleState": listJobDefinitionsRequest.lifecycleState,
      "jobType": listJobDefinitionsRequest.jobType,
      "isIncremental": listJobDefinitionsRequest.isIncremental,
      "dataAssetKey": listJobDefinitionsRequest.dataAssetKey,
      "connectionKey": listJobDefinitionsRequest.connectionKey,
      "timeCreated": listJobDefinitionsRequest.timeCreated,
      "timeUpdated": listJobDefinitionsRequest.timeUpdated,
      "createdById": listJobDefinitionsRequest.createdById,
      "updatedById": listJobDefinitionsRequest.updatedById,
      "sampleDataSizeInMBs": listJobDefinitionsRequest.sampleDataSizeInMBs,
      "fields": listJobDefinitionsRequest.fields,
      "sortBy": listJobDefinitionsRequest.sortBy,
      "sortOrder": listJobDefinitionsRequest.sortOrder,
      "limit": listJobDefinitionsRequest.limit,
      "page": listJobDefinitionsRequest.page
    };

    let headerParams = {
      "opc-request-id": listJobDefinitionsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/jobDefinitions",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listJobDefinitionsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListJobDefinitionsResponse>{},
        body: await response.json(),
        bodyKey: "jobDefinitionCollection",
        bodyModel: "model.JobDefinitionCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns a list of job executions for a job.
   * @param ListJobExecutionsRequest
   * @return ListJobExecutionsResponse
   * @throws OciError when an error occurs
   */
  public async listJobExecutions(
    listJobExecutionsRequest: requests.ListJobExecutionsRequest
  ): Promise<responses.ListJobExecutionsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#listJobExecutions.");
    const pathParams = {
      "{catalogId}": listJobExecutionsRequest.catalogId,
      "{jobKey}": listJobExecutionsRequest.jobKey
    };

    const queryParams = {
      "lifecycleState": listJobExecutionsRequest.lifecycleState,
      "timeCreated": listJobExecutionsRequest.timeCreated,
      "timeUpdated": listJobExecutionsRequest.timeUpdated,
      "createdById": listJobExecutionsRequest.createdById,
      "updatedById": listJobExecutionsRequest.updatedById,
      "jobType": listJobExecutionsRequest.jobType,
      "subType": listJobExecutionsRequest.subType,
      "parentKey": listJobExecutionsRequest.parentKey,
      "timeStart": listJobExecutionsRequest.timeStart,
      "timeEnd": listJobExecutionsRequest.timeEnd,
      "errorCode": listJobExecutionsRequest.errorCode,
      "errorMessage": listJobExecutionsRequest.errorMessage,
      "processKey": listJobExecutionsRequest.processKey,
      "externalUrl": listJobExecutionsRequest.externalUrl,
      "eventKey": listJobExecutionsRequest.eventKey,
      "dataEntityKey": listJobExecutionsRequest.dataEntityKey,
      "fields": listJobExecutionsRequest.fields,
      "sortBy": listJobExecutionsRequest.sortBy,
      "sortOrder": listJobExecutionsRequest.sortOrder,
      "limit": listJobExecutionsRequest.limit,
      "page": listJobExecutionsRequest.page
    };

    let headerParams = {
      "opc-request-id": listJobExecutionsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/jobs/{jobKey}/executions",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listJobExecutionsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListJobExecutionsResponse>{},
        body: await response.json(),
        bodyKey: "jobExecutionCollection",
        bodyModel: "model.JobExecutionCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns a list of job logs.
   * @param ListJobLogsRequest
   * @return ListJobLogsResponse
   * @throws OciError when an error occurs
   */
  public async listJobLogs(
    listJobLogsRequest: requests.ListJobLogsRequest
  ): Promise<responses.ListJobLogsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#listJobLogs.");
    const pathParams = {
      "{catalogId}": listJobLogsRequest.catalogId,
      "{jobKey}": listJobLogsRequest.jobKey,
      "{jobExecutionKey}": listJobLogsRequest.jobExecutionKey
    };

    const queryParams = {
      "lifecycleState": listJobLogsRequest.lifecycleState,
      "severity": listJobLogsRequest.severity,
      "timeCreated": listJobLogsRequest.timeCreated,
      "timeUpdated": listJobLogsRequest.timeUpdated,
      "createdById": listJobLogsRequest.createdById,
      "updatedById": listJobLogsRequest.updatedById,
      "fields": listJobLogsRequest.fields,
      "sortBy": listJobLogsRequest.sortBy,
      "sortOrder": listJobLogsRequest.sortOrder,
      "limit": listJobLogsRequest.limit,
      "page": listJobLogsRequest.page
    };

    let headerParams = {
      "opc-request-id": listJobLogsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/jobs/{jobKey}/executions/{jobExecutionKey}/logs",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listJobLogsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListJobLogsResponse>{},
        body: await response.json(),
        bodyKey: "jobLogCollection",
        bodyModel: "model.JobLogCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns a list of job metrics.
   * @param ListJobMetricsRequest
   * @return ListJobMetricsResponse
   * @throws OciError when an error occurs
   */
  public async listJobMetrics(
    listJobMetricsRequest: requests.ListJobMetricsRequest
  ): Promise<responses.ListJobMetricsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#listJobMetrics.");
    const pathParams = {
      "{catalogId}": listJobMetricsRequest.catalogId,
      "{jobKey}": listJobMetricsRequest.jobKey,
      "{jobExecutionKey}": listJobMetricsRequest.jobExecutionKey
    };

    const queryParams = {
      "displayName": listJobMetricsRequest.displayName,
      "displayNameContains": listJobMetricsRequest.displayNameContains,
      "category": listJobMetricsRequest.category,
      "subCategory": listJobMetricsRequest.subCategory,
      "unit": listJobMetricsRequest.unit,
      "value": listJobMetricsRequest.value,
      "batchKey": listJobMetricsRequest.batchKey,
      "timeCreated": listJobMetricsRequest.timeCreated,
      "timeUpdated": listJobMetricsRequest.timeUpdated,
      "timeInserted": listJobMetricsRequest.timeInserted,
      "createdById": listJobMetricsRequest.createdById,
      "updatedById": listJobMetricsRequest.updatedById,
      "fields": listJobMetricsRequest.fields,
      "sortBy": listJobMetricsRequest.sortBy,
      "sortOrder": listJobMetricsRequest.sortOrder,
      "limit": listJobMetricsRequest.limit,
      "page": listJobMetricsRequest.page
    };

    let headerParams = {
      "opc-request-id": listJobMetricsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/jobs/{jobKey}/executions/{jobExecutionKey}/metrics",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listJobMetricsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListJobMetricsResponse>{},
        body: await response.json(),
        bodyKey: "jobMetricCollection",
        bodyModel: "model.JobMetricCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns a list of jobs within a data catalog.
   * @param ListJobsRequest
   * @return ListJobsResponse
   * @throws OciError when an error occurs
   */
  public async listJobs(
    listJobsRequest: requests.ListJobsRequest
  ): Promise<responses.ListJobsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#listJobs.");
    const pathParams = {
      "{catalogId}": listJobsRequest.catalogId
    };

    const queryParams = {
      "displayName": listJobsRequest.displayName,
      "displayNameContains": listJobsRequest.displayNameContains,
      "lifecycleState": listJobsRequest.lifecycleState,
      "timeCreated": listJobsRequest.timeCreated,
      "timeUpdated": listJobsRequest.timeUpdated,
      "createdById": listJobsRequest.createdById,
      "updatedById": listJobsRequest.updatedById,
      "jobType": listJobsRequest.jobType,
      "jobDefinitionKey": listJobsRequest.jobDefinitionKey,
      "scheduleCronExpression": listJobsRequest.scheduleCronExpression,
      "timeScheduleBegin": listJobsRequest.timeScheduleBegin,
      "timeScheduleEnd": listJobsRequest.timeScheduleEnd,
      "scheduleType": listJobsRequest.scheduleType,
      "connectionKey": listJobsRequest.connectionKey,
      "fields": listJobsRequest.fields,
      "executionCount": listJobsRequest.executionCount,
      "timeOfLatestExecution": listJobsRequest.timeOfLatestExecution,
      "sortBy": listJobsRequest.sortBy,
      "sortOrder": listJobsRequest.sortOrder,
      "limit": listJobsRequest.limit,
      "page": listJobsRequest.page
    };

    let headerParams = {
      "opc-request-id": listJobsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/jobs",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listJobsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListJobsResponse>{},
        body: await response.json(),
        bodyKey: "jobCollection",
        bodyModel: "model.JobCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns a list of all user created tags in the system.
   * @param ListTagsRequest
   * @return ListTagsResponse
   * @throws OciError when an error occurs
   */
  public async listTags(
    listTagsRequest: requests.ListTagsRequest
  ): Promise<responses.ListTagsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#listTags.");
    const pathParams = {
      "{catalogId}": listTagsRequest.catalogId
    };

    const queryParams = {
      "displayName": listTagsRequest.displayName,
      "displayNameContains": listTagsRequest.displayNameContains,
      "lifecycleState": listTagsRequest.lifecycleState,
      "fields": listTagsRequest.fields,
      "sortBy": listTagsRequest.sortBy,
      "sortOrder": listTagsRequest.sortOrder,
      "limit": listTagsRequest.limit,
      "page": listTagsRequest.page
    };

    let headerParams = {
      "opc-request-id": listTagsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/tags",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listTagsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListTagsResponse>{},
        body: await response.json(),
        bodyKey: "termCollection",
        bodyModel: "model.TermCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns a list of all term relationships within a glossary.
   * @param ListTermRelationshipsRequest
   * @return ListTermRelationshipsResponse
   * @throws OciError when an error occurs
   */
  public async listTermRelationships(
    listTermRelationshipsRequest: requests.ListTermRelationshipsRequest
  ): Promise<responses.ListTermRelationshipsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataCatalogClient#listTermRelationships.");
    const pathParams = {
      "{catalogId}": listTermRelationshipsRequest.catalogId,
      "{glossaryKey}": listTermRelationshipsRequest.glossaryKey,
      "{termKey}": listTermRelationshipsRequest.termKey
    };

    const queryParams = {
      "displayName": listTermRelationshipsRequest.displayName,
      "displayNameContains": listTermRelationshipsRequest.displayNameContains,
      "lifecycleState": listTermRelationshipsRequest.lifecycleState,
      "fields": listTermRelationshipsRequest.fields,
      "sortBy": listTermRelationshipsRequest.sortBy,
      "sortOrder": listTermRelationshipsRequest.sortOrder,
      "limit": listTermRelationshipsRequest.limit,
      "page": listTermRelationshipsRequest.page
    };

    let headerParams = {
      "opc-request-id": listTermRelationshipsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/glossaries/{glossaryKey}/terms/{termKey}/termRelationships",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listTermRelationshipsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListTermRelationshipsResponse>{},
        body: await response.json(),
        bodyKey: "termRelationshipCollection",
        bodyModel: "model.TermRelationshipCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns a list of all terms within a glossary.
   * @param ListTermsRequest
   * @return ListTermsResponse
   * @throws OciError when an error occurs
   */
  public async listTerms(
    listTermsRequest: requests.ListTermsRequest
  ): Promise<responses.ListTermsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#listTerms.");
    const pathParams = {
      "{catalogId}": listTermsRequest.catalogId,
      "{glossaryKey}": listTermsRequest.glossaryKey
    };

    const queryParams = {
      "displayName": listTermsRequest.displayName,
      "displayNameContains": listTermsRequest.displayNameContains,
      "lifecycleState": listTermsRequest.lifecycleState,
      "parentTermKey": listTermsRequest.parentTermKey,
      "isAllowedToHaveChildTerms": listTermsRequest.isAllowedToHaveChildTerms,
      "workflowStatus": listTermsRequest.workflowStatus,
      "path": listTermsRequest.path,
      "fields": listTermsRequest.fields,
      "sortBy": listTermsRequest.sortBy,
      "sortOrder": listTermsRequest.sortOrder,
      "limit": listTermsRequest.limit,
      "page": listTermsRequest.page
    };

    let headerParams = {
      "opc-request-id": listTermsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/glossaries/{glossaryKey}/terms",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listTermsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListTermsResponse>{},
        body: await response.json(),
        bodyKey: "termCollection",
        bodyModel: "model.TermCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns a list of all types within a data catalog.
   * @param ListTypesRequest
   * @return ListTypesResponse
   * @throws OciError when an error occurs
   */
  public async listTypes(
    listTypesRequest: requests.ListTypesRequest
  ): Promise<responses.ListTypesResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#listTypes.");
    const pathParams = {
      "{catalogId}": listTypesRequest.catalogId
    };

    const queryParams = {
      "name": listTypesRequest.name,
      "lifecycleState": listTypesRequest.lifecycleState,
      "isInternal": listTypesRequest.isInternal,
      "isTag": listTypesRequest.isTag,
      "isApproved": listTypesRequest.isApproved,
      "externalTypeName": listTypesRequest.externalTypeName,
      "typeCategory": listTypesRequest.typeCategory,
      "fields": listTypesRequest.fields,
      "sortBy": listTypesRequest.sortBy,
      "sortOrder": listTypesRequest.sortOrder,
      "limit": listTypesRequest.limit,
      "page": listTypesRequest.page
    };

    let headerParams = {
      "opc-request-id": listTypesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/types",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listTypesRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListTypesResponse>{},
        body: await response.json(),
        bodyKey: "typeCollection",
        bodyModel: "model.TypeCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns a (paginated) list of errors for a given work request.
   *
   * @param ListWorkRequestErrorsRequest
   * @return ListWorkRequestErrorsResponse
   * @throws OciError when an error occurs
   */
  public async listWorkRequestErrors(
    listWorkRequestErrorsRequest: requests.ListWorkRequestErrorsRequest
  ): Promise<responses.ListWorkRequestErrorsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataCatalogClient#listWorkRequestErrors.");
    const pathParams = {
      "{workRequestId}": listWorkRequestErrorsRequest.workRequestId
    };

    const queryParams = {
      "page": listWorkRequestErrorsRequest.page,
      "limit": listWorkRequestErrorsRequest.limit,
      "sortBy": listWorkRequestErrorsRequest.sortBy,
      "sortOrder": listWorkRequestErrorsRequest.sortOrder
    };

    let headerParams = {
      "opc-request-id": listWorkRequestErrorsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests/{workRequestId}/errors",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listWorkRequestErrorsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListWorkRequestErrorsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "WorkRequestError[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.WorkRequestError objects
   * contained in responses from the listWorkRequestErrors operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequestErrors(
    request: requests.ListWorkRequestErrorsRequest
  ): AsyncIterableIterator<models.WorkRequestError> {
    return paginateRecords(request, req => this.listWorkRequestErrors(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listWorkRequestErrors operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequestErrorsResponses(
    request: requests.ListWorkRequestErrorsRequest
  ): AsyncIterableIterator<responses.ListWorkRequestErrorsResponse> {
    return paginateResponses(request, req => this.listWorkRequestErrors(req));
  }

  /**
   * Returns a (paginated) list of logs for a given work request.
   *
   * @param ListWorkRequestLogsRequest
   * @return ListWorkRequestLogsResponse
   * @throws OciError when an error occurs
   */
  public async listWorkRequestLogs(
    listWorkRequestLogsRequest: requests.ListWorkRequestLogsRequest
  ): Promise<responses.ListWorkRequestLogsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#listWorkRequestLogs.");
    const pathParams = {
      "{workRequestId}": listWorkRequestLogsRequest.workRequestId
    };

    const queryParams = {
      "page": listWorkRequestLogsRequest.page,
      "limit": listWorkRequestLogsRequest.limit,
      "sortBy": listWorkRequestLogsRequest.sortBy,
      "sortOrder": listWorkRequestLogsRequest.sortOrder
    };

    let headerParams = {
      "opc-request-id": listWorkRequestLogsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests/{workRequestId}/logs",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listWorkRequestLogsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListWorkRequestLogsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "WorkRequestLog[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.WorkRequestLog objects
   * contained in responses from the listWorkRequestLogs operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequestLogs(
    request: requests.ListWorkRequestLogsRequest
  ): AsyncIterableIterator<models.WorkRequestLog> {
    return paginateRecords(request, req => this.listWorkRequestLogs(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listWorkRequestLogs operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequestLogsResponses(
    request: requests.ListWorkRequestLogsRequest
  ): AsyncIterableIterator<responses.ListWorkRequestLogsResponse> {
    return paginateResponses(request, req => this.listWorkRequestLogs(req));
  }

  /**
   * Lists the work requests in a compartment.
   *
   * @param ListWorkRequestsRequest
   * @return ListWorkRequestsResponse
   * @throws OciError when an error occurs
   */
  public async listWorkRequests(
    listWorkRequestsRequest: requests.ListWorkRequestsRequest
  ): Promise<responses.ListWorkRequestsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#listWorkRequests.");
    const pathParams = {};

    const queryParams = {
      "compartmentId": listWorkRequestsRequest.compartmentId,
      "page": listWorkRequestsRequest.page,
      "limit": listWorkRequestsRequest.limit
    };

    let headerParams = {
      "opc-request-id": listWorkRequestsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listWorkRequestsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListWorkRequestsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "WorkRequest[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.WorkRequest objects
   * contained in responses from the listWorkRequests operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequests(
    request: requests.ListWorkRequestsRequest
  ): AsyncIterableIterator<models.WorkRequest> {
    return paginateRecords(request, req => this.listWorkRequests(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listWorkRequests operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequestsResponses(
    request: requests.ListWorkRequestsRequest
  ): AsyncIterableIterator<responses.ListWorkRequestsResponse> {
    return paginateResponses(request, req => this.listWorkRequests(req));
  }

  /**
   * Returns stats on objects by type in the repository.
   * @param ObjectStatsRequest
   * @return ObjectStatsResponse
   * @throws OciError when an error occurs
   */
  public async objectStats(
    objectStatsRequest: requests.ObjectStatsRequest
  ): Promise<responses.ObjectStatsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#objectStats.");
    const pathParams = {
      "{catalogId}": objectStatsRequest.catalogId
    };

    const queryParams = {
      "sortBy": objectStatsRequest.sortBy,
      "sortOrder": objectStatsRequest.sortOrder,
      "limit": objectStatsRequest.limit,
      "page": objectStatsRequest.page
    };

    let headerParams = {
      "opc-request-id": objectStatsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/actions/objectStats",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      objectStatsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ObjectStatsResponse>{},
        body: await response.json(),
        bodyKey: "value",
        bodyModel: "string",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Parse data asset references through connections from this data asset.
   * @param ParseConnectionRequest
   * @return ParseConnectionResponse
   * @throws OciError when an error occurs
   */
  public async parseConnection(
    parseConnectionRequest: requests.ParseConnectionRequest
  ): Promise<responses.ParseConnectionResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#parseConnection.");
    const pathParams = {
      "{catalogId}": parseConnectionRequest.catalogId,
      "{dataAssetKey}": parseConnectionRequest.dataAssetKey
    };

    const queryParams = {
      "connectionKey": parseConnectionRequest.connectionKey
    };

    let headerParams = {
      "opc-request-id": parseConnectionRequest.opcRequestId,
      "opc-retry-token": parseConnectionRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/actions/parseConnection",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        parseConnectionRequest.parseConnectionDetails,
        "ParseConnectionDetails",
        models.ParseConnectionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      parseConnectionRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ParseConnectionResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "ConnectionAliasSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns a list of search results within a data catalog.
   * @param SearchCriteriaRequest
   * @return SearchCriteriaResponse
   * @throws OciError when an error occurs
   */
  public async searchCriteria(
    searchCriteriaRequest: requests.SearchCriteriaRequest
  ): Promise<responses.SearchCriteriaResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#searchCriteria.");
    const pathParams = {
      "{catalogId}": searchCriteriaRequest.catalogId
    };

    const queryParams = {
      "displayName": searchCriteriaRequest.displayName,
      "name": searchCriteriaRequest.name,
      "lifecycleState": searchCriteriaRequest.lifecycleState,
      "timeout": searchCriteriaRequest.timeout,
      "sortBy": searchCriteriaRequest.sortBy,
      "sortOrder": searchCriteriaRequest.sortOrder,
      "limit": searchCriteriaRequest.limit,
      "page": searchCriteriaRequest.page
    };

    let headerParams = {
      "opc-request-id": searchCriteriaRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/search",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        searchCriteriaRequest.searchCriteriaDetails,
        "SearchCriteria",
        models.SearchCriteria.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      searchCriteriaRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.SearchCriteriaResponse>{},
        body: await response.json(),
        bodyKey: "searchResultCollection",
        bodyModel: "model.SearchResultCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Test the connection by connecting to the data asset using credentials in the metadata.
   * @param TestConnectionRequest
   * @return TestConnectionResponse
   * @throws OciError when an error occurs
   */
  public async testConnection(
    testConnectionRequest: requests.TestConnectionRequest
  ): Promise<responses.TestConnectionResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#testConnection.");
    const pathParams = {
      "{catalogId}": testConnectionRequest.catalogId,
      "{dataAssetKey}": testConnectionRequest.dataAssetKey,
      "{connectionKey}": testConnectionRequest.connectionKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": testConnectionRequest.opcRequestId,
      "opc-retry-token": testConnectionRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/connections/{connectionKey}/actions/test",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      testConnectionRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.TestConnectionResponse>{},
        body: await response.json(),
        bodyKey: "validateConnectionResult",
        bodyModel: "model.ValidateConnectionResult",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Updates a specific data asset attribute.
   * @param UpdateAttributeRequest
   * @return UpdateAttributeResponse
   * @throws OciError when an error occurs
   */
  public async updateAttribute(
    updateAttributeRequest: requests.UpdateAttributeRequest
  ): Promise<responses.UpdateAttributeResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#updateAttribute.");
    const pathParams = {
      "{catalogId}": updateAttributeRequest.catalogId,
      "{dataAssetKey}": updateAttributeRequest.dataAssetKey,
      "{entityKey}": updateAttributeRequest.entityKey,
      "{attributeKey}": updateAttributeRequest.attributeKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateAttributeRequest.ifMatch,
      "opc-request-id": updateAttributeRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/entities/{entityKey}/attributes/{attributeKey}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateAttributeRequest.updateAttributeDetails,
        "UpdateAttributeDetails",
        models.UpdateAttributeDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateAttributeRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateAttributeResponse>{},
        body: await response.json(),
        bodyKey: "attribute",
        bodyModel: "model.Attribute",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Updates the data catalog.
   * @param UpdateCatalogRequest
   * @return UpdateCatalogResponse
   * @throws OciError when an error occurs
   */
  public async updateCatalog(
    updateCatalogRequest: requests.UpdateCatalogRequest
  ): Promise<responses.UpdateCatalogResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#updateCatalog.");
    const pathParams = {
      "{catalogId}": updateCatalogRequest.catalogId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateCatalogRequest.ifMatch,
      "opc-request-id": updateCatalogRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateCatalogRequest.updateCatalogDetails,
        "UpdateCatalogDetails",
        models.UpdateCatalogDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateCatalogRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateCatalogResponse>{},
        body: await response.json(),
        bodyKey: "catalog",
        bodyModel: "model.Catalog",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Updates the private reverse connection endpoint.
   * @param UpdateCatalogPrivateEndpointRequest
   * @return UpdateCatalogPrivateEndpointResponse
   * @throws OciError when an error occurs
   */
  public async updateCatalogPrivateEndpoint(
    updateCatalogPrivateEndpointRequest: requests.UpdateCatalogPrivateEndpointRequest
  ): Promise<responses.UpdateCatalogPrivateEndpointResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataCatalogClient#updateCatalogPrivateEndpoint.");
    const pathParams = {
      "{catalogPrivateEndpointId}": updateCatalogPrivateEndpointRequest.catalogPrivateEndpointId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateCatalogPrivateEndpointRequest.ifMatch,
      "opc-request-id": updateCatalogPrivateEndpointRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogPrivateEndpoints/{catalogPrivateEndpointId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateCatalogPrivateEndpointRequest.updateCatalogPrivateEndpointDetails,
        "UpdateCatalogPrivateEndpointDetails",
        models.UpdateCatalogPrivateEndpointDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateCatalogPrivateEndpointRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateCatalogPrivateEndpointResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Updates a specific connection of a data asset.
   * @param UpdateConnectionRequest
   * @return UpdateConnectionResponse
   * @throws OciError when an error occurs
   */
  public async updateConnection(
    updateConnectionRequest: requests.UpdateConnectionRequest
  ): Promise<responses.UpdateConnectionResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#updateConnection.");
    const pathParams = {
      "{catalogId}": updateConnectionRequest.catalogId,
      "{dataAssetKey}": updateConnectionRequest.dataAssetKey,
      "{connectionKey}": updateConnectionRequest.connectionKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateConnectionRequest.ifMatch,
      "opc-request-id": updateConnectionRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/connections/{connectionKey}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateConnectionRequest.updateConnectionDetails,
        "UpdateConnectionDetails",
        models.UpdateConnectionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateConnectionRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateConnectionResponse>{},
        body: await response.json(),
        bodyKey: "connection",
        bodyModel: "model.Connection",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Updates a specific data asset identified by the given key.
   * @param UpdateDataAssetRequest
   * @return UpdateDataAssetResponse
   * @throws OciError when an error occurs
   */
  public async updateDataAsset(
    updateDataAssetRequest: requests.UpdateDataAssetRequest
  ): Promise<responses.UpdateDataAssetResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#updateDataAsset.");
    const pathParams = {
      "{catalogId}": updateDataAssetRequest.catalogId,
      "{dataAssetKey}": updateDataAssetRequest.dataAssetKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateDataAssetRequest.ifMatch,
      "opc-request-id": updateDataAssetRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateDataAssetRequest.updateDataAssetDetails,
        "UpdateDataAssetDetails",
        models.UpdateDataAssetDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateDataAssetRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateDataAssetResponse>{},
        body: await response.json(),
        bodyKey: "dataAsset",
        bodyModel: "model.DataAsset",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Updates a specific data entity.
   * @param UpdateEntityRequest
   * @return UpdateEntityResponse
   * @throws OciError when an error occurs
   */
  public async updateEntity(
    updateEntityRequest: requests.UpdateEntityRequest
  ): Promise<responses.UpdateEntityResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#updateEntity.");
    const pathParams = {
      "{catalogId}": updateEntityRequest.catalogId,
      "{dataAssetKey}": updateEntityRequest.dataAssetKey,
      "{entityKey}": updateEntityRequest.entityKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateEntityRequest.ifMatch,
      "opc-request-id": updateEntityRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/entities/{entityKey}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateEntityRequest.updateEntityDetails,
        "UpdateEntityDetails",
        models.UpdateEntityDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateEntityRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateEntityResponse>{},
        body: await response.json(),
        bodyKey: "entity",
        bodyModel: "model.Entity",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Updates a specific folder of a data asset.
   * @param UpdateFolderRequest
   * @return UpdateFolderResponse
   * @throws OciError when an error occurs
   */
  public async updateFolder(
    updateFolderRequest: requests.UpdateFolderRequest
  ): Promise<responses.UpdateFolderResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#updateFolder.");
    const pathParams = {
      "{catalogId}": updateFolderRequest.catalogId,
      "{dataAssetKey}": updateFolderRequest.dataAssetKey,
      "{folderKey}": updateFolderRequest.folderKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateFolderRequest.ifMatch,
      "opc-request-id": updateFolderRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/folders/{folderKey}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateFolderRequest.updateFolderDetails,
        "UpdateFolderDetails",
        models.UpdateFolderDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateFolderRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateFolderResponse>{},
        body: await response.json(),
        bodyKey: "folder",
        bodyModel: "model.Folder",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Updates a specific glossary identified by the given key.
   * @param UpdateGlossaryRequest
   * @return UpdateGlossaryResponse
   * @throws OciError when an error occurs
   */
  public async updateGlossary(
    updateGlossaryRequest: requests.UpdateGlossaryRequest
  ): Promise<responses.UpdateGlossaryResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#updateGlossary.");
    const pathParams = {
      "{catalogId}": updateGlossaryRequest.catalogId,
      "{glossaryKey}": updateGlossaryRequest.glossaryKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateGlossaryRequest.ifMatch,
      "opc-request-id": updateGlossaryRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/glossaries/{glossaryKey}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateGlossaryRequest.updateGlossaryDetails,
        "UpdateGlossaryDetails",
        models.UpdateGlossaryDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateGlossaryRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateGlossaryResponse>{},
        body: await response.json(),
        bodyKey: "glossary",
        bodyModel: "model.Glossary",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Updates a specific job identified by the given key.
   * @param UpdateJobRequest
   * @return UpdateJobResponse
   * @throws OciError when an error occurs
   */
  public async updateJob(
    updateJobRequest: requests.UpdateJobRequest
  ): Promise<responses.UpdateJobResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#updateJob.");
    const pathParams = {
      "{catalogId}": updateJobRequest.catalogId,
      "{jobKey}": updateJobRequest.jobKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateJobRequest.ifMatch,
      "opc-request-id": updateJobRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/jobs/{jobKey}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateJobRequest.updateJobDetails,
        "UpdateJobDetails",
        models.UpdateJobDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateJobRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateJobResponse>{},
        body: await response.json(),
        bodyKey: "job",
        bodyModel: "model.Job",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Update a specific job definition identified by the given key.
   * @param UpdateJobDefinitionRequest
   * @return UpdateJobDefinitionResponse
   * @throws OciError when an error occurs
   */
  public async updateJobDefinition(
    updateJobDefinitionRequest: requests.UpdateJobDefinitionRequest
  ): Promise<responses.UpdateJobDefinitionResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#updateJobDefinition.");
    const pathParams = {
      "{catalogId}": updateJobDefinitionRequest.catalogId,
      "{jobDefinitionKey}": updateJobDefinitionRequest.jobDefinitionKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateJobDefinitionRequest.ifMatch,
      "opc-request-id": updateJobDefinitionRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/jobDefinitions/{jobDefinitionKey}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateJobDefinitionRequest.updateJobDefinitionDetails,
        "UpdateJobDefinitionDetails",
        models.UpdateJobDefinitionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateJobDefinitionRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateJobDefinitionResponse>{},
        body: await response.json(),
        bodyKey: "jobDefinition",
        bodyModel: "model.JobDefinition",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Updates a specific glossary term.
   * @param UpdateTermRequest
   * @return UpdateTermResponse
   * @throws OciError when an error occurs
   */
  public async updateTerm(
    updateTermRequest: requests.UpdateTermRequest
  ): Promise<responses.UpdateTermResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#updateTerm.");
    const pathParams = {
      "{catalogId}": updateTermRequest.catalogId,
      "{glossaryKey}": updateTermRequest.glossaryKey,
      "{termKey}": updateTermRequest.termKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateTermRequest.ifMatch,
      "opc-request-id": updateTermRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/glossaries/{glossaryKey}/terms/{termKey}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateTermRequest.updateTermDetails,
        "UpdateTermDetails",
        models.UpdateTermDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateTermRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateTermResponse>{},
        body: await response.json(),
        bodyKey: "term",
        bodyModel: "model.Term",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Updates a specific glossary term relationship.
   * @param UpdateTermRelationshipRequest
   * @return UpdateTermRelationshipResponse
   * @throws OciError when an error occurs
   */
  public async updateTermRelationship(
    updateTermRelationshipRequest: requests.UpdateTermRelationshipRequest
  ): Promise<responses.UpdateTermRelationshipResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataCatalogClient#updateTermRelationship.");
    const pathParams = {
      "{catalogId}": updateTermRelationshipRequest.catalogId,
      "{glossaryKey}": updateTermRelationshipRequest.glossaryKey,
      "{termKey}": updateTermRelationshipRequest.termKey,
      "{termRelationshipKey}": updateTermRelationshipRequest.termRelationshipKey
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateTermRelationshipRequest.ifMatch,
      "opc-request-id": updateTermRelationshipRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/catalogs/{catalogId}/glossaries/{glossaryKey}/terms/{termKey}/termRelationships/{termRelationshipKey}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateTermRelationshipRequest.updateTermRelationshipDetails,
        "UpdateTermRelationshipDetails",
        models.UpdateTermRelationshipDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateTermRelationshipRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateTermRelationshipResponse>{},
        body: await response.json(),
        bodyKey: "termRelationship",
        bodyModel: "model.TermRelationship",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Upload connection credentails and metadata for this connection.
   * @param UploadCredentialsRequest
   * @return UploadCredentialsResponse
   * @throws OciError when an error occurs
   */
  public async uploadCredentials(
    uploadCredentialsRequest: requests.UploadCredentialsRequest
  ): Promise<responses.UploadCredentialsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#uploadCredentials.");
    const pathParams = {
      "{catalogId}": uploadCredentialsRequest.catalogId,
      "{dataAssetKey}": uploadCredentialsRequest.dataAssetKey,
      "{connectionKey}": uploadCredentialsRequest.connectionKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": uploadCredentialsRequest.opcRequestId,
      "if-match": uploadCredentialsRequest.ifMatch,
      "opc-retry-token": uploadCredentialsRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/connections/{connectionKey}/actions/uploadCredentials",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        uploadCredentialsRequest.uploadCredentialsDetails,
        "UploadCredentialsDetails",
        models.UploadCredentialsDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      uploadCredentialsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UploadCredentialsResponse>{},
        body: await response.json(),
        bodyKey: "connection",
        bodyModel: "model.Connection",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns active users in the system.
   * @param UsersRequest
   * @return UsersResponse
   * @throws OciError when an error occurs
   */
  public async users(usersRequest: requests.UsersRequest): Promise<responses.UsersResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#users.");
    const pathParams = {
      "{catalogId}": usersRequest.catalogId
    };

    const queryParams = {
      "sortBy": usersRequest.sortBy,
      "sortOrder": usersRequest.sortOrder,
      "limit": usersRequest.limit,
      "page": usersRequest.page
    };

    let headerParams = {
      "opc-request-id": usersRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/actions/users",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      usersRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UsersResponse>{},
        body: await response.json(),
        bodyKey: "value",
        bodyModel: "string",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Validate connection by connecting to the data asset using credentials in metadata.
   * @param ValidateConnectionRequest
   * @return ValidateConnectionResponse
   * @throws OciError when an error occurs
   */
  public async validateConnection(
    validateConnectionRequest: requests.ValidateConnectionRequest
  ): Promise<responses.ValidateConnectionResponse> {
    if (this.logger) this.logger.debug("Calling operation DataCatalogClient#validateConnection.");
    const pathParams = {
      "{catalogId}": validateConnectionRequest.catalogId,
      "{dataAssetKey}": validateConnectionRequest.dataAssetKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": validateConnectionRequest.opcRequestId,
      "opc-retry-token": validateConnectionRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/catalogs/{catalogId}/dataAssets/{dataAssetKey}/actions/validateConnection",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        validateConnectionRequest.validateConnectionDetails,
        "ValidateConnectionDetails",
        models.ValidateConnectionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      validateConnectionRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ValidateConnectionResponse>{},
        body: await response.json(),
        bodyKey: "validateConnectionResult",
        bodyModel: "model.ValidateConnectionResult",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }
}
