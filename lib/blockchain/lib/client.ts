/**
 * Blockchain Platform Control Plane API
 * Blockchain Platform Control Plane API
 * OpenAPI spec version: 20191010
 *
 *
 * NOTE: This class is auto generated by OracleSDKGenerator.
 * Do not edit the class manually.
 *
 * Copyright (c) 2020, Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */

import common = require("oci-common");
import * as requests from "./request";
import * as models from "./model";
import * as responses from "./response";
import { BlockchainPlatformWaiter } from "./blockchainplatform-waiter";
import { composeResponse, composeRequest, GenericRetrier } from "oci-common";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum BlockchainPlatformApiKeys {}

export class BlockchainPlatformClient {
  protected static serviceEndpointTemplate = "https://blockchain.{region}.oci.{secondLevelDomain}";
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": BlockchainPlatformWaiter;
  protected "_clientConfiguration": common.ClientConfiguration;

  protected _httpClient: common.HttpClient;

  constructor(params: common.AuthParams) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._httpClient = params.httpClient || new common.FetchHttpClient(requestSigner);

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Get the endpoint that is being used to call (ex, https://www.example.com).
   */
  public get endpoint() {
    return this._endpoint;
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20191010";
    if (this.logger) this.logger.info(`BlockchainPlatformClient endpoint set to ${this._endpoint}`);
  }

  public get logger() {
    return common.LOG.logger;
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      BlockchainPlatformClient.serviceEndpointTemplate,
      region
    );
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      BlockchainPlatformClient.serviceEndpointTemplate,
      regionId
    );
  }

  /**
   * Creates a new BlockchainPlatformWaiter for resources for this service.
   *
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(config?: common.WaiterConfiguration): BlockchainPlatformWaiter {
    this._waiters = new BlockchainPlatformWaiter(this, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): BlockchainPlatformWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Sets the client configuration for the client
   */
  public set clientConfiguration(clientConfiguration: common.ClientConfiguration) {
    this._clientConfiguration = clientConfiguration;
  }

  /**
   * Change Blockchain Platform Compartment
   * @param ChangeBlockchainPlatformCompartmentRequest
   * @return ChangeBlockchainPlatformCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeBlockchainPlatformCompartment(
    changeBlockchainPlatformCompartmentRequest: requests.ChangeBlockchainPlatformCompartmentRequest
  ): Promise<responses.ChangeBlockchainPlatformCompartmentResponse> {
    if (this.logger)
      this.logger.debug(
        "Calling operation BlockchainPlatformClient#changeBlockchainPlatformCompartment."
      );
    const pathParams = {
      "{blockchainPlatformId}": changeBlockchainPlatformCompartmentRequest.blockchainPlatformId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": changeBlockchainPlatformCompartmentRequest.ifMatch,
      "opc-request-id": changeBlockchainPlatformCompartmentRequest.opcRequestId,
      "opc-retry-token": changeBlockchainPlatformCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/blockchainPlatforms/{blockchainPlatformId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeBlockchainPlatformCompartmentRequest.changeBlockchainPlatformCompartmentDetails,
        "ChangeBlockchainPlatformCompartmentDetails",
        models.ChangeBlockchainPlatformCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      changeBlockchainPlatformCompartmentRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeBlockchainPlatformCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new Blockchain Platform.
   *
   * @param CreateBlockchainPlatformRequest
   * @return CreateBlockchainPlatformResponse
   * @throws OciError when an error occurs
   */
  public async createBlockchainPlatform(
    createBlockchainPlatformRequest: requests.CreateBlockchainPlatformRequest
  ): Promise<responses.CreateBlockchainPlatformResponse> {
    if (this.logger)
      this.logger.debug("Calling operation BlockchainPlatformClient#createBlockchainPlatform.");
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createBlockchainPlatformRequest.opcRetryToken,
      "opc-request-id": createBlockchainPlatformRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/blockchainPlatforms",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createBlockchainPlatformRequest.createBlockchainPlatformDetails,
        "CreateBlockchainPlatformDetails",
        models.CreateBlockchainPlatformDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createBlockchainPlatformRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateBlockchainPlatformResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Create Blockchain Platform Osn
   * @param CreateOsnRequest
   * @return CreateOsnResponse
   * @throws OciError when an error occurs
   */
  public async createOsn(
    createOsnRequest: requests.CreateOsnRequest
  ): Promise<responses.CreateOsnResponse> {
    if (this.logger) this.logger.debug("Calling operation BlockchainPlatformClient#createOsn.");
    const pathParams = {
      "{blockchainPlatformId}": createOsnRequest.blockchainPlatformId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": createOsnRequest.ifMatch,
      "opc-request-id": createOsnRequest.opcRequestId,
      "opc-retry-token": createOsnRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/blockchainPlatforms/{blockchainPlatformId}/osns",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createOsnRequest.createOsnDetails,
        "CreateOsnDetails",
        models.CreateOsnDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createOsnRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateOsnResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Create Blockchain Platform Peer
   * @param CreatePeerRequest
   * @return CreatePeerResponse
   * @throws OciError when an error occurs
   */
  public async createPeer(
    createPeerRequest: requests.CreatePeerRequest
  ): Promise<responses.CreatePeerResponse> {
    if (this.logger) this.logger.debug("Calling operation BlockchainPlatformClient#createPeer.");
    const pathParams = {
      "{blockchainPlatformId}": createPeerRequest.blockchainPlatformId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createPeerRequest.opcRequestId,
      "opc-retry-token": createPeerRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/blockchainPlatforms/{blockchainPlatformId}/peers",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createPeerRequest.createPeerDetails,
        "CreatePeerDetails",
        models.CreatePeerDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createPeerRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreatePeerResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Delete a particular of a Blockchain Platform
   * @param DeleteBlockchainPlatformRequest
   * @return DeleteBlockchainPlatformResponse
   * @throws OciError when an error occurs
   */
  public async deleteBlockchainPlatform(
    deleteBlockchainPlatformRequest: requests.DeleteBlockchainPlatformRequest
  ): Promise<responses.DeleteBlockchainPlatformResponse> {
    if (this.logger)
      this.logger.debug("Calling operation BlockchainPlatformClient#deleteBlockchainPlatform.");
    const pathParams = {
      "{blockchainPlatformId}": deleteBlockchainPlatformRequest.blockchainPlatformId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": deleteBlockchainPlatformRequest.opcRequestId,
      "if-match": deleteBlockchainPlatformRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/blockchainPlatforms/{blockchainPlatformId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteBlockchainPlatformRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteBlockchainPlatformResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Delete a particular OSN of a Blockchain Platform
   * @param DeleteOsnRequest
   * @return DeleteOsnResponse
   * @throws OciError when an error occurs
   */
  public async deleteOsn(
    deleteOsnRequest: requests.DeleteOsnRequest
  ): Promise<responses.DeleteOsnResponse> {
    if (this.logger) this.logger.debug("Calling operation BlockchainPlatformClient#deleteOsn.");
    const pathParams = {
      "{blockchainPlatformId}": deleteOsnRequest.blockchainPlatformId,
      "{osnId}": deleteOsnRequest.osnId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": deleteOsnRequest.opcRequestId,
      "if-match": deleteOsnRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/blockchainPlatforms/{blockchainPlatformId}/osns/{osnId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteOsnRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteOsnResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Delete a particular peer of a Blockchain Platform
   * @param DeletePeerRequest
   * @return DeletePeerResponse
   * @throws OciError when an error occurs
   */
  public async deletePeer(
    deletePeerRequest: requests.DeletePeerRequest
  ): Promise<responses.DeletePeerResponse> {
    if (this.logger) this.logger.debug("Calling operation BlockchainPlatformClient#deletePeer.");
    const pathParams = {
      "{blockchainPlatformId}": deletePeerRequest.blockchainPlatformId,
      "{peerId}": deletePeerRequest.peerId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": deletePeerRequest.opcRequestId,
      "if-match": deletePeerRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/blockchainPlatforms/{blockchainPlatformId}/peers/{peerId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deletePeerRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeletePeerResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Attempts to cancel the work request with the given ID.
   * @param DeleteWorkRequestRequest
   * @return DeleteWorkRequestResponse
   * @throws OciError when an error occurs
   */
  public async deleteWorkRequest(
    deleteWorkRequestRequest: requests.DeleteWorkRequestRequest
  ): Promise<responses.DeleteWorkRequestResponse> {
    if (this.logger)
      this.logger.debug("Calling operation BlockchainPlatformClient#deleteWorkRequest.");
    const pathParams = {
      "{workRequestId}": deleteWorkRequestRequest.workRequestId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": deleteWorkRequestRequest.opcRequestId,
      "if-match": deleteWorkRequestRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests/{workRequestId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteWorkRequestRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteWorkRequestResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets information about a Blockchain Platform identified by the specific id
   * @param GetBlockchainPlatformRequest
   * @return GetBlockchainPlatformResponse
   * @throws OciError when an error occurs
   */
  public async getBlockchainPlatform(
    getBlockchainPlatformRequest: requests.GetBlockchainPlatformRequest
  ): Promise<responses.GetBlockchainPlatformResponse> {
    if (this.logger)
      this.logger.debug("Calling operation BlockchainPlatformClient#getBlockchainPlatform.");
    const pathParams = {
      "{blockchainPlatformId}": getBlockchainPlatformRequest.blockchainPlatformId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getBlockchainPlatformRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/blockchainPlatforms/{blockchainPlatformId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getBlockchainPlatformRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetBlockchainPlatformResponse>{},
        body: await response.json(),
        bodyKey: "blockchainPlatform",
        bodyModel: "model.BlockchainPlatform",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets information about an OSN identified by the specific id
   * @param GetOsnRequest
   * @return GetOsnResponse
   * @throws OciError when an error occurs
   */
  public async getOsn(getOsnRequest: requests.GetOsnRequest): Promise<responses.GetOsnResponse> {
    if (this.logger) this.logger.debug("Calling operation BlockchainPlatformClient#getOsn.");
    const pathParams = {
      "{blockchainPlatformId}": getOsnRequest.blockchainPlatformId,
      "{osnId}": getOsnRequest.osnId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getOsnRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/blockchainPlatforms/{blockchainPlatformId}/osns/{osnId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getOsnRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetOsnResponse>{},
        body: await response.json(),
        bodyKey: "osn",
        bodyModel: "model.Osn",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets information about a peer identified by the specific id
   * @param GetPeerRequest
   * @return GetPeerResponse
   * @throws OciError when an error occurs
   */
  public async getPeer(
    getPeerRequest: requests.GetPeerRequest
  ): Promise<responses.GetPeerResponse> {
    if (this.logger) this.logger.debug("Calling operation BlockchainPlatformClient#getPeer.");
    const pathParams = {
      "{blockchainPlatformId}": getPeerRequest.blockchainPlatformId,
      "{peerId}": getPeerRequest.peerId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getPeerRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/blockchainPlatforms/{blockchainPlatformId}/peers/{peerId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getPeerRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetPeerResponse>{},
        body: await response.json(),
        bodyKey: "peer",
        bodyModel: "model.Peer",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets the status of the work request with the given ID.
   * @param GetWorkRequestRequest
   * @return GetWorkRequestResponse
   * @throws OciError when an error occurs
   */
  public async getWorkRequest(
    getWorkRequestRequest: requests.GetWorkRequestRequest
  ): Promise<responses.GetWorkRequestResponse> {
    if (this.logger)
      this.logger.debug("Calling operation BlockchainPlatformClient#getWorkRequest.");
    const pathParams = {
      "{workRequestId}": getWorkRequestRequest.workRequestId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getWorkRequestRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests/{workRequestId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getWorkRequestRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetWorkRequestResponse>{},
        body: await response.json(),
        bodyKey: "workRequest",
        bodyModel: "model.WorkRequest",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("retry-after"),
            key: "retryAfter",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns a list Blockchain Platform Instances in a compartment
   * @param ListBlockchainPlatformsRequest
   * @return ListBlockchainPlatformsResponse
   * @throws OciError when an error occurs
   */
  public async listBlockchainPlatforms(
    listBlockchainPlatformsRequest: requests.ListBlockchainPlatformsRequest
  ): Promise<responses.ListBlockchainPlatformsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation BlockchainPlatformClient#listBlockchainPlatforms.");
    const pathParams = {};

    const queryParams = {
      "compartmentId": listBlockchainPlatformsRequest.compartmentId,
      "displayName": listBlockchainPlatformsRequest.displayName,
      "page": listBlockchainPlatformsRequest.page,
      "limit": listBlockchainPlatformsRequest.limit,
      "sortOrder": listBlockchainPlatformsRequest.sortOrder,
      "sortBy": listBlockchainPlatformsRequest.sortBy,
      "lifecycleState": listBlockchainPlatformsRequest.lifecycleState
    };

    let headerParams = {
      "opc-request-id": listBlockchainPlatformsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/blockchainPlatforms",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listBlockchainPlatformsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListBlockchainPlatformsResponse>{},
        body: await response.json(),
        bodyKey: "blockchainPlatformCollection",
        bodyModel: "model.BlockchainPlatformCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * List Blockchain Platform OSNs
   * @param ListOsnsRequest
   * @return ListOsnsResponse
   * @throws OciError when an error occurs
   */
  public async listOsns(
    listOsnsRequest: requests.ListOsnsRequest
  ): Promise<responses.ListOsnsResponse> {
    if (this.logger) this.logger.debug("Calling operation BlockchainPlatformClient#listOsns.");
    const pathParams = {
      "{blockchainPlatformId}": listOsnsRequest.blockchainPlatformId
    };

    const queryParams = {
      "displayName": listOsnsRequest.displayName,
      "sortOrder": listOsnsRequest.sortOrder,
      "sortBy": listOsnsRequest.sortBy,
      "page": listOsnsRequest.page,
      "limit": listOsnsRequest.limit
    };

    let headerParams = {
      "opc-request-id": listOsnsRequest.opcRequestId,
      "opc-retry-token": listOsnsRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/blockchainPlatforms/{blockchainPlatformId}/osns",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listOsnsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListOsnsResponse>{},
        body: await response.json(),
        bodyKey: "osnCollection",
        bodyModel: "model.OsnCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * List Blockchain Platform Peers
   * @param ListPeersRequest
   * @return ListPeersResponse
   * @throws OciError when an error occurs
   */
  public async listPeers(
    listPeersRequest: requests.ListPeersRequest
  ): Promise<responses.ListPeersResponse> {
    if (this.logger) this.logger.debug("Calling operation BlockchainPlatformClient#listPeers.");
    const pathParams = {
      "{blockchainPlatformId}": listPeersRequest.blockchainPlatformId
    };

    const queryParams = {
      "displayName": listPeersRequest.displayName,
      "sortOrder": listPeersRequest.sortOrder,
      "sortBy": listPeersRequest.sortBy,
      "page": listPeersRequest.page,
      "limit": listPeersRequest.limit
    };

    let headerParams = {
      "opc-request-id": listPeersRequest.opcRequestId,
      "opc-retry-token": listPeersRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/blockchainPlatforms/{blockchainPlatformId}/peers",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listPeersRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListPeersResponse>{},
        body: await response.json(),
        bodyKey: "peerCollection",
        bodyModel: "model.PeerCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Return a (paginated) list of errors for a given work request.
   *
   * @param ListWorkRequestErrorsRequest
   * @return ListWorkRequestErrorsResponse
   * @throws OciError when an error occurs
   */
  public async listWorkRequestErrors(
    listWorkRequestErrorsRequest: requests.ListWorkRequestErrorsRequest
  ): Promise<responses.ListWorkRequestErrorsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation BlockchainPlatformClient#listWorkRequestErrors.");
    const pathParams = {
      "{workRequestId}": listWorkRequestErrorsRequest.workRequestId
    };

    const queryParams = {
      "page": listWorkRequestErrorsRequest.page,
      "limit": listWorkRequestErrorsRequest.limit
    };

    let headerParams = {
      "opc-request-id": listWorkRequestErrorsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests/{workRequestId}/errors",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listWorkRequestErrorsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListWorkRequestErrorsResponse>{},
        body: await response.json(),
        bodyKey: "workRequestErrorCollection",
        bodyModel: "model.WorkRequestErrorCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Return a (paginated) list of logs for a given work request.
   *
   * @param ListWorkRequestLogsRequest
   * @return ListWorkRequestLogsResponse
   * @throws OciError when an error occurs
   */
  public async listWorkRequestLogs(
    listWorkRequestLogsRequest: requests.ListWorkRequestLogsRequest
  ): Promise<responses.ListWorkRequestLogsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation BlockchainPlatformClient#listWorkRequestLogs.");
    const pathParams = {
      "{workRequestId}": listWorkRequestLogsRequest.workRequestId
    };

    const queryParams = {
      "page": listWorkRequestLogsRequest.page,
      "limit": listWorkRequestLogsRequest.limit
    };

    let headerParams = {
      "opc-request-id": listWorkRequestLogsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests/{workRequestId}/logs",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listWorkRequestLogsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListWorkRequestLogsResponse>{},
        body: await response.json(),
        bodyKey: "workRequestLogEntryCollection",
        bodyModel: "model.WorkRequestLogEntryCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Lists the work requests in a compartment.
   *
   * @param ListWorkRequestsRequest
   * @return ListWorkRequestsResponse
   * @throws OciError when an error occurs
   */
  public async listWorkRequests(
    listWorkRequestsRequest: requests.ListWorkRequestsRequest
  ): Promise<responses.ListWorkRequestsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation BlockchainPlatformClient#listWorkRequests.");
    const pathParams = {};

    const queryParams = {
      "compartmentId": listWorkRequestsRequest.compartmentId,
      "blockchainPlatformId": listWorkRequestsRequest.blockchainPlatformId,
      "sortOrder": listWorkRequestsRequest.sortOrder,
      "sortBy": listWorkRequestsRequest.sortBy,
      "page": listWorkRequestsRequest.page,
      "limit": listWorkRequestsRequest.limit
    };

    let headerParams = {
      "opc-request-id": listWorkRequestsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listWorkRequestsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListWorkRequestsResponse>{},
        body: await response.json(),
        bodyKey: "workRequestCollection",
        bodyModel: "model.WorkRequestCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Preview Scale Blockchain Platform
   * @param PreviewScaleBlockchainPlatformRequest
   * @return PreviewScaleBlockchainPlatformResponse
   * @throws OciError when an error occurs
   */
  public async previewScaleBlockchainPlatform(
    previewScaleBlockchainPlatformRequest: requests.PreviewScaleBlockchainPlatformRequest
  ): Promise<responses.PreviewScaleBlockchainPlatformResponse> {
    if (this.logger)
      this.logger.debug(
        "Calling operation BlockchainPlatformClient#previewScaleBlockchainPlatform."
      );
    const pathParams = {
      "{blockchainPlatformId}": previewScaleBlockchainPlatformRequest.blockchainPlatformId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": previewScaleBlockchainPlatformRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/blockchainPlatforms/{blockchainPlatformId}/actions/scale/preview",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        previewScaleBlockchainPlatformRequest.scaleBlockchainPlatformDetails,
        "ScaleBlockchainPlatformDetails",
        models.ScaleBlockchainPlatformDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      previewScaleBlockchainPlatformRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.PreviewScaleBlockchainPlatformResponse>{},
        body: await response.json(),
        bodyKey: "scaledBlockchainPlatformPreview",
        bodyModel: "model.ScaledBlockchainPlatformPreview",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Scale Blockchain Platform
   * @param ScaleBlockchainPlatformRequest
   * @return ScaleBlockchainPlatformResponse
   * @throws OciError when an error occurs
   */
  public async scaleBlockchainPlatform(
    scaleBlockchainPlatformRequest: requests.ScaleBlockchainPlatformRequest
  ): Promise<responses.ScaleBlockchainPlatformResponse> {
    if (this.logger)
      this.logger.debug("Calling operation BlockchainPlatformClient#scaleBlockchainPlatform.");
    const pathParams = {
      "{blockchainPlatformId}": scaleBlockchainPlatformRequest.blockchainPlatformId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": scaleBlockchainPlatformRequest.ifMatch,
      "opc-request-id": scaleBlockchainPlatformRequest.opcRequestId,
      "opc-retry-token": scaleBlockchainPlatformRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/blockchainPlatforms/{blockchainPlatformId}/actions/scale",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        scaleBlockchainPlatformRequest.scaleBlockchainPlatformDetails,
        "ScaleBlockchainPlatformDetails",
        models.ScaleBlockchainPlatformDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      scaleBlockchainPlatformRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ScaleBlockchainPlatformResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Start a Blockchain Platform
   * @param StartBlockchainPlatformRequest
   * @return StartBlockchainPlatformResponse
   * @throws OciError when an error occurs
   */
  public async startBlockchainPlatform(
    startBlockchainPlatformRequest: requests.StartBlockchainPlatformRequest
  ): Promise<responses.StartBlockchainPlatformResponse> {
    if (this.logger)
      this.logger.debug("Calling operation BlockchainPlatformClient#startBlockchainPlatform.");
    const pathParams = {
      "{blockchainPlatformId}": startBlockchainPlatformRequest.blockchainPlatformId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": startBlockchainPlatformRequest.ifMatch,
      "opc-request-id": startBlockchainPlatformRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/blockchainPlatforms/{blockchainPlatformId}/actions/start",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      startBlockchainPlatformRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.StartBlockchainPlatformResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Stop a Blockchain Platform
   * @param StopBlockchainPlatformRequest
   * @return StopBlockchainPlatformResponse
   * @throws OciError when an error occurs
   */
  public async stopBlockchainPlatform(
    stopBlockchainPlatformRequest: requests.StopBlockchainPlatformRequest
  ): Promise<responses.StopBlockchainPlatformResponse> {
    if (this.logger)
      this.logger.debug("Calling operation BlockchainPlatformClient#stopBlockchainPlatform.");
    const pathParams = {
      "{blockchainPlatformId}": stopBlockchainPlatformRequest.blockchainPlatformId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": stopBlockchainPlatformRequest.ifMatch,
      "opc-request-id": stopBlockchainPlatformRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/blockchainPlatforms/{blockchainPlatformId}/actions/stop",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      stopBlockchainPlatformRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.StopBlockchainPlatformResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Update a particular of a Blockchain Platform
   * @param UpdateBlockchainPlatformRequest
   * @return UpdateBlockchainPlatformResponse
   * @throws OciError when an error occurs
   */
  public async updateBlockchainPlatform(
    updateBlockchainPlatformRequest: requests.UpdateBlockchainPlatformRequest
  ): Promise<responses.UpdateBlockchainPlatformResponse> {
    if (this.logger)
      this.logger.debug("Calling operation BlockchainPlatformClient#updateBlockchainPlatform.");
    const pathParams = {
      "{blockchainPlatformId}": updateBlockchainPlatformRequest.blockchainPlatformId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": updateBlockchainPlatformRequest.opcRequestId,
      "if-match": updateBlockchainPlatformRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/blockchainPlatforms/{blockchainPlatformId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateBlockchainPlatformRequest.updateBlockchainPlatformDetails,
        "UpdateBlockchainPlatformDetails",
        models.UpdateBlockchainPlatformDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateBlockchainPlatformRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateBlockchainPlatformResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Update Blockchain Platform OSN
   * @param UpdateOsnRequest
   * @return UpdateOsnResponse
   * @throws OciError when an error occurs
   */
  public async updateOsn(
    updateOsnRequest: requests.UpdateOsnRequest
  ): Promise<responses.UpdateOsnResponse> {
    if (this.logger) this.logger.debug("Calling operation BlockchainPlatformClient#updateOsn.");
    const pathParams = {
      "{blockchainPlatformId}": updateOsnRequest.blockchainPlatformId,
      "{osnId}": updateOsnRequest.osnId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateOsnRequest.ifMatch,
      "opc-request-id": updateOsnRequest.opcRequestId,
      "opc-retry-token": updateOsnRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/blockchainPlatforms/{blockchainPlatformId}/osns/{osnId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateOsnRequest.updateOsnDetails,
        "UpdateOsnDetails",
        models.UpdateOsnDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateOsnRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateOsnResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Update Blockchain Platform Peer
   * @param UpdatePeerRequest
   * @return UpdatePeerResponse
   * @throws OciError when an error occurs
   */
  public async updatePeer(
    updatePeerRequest: requests.UpdatePeerRequest
  ): Promise<responses.UpdatePeerResponse> {
    if (this.logger) this.logger.debug("Calling operation BlockchainPlatformClient#updatePeer.");
    const pathParams = {
      "{blockchainPlatformId}": updatePeerRequest.blockchainPlatformId,
      "{peerId}": updatePeerRequest.peerId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updatePeerRequest.ifMatch,
      "opc-request-id": updatePeerRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/blockchainPlatforms/{blockchainPlatformId}/peers/{peerId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updatePeerRequest.updatePeerDetails,
        "UpdatePeerDetails",
        models.UpdatePeerDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updatePeerRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdatePeerResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }
}
