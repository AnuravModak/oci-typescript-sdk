/**
 * Data Science API
 * Use the Data Science APIs to organize your data science work, access data and computing resources, and build, train, deploy, and manage models on Oracle Cloud.

 * OpenAPI spec version: 20190101
 * 
 *
 * NOTE: This class is auto generated by OracleSDKGenerator.
 * Do not edit the class manually.
 *
 * Copyright (c) 2020, Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */

import common = require("oci-common");
import * as requests from "./request";
import * as models from "./model";
import * as responses from "./response";
import { paginateRecords, paginateResponses } from "oci-common";
import { DataScienceWaiter } from "./datascience-waiter";
import { composeResponse, composeRequest, GenericRetrier } from "oci-common";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum DataScienceApiKeys {}

export class DataScienceClient {
  protected static serviceEndpointTemplate = "https://datascience.{region}.oci.{secondLevelDomain}";
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": DataScienceWaiter;
  protected "_clientConfiguration": common.ClientConfiguration;

  protected _httpClient: common.HttpClient;

  constructor(params: common.AuthParams) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._httpClient = params.httpClient || new common.FetchHttpClient(requestSigner);

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Get the endpoint that is being used to call (ex, https://www.example.com).
   */
  public get endpoint() {
    return this._endpoint;
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20190101";
    if (this.logger) this.logger.info(`DataScienceClient endpoint set to ${this._endpoint}`);
  }

  public get logger() {
    return common.LOG.logger;
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      DataScienceClient.serviceEndpointTemplate,
      region
    );
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      DataScienceClient.serviceEndpointTemplate,
      regionId
    );
  }

  /**
   * Creates a new DataScienceWaiter for resources for this service.
   *
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(config?: common.WaiterConfiguration): DataScienceWaiter {
    this._waiters = new DataScienceWaiter(this, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): DataScienceWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Sets the client configuration for the client
   */
  public set clientConfiguration(clientConfiguration: common.ClientConfiguration) {
    this._clientConfiguration = clientConfiguration;
  }

  /**
   * Activates the model.
   * @param ActivateModelRequest
   * @return ActivateModelResponse
   * @throws OciError when an error occurs
   */
  public async activateModel(
    activateModelRequest: requests.ActivateModelRequest
  ): Promise<responses.ActivateModelResponse> {
    if (this.logger) this.logger.debug("Calling operation DataScienceClient#activateModel.");
    const pathParams = {
      "{modelId}": activateModelRequest.modelId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": activateModelRequest.ifMatch,
      "opc-request-id": activateModelRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/models/{modelId}/actions/activate",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      activateModelRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ActivateModelResponse>{},
        body: await response.json(),
        bodyKey: "model",
        bodyModel: "model.Model",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Activates the notebook session.
   * @param ActivateNotebookSessionRequest
   * @return ActivateNotebookSessionResponse
   * @throws OciError when an error occurs
   */
  public async activateNotebookSession(
    activateNotebookSessionRequest: requests.ActivateNotebookSessionRequest
  ): Promise<responses.ActivateNotebookSessionResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataScienceClient#activateNotebookSession.");
    const pathParams = {
      "{notebookSessionId}": activateNotebookSessionRequest.notebookSessionId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": activateNotebookSessionRequest.ifMatch,
      "opc-request-id": activateNotebookSessionRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/notebookSessions/{notebookSessionId}/actions/activate",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      activateNotebookSessionRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ActivateNotebookSessionResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Cancels a work request that has not started.
   * @param CancelWorkRequestRequest
   * @return CancelWorkRequestResponse
   * @throws OciError when an error occurs
   */
  public async cancelWorkRequest(
    cancelWorkRequestRequest: requests.CancelWorkRequestRequest
  ): Promise<responses.CancelWorkRequestResponse> {
    if (this.logger) this.logger.debug("Calling operation DataScienceClient#cancelWorkRequest.");
    const pathParams = {
      "{workRequestId}": cancelWorkRequestRequest.workRequestId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": cancelWorkRequestRequest.ifMatch,
      "opc-request-id": cancelWorkRequestRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests/{workRequestId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      cancelWorkRequestRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CancelWorkRequestResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Moves a model resource into a different compartment.
   * @param ChangeModelCompartmentRequest
   * @return ChangeModelCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeModelCompartment(
    changeModelCompartmentRequest: requests.ChangeModelCompartmentRequest
  ): Promise<responses.ChangeModelCompartmentResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataScienceClient#changeModelCompartment.");
    const pathParams = {
      "{modelId}": changeModelCompartmentRequest.modelId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": changeModelCompartmentRequest.ifMatch,
      "opc-request-id": changeModelCompartmentRequest.opcRequestId,
      "opc-retry-token": changeModelCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/models/{modelId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeModelCompartmentRequest.changeModelCompartmentDetails,
        "ChangeModelCompartmentDetails",
        models.ChangeModelCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      changeModelCompartmentRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeModelCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Moves a notebook session resource into a different compartment.
   * @param ChangeNotebookSessionCompartmentRequest
   * @return ChangeNotebookSessionCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeNotebookSessionCompartment(
    changeNotebookSessionCompartmentRequest: requests.ChangeNotebookSessionCompartmentRequest
  ): Promise<responses.ChangeNotebookSessionCompartmentResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataScienceClient#changeNotebookSessionCompartment.");
    const pathParams = {
      "{notebookSessionId}": changeNotebookSessionCompartmentRequest.notebookSessionId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": changeNotebookSessionCompartmentRequest.ifMatch,
      "opc-request-id": changeNotebookSessionCompartmentRequest.opcRequestId,
      "opc-retry-token": changeNotebookSessionCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/notebookSessions/{notebookSessionId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeNotebookSessionCompartmentRequest.changeNotebookSessionCompartmentDetails,
        "ChangeNotebookSessionCompartmentDetails",
        models.ChangeNotebookSessionCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      changeNotebookSessionCompartmentRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeNotebookSessionCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Moves a project resource into a different compartment.
   * @param ChangeProjectCompartmentRequest
   * @return ChangeProjectCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeProjectCompartment(
    changeProjectCompartmentRequest: requests.ChangeProjectCompartmentRequest
  ): Promise<responses.ChangeProjectCompartmentResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataScienceClient#changeProjectCompartment.");
    const pathParams = {
      "{projectId}": changeProjectCompartmentRequest.projectId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": changeProjectCompartmentRequest.ifMatch,
      "opc-request-id": changeProjectCompartmentRequest.opcRequestId,
      "opc-retry-token": changeProjectCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/projects/{projectId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeProjectCompartmentRequest.changeProjectCompartmentDetails,
        "ChangeProjectCompartmentDetails",
        models.ChangeProjectCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      changeProjectCompartmentRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeProjectCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new model.
   * @param CreateModelRequest
   * @return CreateModelResponse
   * @throws OciError when an error occurs
   */
  public async createModel(
    createModelRequest: requests.CreateModelRequest
  ): Promise<responses.CreateModelResponse> {
    if (this.logger) this.logger.debug("Calling operation DataScienceClient#createModel.");
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createModelRequest.opcRequestId,
      "opc-retry-token": createModelRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/models",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createModelRequest.createModelDetails,
        "CreateModelDetails",
        models.CreateModelDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createModelRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateModelResponse>{},
        body: await response.json(),
        bodyKey: "model",
        bodyModel: "model.Model",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates model artifact for specified model.
   * @param CreateModelArtifactRequest
   * @return CreateModelArtifactResponse
   * @throws OciError when an error occurs
   */
  public async createModelArtifact(
    createModelArtifactRequest: requests.CreateModelArtifactRequest
  ): Promise<responses.CreateModelArtifactResponse> {
    if (this.logger) this.logger.debug("Calling operation DataScienceClient#createModelArtifact.");
    const pathParams = {
      "{modelId}": createModelArtifactRequest.modelId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createModelArtifactRequest.opcRequestId,
      "opc-retry-token": createModelArtifactRequest.opcRetryToken,
      "content-length": createModelArtifactRequest.contentLength,
      "content-disposition": createModelArtifactRequest.contentDisposition
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/models/{modelId}/artifact",
      method: "POST",
      bodyContent: createModelArtifactRequest.modelArtifact,
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createModelArtifactRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request, true);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateModelArtifactResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates provenance information for the specified model.
   * @param CreateModelProvenanceRequest
   * @return CreateModelProvenanceResponse
   * @throws OciError when an error occurs
   */
  public async createModelProvenance(
    createModelProvenanceRequest: requests.CreateModelProvenanceRequest
  ): Promise<responses.CreateModelProvenanceResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataScienceClient#createModelProvenance.");
    const pathParams = {
      "{modelId}": createModelProvenanceRequest.modelId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createModelProvenanceRequest.opcRequestId,
      "opc-retry-token": createModelProvenanceRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/models/{modelId}/provenance",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createModelProvenanceRequest.createModelProvenanceDetails,
        "CreateModelProvenanceDetails",
        models.CreateModelProvenanceDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createModelProvenanceRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateModelProvenanceResponse>{},
        body: await response.json(),
        bodyKey: "modelProvenance",
        bodyModel: "model.ModelProvenance",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new notebook session.
   * @param CreateNotebookSessionRequest
   * @return CreateNotebookSessionResponse
   * @throws OciError when an error occurs
   */
  public async createNotebookSession(
    createNotebookSessionRequest: requests.CreateNotebookSessionRequest
  ): Promise<responses.CreateNotebookSessionResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataScienceClient#createNotebookSession.");
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createNotebookSessionRequest.opcRequestId,
      "opc-retry-token": createNotebookSessionRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/notebookSessions",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createNotebookSessionRequest.createNotebookSessionDetails,
        "CreateNotebookSessionDetails",
        models.CreateNotebookSessionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createNotebookSessionRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateNotebookSessionResponse>{},
        body: await response.json(),
        bodyKey: "notebookSession",
        bodyModel: "model.NotebookSession",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("location"),
            key: "location",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new project.
   * @param CreateProjectRequest
   * @return CreateProjectResponse
   * @throws OciError when an error occurs
   */
  public async createProject(
    createProjectRequest: requests.CreateProjectRequest
  ): Promise<responses.CreateProjectResponse> {
    if (this.logger) this.logger.debug("Calling operation DataScienceClient#createProject.");
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createProjectRequest.opcRequestId,
      "opc-retry-token": createProjectRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/projects",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createProjectRequest.createProjectDetails,
        "CreateProjectDetails",
        models.CreateProjectDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createProjectRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateProjectResponse>{},
        body: await response.json(),
        bodyKey: "project",
        bodyModel: "model.Project",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deactivates the model.
   * @param DeactivateModelRequest
   * @return DeactivateModelResponse
   * @throws OciError when an error occurs
   */
  public async deactivateModel(
    deactivateModelRequest: requests.DeactivateModelRequest
  ): Promise<responses.DeactivateModelResponse> {
    if (this.logger) this.logger.debug("Calling operation DataScienceClient#deactivateModel.");
    const pathParams = {
      "{modelId}": deactivateModelRequest.modelId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deactivateModelRequest.ifMatch,
      "opc-request-id": deactivateModelRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/models/{modelId}/actions/deactivate",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deactivateModelRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeactivateModelResponse>{},
        body: await response.json(),
        bodyKey: "model",
        bodyModel: "model.Model",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deactivates the notebook session.
   * @param DeactivateNotebookSessionRequest
   * @return DeactivateNotebookSessionResponse
   * @throws OciError when an error occurs
   */
  public async deactivateNotebookSession(
    deactivateNotebookSessionRequest: requests.DeactivateNotebookSessionRequest
  ): Promise<responses.DeactivateNotebookSessionResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataScienceClient#deactivateNotebookSession.");
    const pathParams = {
      "{notebookSessionId}": deactivateNotebookSessionRequest.notebookSessionId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deactivateNotebookSessionRequest.ifMatch,
      "opc-request-id": deactivateNotebookSessionRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/notebookSessions/{notebookSessionId}/actions/deactivate",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deactivateNotebookSessionRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeactivateNotebookSessionResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes the specified model.
   * @param DeleteModelRequest
   * @return DeleteModelResponse
   * @throws OciError when an error occurs
   */
  public async deleteModel(
    deleteModelRequest: requests.DeleteModelRequest
  ): Promise<responses.DeleteModelResponse> {
    if (this.logger) this.logger.debug("Calling operation DataScienceClient#deleteModel.");
    const pathParams = {
      "{modelId}": deleteModelRequest.modelId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteModelRequest.ifMatch,
      "opc-request-id": deleteModelRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/models/{modelId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteModelRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteModelResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes the specified notebook session. Any unsaved work in this notebook session will be lost.
   * @param DeleteNotebookSessionRequest
   * @return DeleteNotebookSessionResponse
   * @throws OciError when an error occurs
   */
  public async deleteNotebookSession(
    deleteNotebookSessionRequest: requests.DeleteNotebookSessionRequest
  ): Promise<responses.DeleteNotebookSessionResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataScienceClient#deleteNotebookSession.");
    const pathParams = {
      "{notebookSessionId}": deleteNotebookSessionRequest.notebookSessionId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteNotebookSessionRequest.ifMatch,
      "opc-request-id": deleteNotebookSessionRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/notebookSessions/{notebookSessionId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteNotebookSessionRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteNotebookSessionResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes the specified project. This operation will fail unless all associated resources (such as notebook sessions or models) are in a DELETED state. You must delete all associated resources before deleting a project.
   * @param DeleteProjectRequest
   * @return DeleteProjectResponse
   * @throws OciError when an error occurs
   */
  public async deleteProject(
    deleteProjectRequest: requests.DeleteProjectRequest
  ): Promise<responses.DeleteProjectResponse> {
    if (this.logger) this.logger.debug("Calling operation DataScienceClient#deleteProject.");
    const pathParams = {
      "{projectId}": deleteProjectRequest.projectId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteProjectRequest.ifMatch,
      "opc-request-id": deleteProjectRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/projects/{projectId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteProjectRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteProjectResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets the specified model's information.
   * @param GetModelRequest
   * @return GetModelResponse
   * @throws OciError when an error occurs
   */
  public async getModel(
    getModelRequest: requests.GetModelRequest
  ): Promise<responses.GetModelResponse> {
    if (this.logger) this.logger.debug("Calling operation DataScienceClient#getModel.");
    const pathParams = {
      "{modelId}": getModelRequest.modelId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getModelRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/models/{modelId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getModelRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetModelResponse>{},
        body: await response.json(),
        bodyKey: "model",
        bodyModel: "model.Model",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Downloads model artifact content for specified model.
   * @param GetModelArtifactContentRequest
   * @return GetModelArtifactContentResponse
   * @throws OciError when an error occurs
   */
  public async getModelArtifactContent(
    getModelArtifactContentRequest: requests.GetModelArtifactContentRequest
  ): Promise<responses.GetModelArtifactContentResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataScienceClient#getModelArtifactContent.");
    const pathParams = {
      "{modelId}": getModelArtifactContentRequest.modelId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getModelArtifactContentRequest.opcRequestId,
      "range": getModelArtifactContentRequest.range
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/models/{modelId}/artifact/content",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getModelArtifactContentRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetModelArtifactContentResponse>{},

        body: response.body!,
        bodyKey: "value",
        bodyModel: "string",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("content-length"),
            key: "contentLength",
            dataType: "number"
          },
          {
            value: response.headers.get("content-disposition"),
            key: "contentDisposition",
            dataType: "string"
          },
          {
            value: response.headers.get("content-md5"),
            key: "contentMd5",
            dataType: "string"
          },
          {
            value: response.headers.get("last-modified"),
            key: "lastModified",
            dataType: "Date"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets provenance information for specified model.
   * @param GetModelProvenanceRequest
   * @return GetModelProvenanceResponse
   * @throws OciError when an error occurs
   */
  public async getModelProvenance(
    getModelProvenanceRequest: requests.GetModelProvenanceRequest
  ): Promise<responses.GetModelProvenanceResponse> {
    if (this.logger) this.logger.debug("Calling operation DataScienceClient#getModelProvenance.");
    const pathParams = {
      "{modelId}": getModelProvenanceRequest.modelId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getModelProvenanceRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/models/{modelId}/provenance",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getModelProvenanceRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetModelProvenanceResponse>{},
        body: await response.json(),
        bodyKey: "modelProvenance",
        bodyModel: "model.ModelProvenance",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets the specified notebook session's information.
   * @param GetNotebookSessionRequest
   * @return GetNotebookSessionResponse
   * @throws OciError when an error occurs
   */
  public async getNotebookSession(
    getNotebookSessionRequest: requests.GetNotebookSessionRequest
  ): Promise<responses.GetNotebookSessionResponse> {
    if (this.logger) this.logger.debug("Calling operation DataScienceClient#getNotebookSession.");
    const pathParams = {
      "{notebookSessionId}": getNotebookSessionRequest.notebookSessionId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getNotebookSessionRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/notebookSessions/{notebookSessionId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getNotebookSessionRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetNotebookSessionResponse>{},
        body: await response.json(),
        bodyKey: "notebookSession",
        bodyModel: "model.NotebookSession",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets the specified project's information.
   * @param GetProjectRequest
   * @return GetProjectResponse
   * @throws OciError when an error occurs
   */
  public async getProject(
    getProjectRequest: requests.GetProjectRequest
  ): Promise<responses.GetProjectResponse> {
    if (this.logger) this.logger.debug("Calling operation DataScienceClient#getProject.");
    const pathParams = {
      "{projectId}": getProjectRequest.projectId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getProjectRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/projects/{projectId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getProjectRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetProjectResponse>{},
        body: await response.json(),
        bodyKey: "project",
        bodyModel: "model.Project",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets the specified work request's information.
   * @param GetWorkRequestRequest
   * @return GetWorkRequestResponse
   * @throws OciError when an error occurs
   */
  public async getWorkRequest(
    getWorkRequestRequest: requests.GetWorkRequestRequest
  ): Promise<responses.GetWorkRequestResponse> {
    if (this.logger) this.logger.debug("Calling operation DataScienceClient#getWorkRequest.");
    const pathParams = {
      "{workRequestId}": getWorkRequestRequest.workRequestId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getWorkRequestRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests/{workRequestId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getWorkRequestRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetWorkRequestResponse>{},
        body: await response.json(),
        bodyKey: "workRequest",
        bodyModel: "model.WorkRequest",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("retry-after"),
            key: "retryAfter",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets model artifact metadata for specified model.
   * @param HeadModelArtifactRequest
   * @return HeadModelArtifactResponse
   * @throws OciError when an error occurs
   */
  public async headModelArtifact(
    headModelArtifactRequest: requests.HeadModelArtifactRequest
  ): Promise<responses.HeadModelArtifactResponse> {
    if (this.logger) this.logger.debug("Calling operation DataScienceClient#headModelArtifact.");
    const pathParams = {
      "{modelId}": headModelArtifactRequest.modelId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": headModelArtifactRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/models/{modelId}/artifact/content",
      method: "HEAD",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      headModelArtifactRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.HeadModelArtifactResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("content-length"),
            key: "contentLength",
            dataType: "number"
          },
          {
            value: response.headers.get("content-disposition"),
            key: "contentDisposition",
            dataType: "string"
          },
          {
            value: response.headers.get("content-md5"),
            key: "contentMd5",
            dataType: "string"
          },
          {
            value: response.headers.get("last-modified"),
            key: "lastModified",
            dataType: "Date"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Lists models in the specified compartment.
   * @param ListModelsRequest
   * @return ListModelsResponse
   * @throws OciError when an error occurs
   */
  public async listModels(
    listModelsRequest: requests.ListModelsRequest
  ): Promise<responses.ListModelsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataScienceClient#listModels.");
    const pathParams = {};

    const queryParams = {
      "compartmentId": listModelsRequest.compartmentId,
      "id": listModelsRequest.id,
      "projectId": listModelsRequest.projectId,
      "displayName": listModelsRequest.displayName,
      "lifecycleState": listModelsRequest.lifecycleState,
      "createdBy": listModelsRequest.createdBy,
      "limit": listModelsRequest.limit,
      "page": listModelsRequest.page,
      "sortOrder": listModelsRequest.sortOrder,
      "sortBy": listModelsRequest.sortBy
    };

    let headerParams = {
      "opc-request-id": listModelsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/models",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listModelsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListModelsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "ModelSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.ModelSummary objects
   * contained in responses from the listModels operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllModels(
    request: requests.ListModelsRequest
  ): AsyncIterableIterator<models.ModelSummary> {
    return paginateRecords(request, req => this.listModels(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listModels operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllModelsResponses(
    request: requests.ListModelsRequest
  ): AsyncIterableIterator<responses.ListModelsResponse> {
    return paginateResponses(request, req => this.listModels(req));
  }

  /**
   * Lists the valid notebook session shapes.
   * @param ListNotebookSessionShapesRequest
   * @return ListNotebookSessionShapesResponse
   * @throws OciError when an error occurs
   */
  public async listNotebookSessionShapes(
    listNotebookSessionShapesRequest: requests.ListNotebookSessionShapesRequest
  ): Promise<responses.ListNotebookSessionShapesResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataScienceClient#listNotebookSessionShapes.");
    const pathParams = {};

    const queryParams = {
      "compartmentId": listNotebookSessionShapesRequest.compartmentId,
      "limit": listNotebookSessionShapesRequest.limit,
      "page": listNotebookSessionShapesRequest.page
    };

    let headerParams = {
      "opc-request-id": listNotebookSessionShapesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/notebookSessionShapes",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listNotebookSessionShapesRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListNotebookSessionShapesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "NotebookSessionShapeSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.NotebookSessionShapeSummary objects
   * contained in responses from the listNotebookSessionShapes operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllNotebookSessionShapes(
    request: requests.ListNotebookSessionShapesRequest
  ): AsyncIterableIterator<models.NotebookSessionShapeSummary> {
    return paginateRecords(request, req => this.listNotebookSessionShapes(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listNotebookSessionShapes operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllNotebookSessionShapesResponses(
    request: requests.ListNotebookSessionShapesRequest
  ): AsyncIterableIterator<responses.ListNotebookSessionShapesResponse> {
    return paginateResponses(request, req => this.listNotebookSessionShapes(req));
  }

  /**
   * Lists notebook sessions in the specified compartment.
   * @param ListNotebookSessionsRequest
   * @return ListNotebookSessionsResponse
   * @throws OciError when an error occurs
   */
  public async listNotebookSessions(
    listNotebookSessionsRequest: requests.ListNotebookSessionsRequest
  ): Promise<responses.ListNotebookSessionsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataScienceClient#listNotebookSessions.");
    const pathParams = {};

    const queryParams = {
      "compartmentId": listNotebookSessionsRequest.compartmentId,
      "id": listNotebookSessionsRequest.id,
      "projectId": listNotebookSessionsRequest.projectId,
      "displayName": listNotebookSessionsRequest.displayName,
      "lifecycleState": listNotebookSessionsRequest.lifecycleState,
      "createdBy": listNotebookSessionsRequest.createdBy,
      "limit": listNotebookSessionsRequest.limit,
      "page": listNotebookSessionsRequest.page,
      "sortOrder": listNotebookSessionsRequest.sortOrder,
      "sortBy": listNotebookSessionsRequest.sortBy
    };

    let headerParams = {
      "opc-request-id": listNotebookSessionsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/notebookSessions",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listNotebookSessionsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListNotebookSessionsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "NotebookSessionSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.NotebookSessionSummary objects
   * contained in responses from the listNotebookSessions operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllNotebookSessions(
    request: requests.ListNotebookSessionsRequest
  ): AsyncIterableIterator<models.NotebookSessionSummary> {
    return paginateRecords(request, req => this.listNotebookSessions(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listNotebookSessions operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllNotebookSessionsResponses(
    request: requests.ListNotebookSessionsRequest
  ): AsyncIterableIterator<responses.ListNotebookSessionsResponse> {
    return paginateResponses(request, req => this.listNotebookSessions(req));
  }

  /**
   * Lists projects in the specified compartment.
   * @param ListProjectsRequest
   * @return ListProjectsResponse
   * @throws OciError when an error occurs
   */
  public async listProjects(
    listProjectsRequest: requests.ListProjectsRequest
  ): Promise<responses.ListProjectsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataScienceClient#listProjects.");
    const pathParams = {};

    const queryParams = {
      "compartmentId": listProjectsRequest.compartmentId,
      "id": listProjectsRequest.id,
      "displayName": listProjectsRequest.displayName,
      "lifecycleState": listProjectsRequest.lifecycleState,
      "createdBy": listProjectsRequest.createdBy,
      "limit": listProjectsRequest.limit,
      "page": listProjectsRequest.page,
      "sortOrder": listProjectsRequest.sortOrder,
      "sortBy": listProjectsRequest.sortBy
    };

    let headerParams = {
      "opc-request-id": listProjectsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/projects",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listProjectsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListProjectsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "ProjectSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.ProjectSummary objects
   * contained in responses from the listProjects operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllProjects(
    request: requests.ListProjectsRequest
  ): AsyncIterableIterator<models.ProjectSummary> {
    return paginateRecords(request, req => this.listProjects(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listProjects operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllProjectsResponses(
    request: requests.ListProjectsRequest
  ): AsyncIterableIterator<responses.ListProjectsResponse> {
    return paginateResponses(request, req => this.listProjects(req));
  }

  /**
   * Lists work request errors for the specified work request.
   * @param ListWorkRequestErrorsRequest
   * @return ListWorkRequestErrorsResponse
   * @throws OciError when an error occurs
   */
  public async listWorkRequestErrors(
    listWorkRequestErrorsRequest: requests.ListWorkRequestErrorsRequest
  ): Promise<responses.ListWorkRequestErrorsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataScienceClient#listWorkRequestErrors.");
    const pathParams = {
      "{workRequestId}": listWorkRequestErrorsRequest.workRequestId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": listWorkRequestErrorsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests/{workRequestId}/errors",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listWorkRequestErrorsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListWorkRequestErrorsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "WorkRequestError[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Lists work request logs for the specified work request.
   * @param ListWorkRequestLogsRequest
   * @return ListWorkRequestLogsResponse
   * @throws OciError when an error occurs
   */
  public async listWorkRequestLogs(
    listWorkRequestLogsRequest: requests.ListWorkRequestLogsRequest
  ): Promise<responses.ListWorkRequestLogsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataScienceClient#listWorkRequestLogs.");
    const pathParams = {
      "{workRequestId}": listWorkRequestLogsRequest.workRequestId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": listWorkRequestLogsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests/{workRequestId}/logs",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listWorkRequestLogsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListWorkRequestLogsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "WorkRequestLogEntry[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Lists work requests in the specified compartment.
   * @param ListWorkRequestsRequest
   * @return ListWorkRequestsResponse
   * @throws OciError when an error occurs
   */
  public async listWorkRequests(
    listWorkRequestsRequest: requests.ListWorkRequestsRequest
  ): Promise<responses.ListWorkRequestsResponse> {
    if (this.logger) this.logger.debug("Calling operation DataScienceClient#listWorkRequests.");
    const pathParams = {};

    const queryParams = {
      "compartmentId": listWorkRequestsRequest.compartmentId,
      "id": listWorkRequestsRequest.id,
      "operationType": listWorkRequestsRequest.operationType,
      "status": listWorkRequestsRequest.status,
      "limit": listWorkRequestsRequest.limit,
      "page": listWorkRequestsRequest.page,
      "sortOrder": listWorkRequestsRequest.sortOrder,
      "sortBy": listWorkRequestsRequest.sortBy
    };

    let headerParams = {
      "opc-request-id": listWorkRequestsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listWorkRequestsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListWorkRequestsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "WorkRequestSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.WorkRequestSummary objects
   * contained in responses from the listWorkRequests operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequests(
    request: requests.ListWorkRequestsRequest
  ): AsyncIterableIterator<models.WorkRequestSummary> {
    return paginateRecords(request, req => this.listWorkRequests(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listWorkRequests operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequestsResponses(
    request: requests.ListWorkRequestsRequest
  ): AsyncIterableIterator<responses.ListWorkRequestsResponse> {
    return paginateResponses(request, req => this.listWorkRequests(req));
  }

  /**
   * Updates the properties of a model. You can update the `displayName`, `description`, `freeformTags`, and `definedTags` properties.
   * @param UpdateModelRequest
   * @return UpdateModelResponse
   * @throws OciError when an error occurs
   */
  public async updateModel(
    updateModelRequest: requests.UpdateModelRequest
  ): Promise<responses.UpdateModelResponse> {
    if (this.logger) this.logger.debug("Calling operation DataScienceClient#updateModel.");
    const pathParams = {
      "{modelId}": updateModelRequest.modelId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateModelRequest.ifMatch,
      "opc-request-id": updateModelRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/models/{modelId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateModelRequest.updateModelDetails,
        "UpdateModelDetails",
        models.UpdateModelDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateModelRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateModelResponse>{},
        body: await response.json(),
        bodyKey: "model",
        bodyModel: "model.Model",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Updates provenance information for the specified model.
   * @param UpdateModelProvenanceRequest
   * @return UpdateModelProvenanceResponse
   * @throws OciError when an error occurs
   */
  public async updateModelProvenance(
    updateModelProvenanceRequest: requests.UpdateModelProvenanceRequest
  ): Promise<responses.UpdateModelProvenanceResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataScienceClient#updateModelProvenance.");
    const pathParams = {
      "{modelId}": updateModelProvenanceRequest.modelId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": updateModelProvenanceRequest.opcRequestId,
      "if-match": updateModelProvenanceRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/models/{modelId}/provenance",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateModelProvenanceRequest.updateModelProvenanceDetails,
        "UpdateModelProvenanceDetails",
        models.UpdateModelProvenanceDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateModelProvenanceRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateModelProvenanceResponse>{},
        body: await response.json(),
        bodyKey: "modelProvenance",
        bodyModel: "model.ModelProvenance",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Updates the properties of a notebook session. You can update the `displayName`, `freeformTags`, and `definedTags` properties.
   * When the notebook session is in the INACTIVE lifecycle state, you can update `notebookSessionConfigurationDetails` and change `shape`, `subnetId`, and `blockStorageSizeInGBs`.
   * Changes to the `notebookSessionConfigurationDetails` will take effect the next time the `ActivateNotebookSession` action is invoked on the notebook session resource.
   *
   * @param UpdateNotebookSessionRequest
   * @return UpdateNotebookSessionResponse
   * @throws OciError when an error occurs
   */
  public async updateNotebookSession(
    updateNotebookSessionRequest: requests.UpdateNotebookSessionRequest
  ): Promise<responses.UpdateNotebookSessionResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DataScienceClient#updateNotebookSession.");
    const pathParams = {
      "{notebookSessionId}": updateNotebookSessionRequest.notebookSessionId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateNotebookSessionRequest.ifMatch,
      "opc-request-id": updateNotebookSessionRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/notebookSessions/{notebookSessionId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateNotebookSessionRequest.updateNotebookSessionDetails,
        "UpdateNotebookSessionDetails",
        models.UpdateNotebookSessionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateNotebookSessionRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateNotebookSessionResponse>{},
        body: await response.json(),
        bodyKey: "notebookSession",
        bodyModel: "model.NotebookSession",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Updates the properties of a project. You can update the `displayName`, `description`, `freeformTags`, and `definedTags` properties.
   * @param UpdateProjectRequest
   * @return UpdateProjectResponse
   * @throws OciError when an error occurs
   */
  public async updateProject(
    updateProjectRequest: requests.UpdateProjectRequest
  ): Promise<responses.UpdateProjectResponse> {
    if (this.logger) this.logger.debug("Calling operation DataScienceClient#updateProject.");
    const pathParams = {
      "{projectId}": updateProjectRequest.projectId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateProjectRequest.ifMatch,
      "opc-request-id": updateProjectRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/projects/{projectId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateProjectRequest.updateProjectDetails,
        "UpdateProjectDetails",
        models.UpdateProjectDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateProjectRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateProjectResponse>{},
        body: await response.json(),
        bodyKey: "project",
        bodyModel: "model.Project",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }
}
