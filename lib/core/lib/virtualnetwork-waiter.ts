/**
 * Core Services API
 * API covering the [Networking](/iaas/Content/Network/Concepts/overview.htm),
[Compute](/iaas/Content/Compute/Concepts/computeoverview.htm), and
[Block Volume](/iaas/Content/Block/Concepts/overview.htm) services. Use this API
to manage resources such as virtual cloud networks (VCNs), compute instances, and
block storage volumes.

 * OpenAPI spec version: 20160918
 * 
 *
 * NOTE: This class is auto generated by OracleSDKGenerator.
 * Do not edit the class manually.
 *
 * Copyright (c) 2020, 2021, Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */

import * as serviceRequests from "./request";
import * as serviceResponses from "./response";
import * as models from "./model";
import { VirtualNetworkClient } from "./client";
import { genericWaiter, genericTerminalConditionWaiter, WaiterConfiguration } from "oci-common";
import { waitForWorkRequest, WorkRequestClient, responses } from "oci-workrequests";

export class VirtualNetworkWaiter {
  public constructor(
    private client: VirtualNetworkClient,
    private workRequestClient: WorkRequestClient,
    private readonly config?: WaiterConfiguration
  ) {}

  /**
   * Waits forAddIpv6VcnCidr
   *
   * @param request the request to send
   * @return response returns AddIpv6VcnCidrResponse, GetWorkRequestResponse tuple
   */
  public async forAddIpv6VcnCidr(
    request: serviceRequests.AddIpv6VcnCidrRequest
  ): Promise<{
    response: serviceResponses.AddIpv6VcnCidrResponse;
    workRequestResponse: responses.GetWorkRequestResponse;
  }> {
    const addIpv6VcnCidrResponse = await this.client.addIpv6VcnCidr(request);
    const getWorkRequestResponse = await waitForWorkRequest(
      this.config,
      this.workRequestClient,
      addIpv6VcnCidrResponse.opcWorkRequestId
    );
    return { response: addIpv6VcnCidrResponse, workRequestResponse: getWorkRequestResponse };
  }

  /**
   * Waits forAddVcnCidr
   *
   * @param request the request to send
   * @return response returns AddVcnCidrResponse, GetWorkRequestResponse tuple
   */
  public async forAddVcnCidr(
    request: serviceRequests.AddVcnCidrRequest
  ): Promise<{
    response: serviceResponses.AddVcnCidrResponse;
    workRequestResponse: responses.GetWorkRequestResponse;
  }> {
    const addVcnCidrResponse = await this.client.addVcnCidr(request);
    const getWorkRequestResponse = await waitForWorkRequest(
      this.config,
      this.workRequestClient,
      addVcnCidrResponse.opcWorkRequestId
    );
    return { response: addVcnCidrResponse, workRequestResponse: getWorkRequestResponse };
  }

  /**
   * Waits forChangeDrgCompartment
   *
   * @param request the request to send
   * @return response returns ChangeDrgCompartmentResponse, GetWorkRequestResponse tuple
   */
  public async forChangeDrgCompartment(
    request: serviceRequests.ChangeDrgCompartmentRequest
  ): Promise<{
    response: serviceResponses.ChangeDrgCompartmentResponse;
    workRequestResponse: responses.GetWorkRequestResponse;
  }> {
    const changeDrgCompartmentResponse = await this.client.changeDrgCompartment(request);
    const getWorkRequestResponse = await waitForWorkRequest(
      this.config,
      this.workRequestClient,
      changeDrgCompartmentResponse.opcWorkRequestId
    );
    return { response: changeDrgCompartmentResponse, workRequestResponse: getWorkRequestResponse };
  }

  /**
   * Waits forChangeSubnetCompartment
   *
   * @param request the request to send
   * @return response returns ChangeSubnetCompartmentResponse, GetWorkRequestResponse tuple
   */
  public async forChangeSubnetCompartment(
    request: serviceRequests.ChangeSubnetCompartmentRequest
  ): Promise<{
    response: serviceResponses.ChangeSubnetCompartmentResponse;
    workRequestResponse: responses.GetWorkRequestResponse;
  }> {
    const changeSubnetCompartmentResponse = await this.client.changeSubnetCompartment(request);
    const getWorkRequestResponse = await waitForWorkRequest(
      this.config,
      this.workRequestClient,
      changeSubnetCompartmentResponse.opcWorkRequestId
    );
    return {
      response: changeSubnetCompartmentResponse,
      workRequestResponse: getWorkRequestResponse
    };
  }

  /**
   * Waits forChangeVcnCompartment
   *
   * @param request the request to send
   * @return response returns ChangeVcnCompartmentResponse, GetWorkRequestResponse tuple
   */
  public async forChangeVcnCompartment(
    request: serviceRequests.ChangeVcnCompartmentRequest
  ): Promise<{
    response: serviceResponses.ChangeVcnCompartmentResponse;
    workRequestResponse: responses.GetWorkRequestResponse;
  }> {
    const changeVcnCompartmentResponse = await this.client.changeVcnCompartment(request);
    const getWorkRequestResponse = await waitForWorkRequest(
      this.config,
      this.workRequestClient,
      changeVcnCompartmentResponse.opcWorkRequestId
    );
    return { response: changeVcnCompartmentResponse, workRequestResponse: getWorkRequestResponse };
  }

  /**
   * Waits forChangeVlanCompartment
   *
   * @param request the request to send
   * @return response returns ChangeVlanCompartmentResponse, GetWorkRequestResponse tuple
   */
  public async forChangeVlanCompartment(
    request: serviceRequests.ChangeVlanCompartmentRequest
  ): Promise<{
    response: serviceResponses.ChangeVlanCompartmentResponse;
    workRequestResponse: responses.GetWorkRequestResponse;
  }> {
    const changeVlanCompartmentResponse = await this.client.changeVlanCompartment(request);
    const getWorkRequestResponse = await waitForWorkRequest(
      this.config,
      this.workRequestClient,
      changeVlanCompartmentResponse.opcWorkRequestId
    );
    return { response: changeVlanCompartmentResponse, workRequestResponse: getWorkRequestResponse };
  }

  /**
   * Waits forDeleteByoipRange
   *
   * @param request the request to send
   * @return response returns DeleteByoipRangeResponse, GetWorkRequestResponse tuple
   */
  public async forDeleteByoipRange(
    request: serviceRequests.DeleteByoipRangeRequest
  ): Promise<{
    response: serviceResponses.DeleteByoipRangeResponse;
    workRequestResponse: responses.GetWorkRequestResponse;
  }> {
    const deleteByoipRangeResponse = await this.client.deleteByoipRange(request);
    const getWorkRequestResponse = await waitForWorkRequest(
      this.config,
      this.workRequestClient,
      deleteByoipRangeResponse.opcWorkRequestId
    );
    return { response: deleteByoipRangeResponse, workRequestResponse: getWorkRequestResponse };
  }

  /**
   * Waits forByoipRange till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetByoipRangeResponse | null (null in case of 404 response)
   */
  public async forByoipRange(
    request: serviceRequests.GetByoipRangeRequest,
    ...targetStates: models.ByoipRange.LifecycleState[]
  ): Promise<serviceResponses.GetByoipRangeResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getByoipRange(request),
      response => targetStates.includes(response.byoipRange.lifecycleState!),
      targetStates.includes(models.ByoipRange.LifecycleState.Deleted)
    );
  }

  /**
   * Waits forCrossConnect till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetCrossConnectResponse | null (null in case of 404 response)
   */
  public async forCrossConnect(
    request: serviceRequests.GetCrossConnectRequest,
    ...targetStates: models.CrossConnect.LifecycleState[]
  ): Promise<serviceResponses.GetCrossConnectResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getCrossConnect(request),
      response => targetStates.includes(response.crossConnect.lifecycleState!),
      targetStates.includes(models.CrossConnect.LifecycleState.Terminated)
    );
  }

  /**
   * Waits forCrossConnectGroup till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetCrossConnectGroupResponse | null (null in case of 404 response)
   */
  public async forCrossConnectGroup(
    request: serviceRequests.GetCrossConnectGroupRequest,
    ...targetStates: models.CrossConnectGroup.LifecycleState[]
  ): Promise<serviceResponses.GetCrossConnectGroupResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getCrossConnectGroup(request),
      response => targetStates.includes(response.crossConnectGroup.lifecycleState!),
      targetStates.includes(models.CrossConnectGroup.LifecycleState.Terminated)
    );
  }

  /**
   * Waits forDhcpOptions till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetDhcpOptionsResponse | null (null in case of 404 response)
   */
  public async forDhcpOptions(
    request: serviceRequests.GetDhcpOptionsRequest,
    ...targetStates: models.DhcpOptions.LifecycleState[]
  ): Promise<serviceResponses.GetDhcpOptionsResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getDhcpOptions(request),
      response => targetStates.includes(response.dhcpOptions.lifecycleState!),
      targetStates.includes(models.DhcpOptions.LifecycleState.Terminated)
    );
  }

  /**
   * Waits forDrg till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetDrgResponse | null (null in case of 404 response)
   */
  public async forDrg(
    request: serviceRequests.GetDrgRequest,
    ...targetStates: models.Drg.LifecycleState[]
  ): Promise<serviceResponses.GetDrgResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getDrg(request),
      response => targetStates.includes(response.drg.lifecycleState!),
      targetStates.includes(models.Drg.LifecycleState.Terminated)
    );
  }

  /**
   * Waits forDrgAttachment till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetDrgAttachmentResponse
   */
  public async forDrgAttachment(
    request: serviceRequests.GetDrgAttachmentRequest,
    ...targetStates: models.DrgAttachment.LifecycleState[]
  ): Promise<serviceResponses.GetDrgAttachmentResponse> {
    return genericWaiter(
      this.config,
      () => this.client.getDrgAttachment(request),
      response => targetStates.includes(response.drgAttachment.lifecycleState!)
    );
  }

  /**
   * Waits forDrgRouteDistribution till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetDrgRouteDistributionResponse | null (null in case of 404 response)
   */
  public async forDrgRouteDistribution(
    request: serviceRequests.GetDrgRouteDistributionRequest,
    ...targetStates: models.DrgRouteDistribution.LifecycleState[]
  ): Promise<serviceResponses.GetDrgRouteDistributionResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getDrgRouteDistribution(request),
      response => targetStates.includes(response.drgRouteDistribution.lifecycleState!),
      targetStates.includes(models.DrgRouteDistribution.LifecycleState.Terminated)
    );
  }

  /**
   * Waits forDrgRouteTable till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetDrgRouteTableResponse | null (null in case of 404 response)
   */
  public async forDrgRouteTable(
    request: serviceRequests.GetDrgRouteTableRequest,
    ...targetStates: models.DrgRouteTable.LifecycleState[]
  ): Promise<serviceResponses.GetDrgRouteTableResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getDrgRouteTable(request),
      response => targetStates.includes(response.drgRouteTable.lifecycleState!),
      targetStates.includes(models.DrgRouteTable.LifecycleState.Terminated)
    );
  }

  /**
   * Waits forIPSecConnection till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetIPSecConnectionResponse | null (null in case of 404 response)
   */
  public async forIPSecConnection(
    request: serviceRequests.GetIPSecConnectionRequest,
    ...targetStates: models.IPSecConnection.LifecycleState[]
  ): Promise<serviceResponses.GetIPSecConnectionResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getIPSecConnection(request),
      response => targetStates.includes(response.iPSecConnection.lifecycleState!),
      targetStates.includes(models.IPSecConnection.LifecycleState.Terminated)
    );
  }

  /**
   * Waits forIPSecConnectionTunnel till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetIPSecConnectionTunnelResponse | null (null in case of 404 response)
   */
  public async forIPSecConnectionTunnel(
    request: serviceRequests.GetIPSecConnectionTunnelRequest,
    ...targetStates: models.IPSecConnectionTunnel.LifecycleState[]
  ): Promise<serviceResponses.GetIPSecConnectionTunnelResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getIPSecConnectionTunnel(request),
      response => targetStates.includes(response.iPSecConnectionTunnel.lifecycleState!),
      targetStates.includes(models.IPSecConnectionTunnel.LifecycleState.Terminated)
    );
  }

  /**
   * Waits forInternetGateway till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetInternetGatewayResponse | null (null in case of 404 response)
   */
  public async forInternetGateway(
    request: serviceRequests.GetInternetGatewayRequest,
    ...targetStates: models.InternetGateway.LifecycleState[]
  ): Promise<serviceResponses.GetInternetGatewayResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getInternetGateway(request),
      response => targetStates.includes(response.internetGateway.lifecycleState!),
      targetStates.includes(models.InternetGateway.LifecycleState.Terminated)
    );
  }

  /**
   * Waits forIpv6 till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetIpv6Response | null (null in case of 404 response)
   */
  public async forIpv6(
    request: serviceRequests.GetIpv6Request,
    ...targetStates: models.Ipv6.LifecycleState[]
  ): Promise<serviceResponses.GetIpv6Response | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getIpv6(request),
      response => targetStates.includes(response.ipv6.lifecycleState!),
      targetStates.includes(models.Ipv6.LifecycleState.Terminated)
    );
  }

  /**
   * Waits forLocalPeeringGatewayonPeeringStatus till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetLocalPeeringGatewayResponse | null (null in case of 404 response)
   */
  public async forLocalPeeringGatewayonPeeringStatus(
    request: serviceRequests.GetLocalPeeringGatewayRequest,
    ...targetStates: models.LocalPeeringGateway.PeeringStatus[]
  ): Promise<serviceResponses.GetLocalPeeringGatewayResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getLocalPeeringGateway(request),
      response => targetStates.includes(response.localPeeringGateway.peeringStatus!),
      targetStates.includes(models.LocalPeeringGateway.PeeringStatus.Revoked)
    );
  }

  /**
   * Waits forLocalPeeringGatewayonLifecycleState till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetLocalPeeringGatewayResponse | null (null in case of 404 response)
   */
  public async forLocalPeeringGatewayonLifecycleState(
    request: serviceRequests.GetLocalPeeringGatewayRequest,
    ...targetStates: models.LocalPeeringGateway.LifecycleState[]
  ): Promise<serviceResponses.GetLocalPeeringGatewayResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getLocalPeeringGateway(request),
      response => targetStates.includes(response.localPeeringGateway.lifecycleState!),
      targetStates.includes(models.LocalPeeringGateway.LifecycleState.Terminated)
    );
  }

  /**
   * Waits forNatGateway till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetNatGatewayResponse | null (null in case of 404 response)
   */
  public async forNatGateway(
    request: serviceRequests.GetNatGatewayRequest,
    ...targetStates: models.NatGateway.LifecycleState[]
  ): Promise<serviceResponses.GetNatGatewayResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getNatGateway(request),
      response => targetStates.includes(response.natGateway.lifecycleState!),
      targetStates.includes(models.NatGateway.LifecycleState.Terminated)
    );
  }

  /**
   * Waits forNetworkSecurityGroup till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetNetworkSecurityGroupResponse | null (null in case of 404 response)
   */
  public async forNetworkSecurityGroup(
    request: serviceRequests.GetNetworkSecurityGroupRequest,
    ...targetStates: models.NetworkSecurityGroup.LifecycleState[]
  ): Promise<serviceResponses.GetNetworkSecurityGroupResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getNetworkSecurityGroup(request),
      response => targetStates.includes(response.networkSecurityGroup.lifecycleState!),
      targetStates.includes(models.NetworkSecurityGroup.LifecycleState.Terminated)
    );
  }

  /**
   * Waits forPublicIp till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetPublicIpResponse | null (null in case of 404 response)
   */
  public async forPublicIp(
    request: serviceRequests.GetPublicIpRequest,
    ...targetStates: models.PublicIp.LifecycleState[]
  ): Promise<serviceResponses.GetPublicIpResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getPublicIp(request),
      response => targetStates.includes(response.publicIp.lifecycleState!),
      targetStates.includes(models.PublicIp.LifecycleState.Terminated)
    );
  }

  /**
   * Waits forPublicIpPool till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetPublicIpPoolResponse | null (null in case of 404 response)
   */
  public async forPublicIpPool(
    request: serviceRequests.GetPublicIpPoolRequest,
    ...targetStates: models.PublicIpPool.LifecycleState[]
  ): Promise<serviceResponses.GetPublicIpPoolResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getPublicIpPool(request),
      response => targetStates.includes(response.publicIpPool.lifecycleState!),
      targetStates.includes(models.PublicIpPool.LifecycleState.Deleted)
    );
  }

  /**
   * Waits forRemotePeeringConnectiononLifecycleState till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetRemotePeeringConnectionResponse | null (null in case of 404 response)
   */
  public async forRemotePeeringConnectiononLifecycleState(
    request: serviceRequests.GetRemotePeeringConnectionRequest,
    ...targetStates: models.RemotePeeringConnection.LifecycleState[]
  ): Promise<serviceResponses.GetRemotePeeringConnectionResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getRemotePeeringConnection(request),
      response => targetStates.includes(response.remotePeeringConnection.lifecycleState!),
      targetStates.includes(models.RemotePeeringConnection.LifecycleState.Terminated)
    );
  }

  /**
   * Waits forRemotePeeringConnectiononPeeringStatus till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetRemotePeeringConnectionResponse | null (null in case of 404 response)
   */
  public async forRemotePeeringConnectiononPeeringStatus(
    request: serviceRequests.GetRemotePeeringConnectionRequest,
    ...targetStates: models.RemotePeeringConnection.PeeringStatus[]
  ): Promise<serviceResponses.GetRemotePeeringConnectionResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getRemotePeeringConnection(request),
      response => targetStates.includes(response.remotePeeringConnection.peeringStatus!),
      targetStates.includes(models.RemotePeeringConnection.PeeringStatus.Revoked)
    );
  }

  /**
   * Waits forRouteTable till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetRouteTableResponse | null (null in case of 404 response)
   */
  public async forRouteTable(
    request: serviceRequests.GetRouteTableRequest,
    ...targetStates: models.RouteTable.LifecycleState[]
  ): Promise<serviceResponses.GetRouteTableResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getRouteTable(request),
      response => targetStates.includes(response.routeTable.lifecycleState!),
      targetStates.includes(models.RouteTable.LifecycleState.Terminated)
    );
  }

  /**
   * Waits forSecurityList till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetSecurityListResponse | null (null in case of 404 response)
   */
  public async forSecurityList(
    request: serviceRequests.GetSecurityListRequest,
    ...targetStates: models.SecurityList.LifecycleState[]
  ): Promise<serviceResponses.GetSecurityListResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getSecurityList(request),
      response => targetStates.includes(response.securityList.lifecycleState!),
      targetStates.includes(models.SecurityList.LifecycleState.Terminated)
    );
  }

  /**
   * Waits forServiceGateway till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetServiceGatewayResponse | null (null in case of 404 response)
   */
  public async forServiceGateway(
    request: serviceRequests.GetServiceGatewayRequest,
    ...targetStates: models.ServiceGateway.LifecycleState[]
  ): Promise<serviceResponses.GetServiceGatewayResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getServiceGateway(request),
      response => targetStates.includes(response.serviceGateway.lifecycleState!),
      targetStates.includes(models.ServiceGateway.LifecycleState.Terminated)
    );
  }

  /**
   * Waits forSubnet till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetSubnetResponse | null (null in case of 404 response)
   */
  public async forSubnet(
    request: serviceRequests.GetSubnetRequest,
    ...targetStates: models.Subnet.LifecycleState[]
  ): Promise<serviceResponses.GetSubnetResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getSubnet(request),
      response => targetStates.includes(response.subnet.lifecycleState!),
      targetStates.includes(models.Subnet.LifecycleState.Terminated)
    );
  }

  /**
   * Waits forVcn till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetVcnResponse | null (null in case of 404 response)
   */
  public async forVcn(
    request: serviceRequests.GetVcnRequest,
    ...targetStates: models.Vcn.LifecycleState[]
  ): Promise<serviceResponses.GetVcnResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getVcn(request),
      response => targetStates.includes(response.vcn.lifecycleState!),
      targetStates.includes(models.Vcn.LifecycleState.Terminated)
    );
  }

  /**
   * Waits forVcnDnsResolverAssociation till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetVcnDnsResolverAssociationResponse | null (null in case of 404 response)
   */
  public async forVcnDnsResolverAssociation(
    request: serviceRequests.GetVcnDnsResolverAssociationRequest,
    ...targetStates: models.VcnDnsResolverAssociation.LifecycleState[]
  ): Promise<serviceResponses.GetVcnDnsResolverAssociationResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getVcnDnsResolverAssociation(request),
      response => targetStates.includes(response.vcnDnsResolverAssociation.lifecycleState!),
      targetStates.includes(models.VcnDnsResolverAssociation.LifecycleState.Terminated)
    );
  }

  /**
   * Waits forVirtualCircuit till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetVirtualCircuitResponse | null (null in case of 404 response)
   */
  public async forVirtualCircuit(
    request: serviceRequests.GetVirtualCircuitRequest,
    ...targetStates: models.VirtualCircuit.LifecycleState[]
  ): Promise<serviceResponses.GetVirtualCircuitResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getVirtualCircuit(request),
      response => targetStates.includes(response.virtualCircuit.lifecycleState!),
      targetStates.includes(models.VirtualCircuit.LifecycleState.Terminated)
    );
  }

  /**
   * Waits forVlan till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetVlanResponse | null (null in case of 404 response)
   */
  public async forVlan(
    request: serviceRequests.GetVlanRequest,
    ...targetStates: models.Vlan.LifecycleState[]
  ): Promise<serviceResponses.GetVlanResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getVlan(request),
      response => targetStates.includes(response.vlan.lifecycleState!),
      targetStates.includes(models.Vlan.LifecycleState.Terminated)
    );
  }

  /**
   * Waits forVnic till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetVnicResponse | null (null in case of 404 response)
   */
  public async forVnic(
    request: serviceRequests.GetVnicRequest,
    ...targetStates: models.Vnic.LifecycleState[]
  ): Promise<serviceResponses.GetVnicResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getVnic(request),
      response => targetStates.includes(response.vnic.lifecycleState!),
      targetStates.includes(models.Vnic.LifecycleState.Terminated)
    );
  }

  /**
   * Waits forModifyVcnCidr
   *
   * @param request the request to send
   * @return response returns ModifyVcnCidrResponse, GetWorkRequestResponse tuple
   */
  public async forModifyVcnCidr(
    request: serviceRequests.ModifyVcnCidrRequest
  ): Promise<{
    response: serviceResponses.ModifyVcnCidrResponse;
    workRequestResponse: responses.GetWorkRequestResponse;
  }> {
    const modifyVcnCidrResponse = await this.client.modifyVcnCidr(request);
    const getWorkRequestResponse = await waitForWorkRequest(
      this.config,
      this.workRequestClient,
      modifyVcnCidrResponse.opcWorkRequestId
    );
    return { response: modifyVcnCidrResponse, workRequestResponse: getWorkRequestResponse };
  }

  /**
   * Waits forRemoveVcnCidr
   *
   * @param request the request to send
   * @return response returns RemoveVcnCidrResponse, GetWorkRequestResponse tuple
   */
  public async forRemoveVcnCidr(
    request: serviceRequests.RemoveVcnCidrRequest
  ): Promise<{
    response: serviceResponses.RemoveVcnCidrResponse;
    workRequestResponse: responses.GetWorkRequestResponse;
  }> {
    const removeVcnCidrResponse = await this.client.removeVcnCidr(request);
    const getWorkRequestResponse = await waitForWorkRequest(
      this.config,
      this.workRequestClient,
      removeVcnCidrResponse.opcWorkRequestId
    );
    return { response: removeVcnCidrResponse, workRequestResponse: getWorkRequestResponse };
  }

  /**
   * Waits forUpgradeDrg
   *
   * @param request the request to send
   * @return response returns UpgradeDrgResponse, GetWorkRequestResponse tuple
   */
  public async forUpgradeDrg(
    request: serviceRequests.UpgradeDrgRequest
  ): Promise<{
    response: serviceResponses.UpgradeDrgResponse;
    workRequestResponse: responses.GetWorkRequestResponse;
  }> {
    const upgradeDrgResponse = await this.client.upgradeDrg(request);
    const getWorkRequestResponse = await waitForWorkRequest(
      this.config,
      this.workRequestClient,
      upgradeDrgResponse.opcWorkRequestId
    );
    return { response: upgradeDrgResponse, workRequestResponse: getWorkRequestResponse };
  }

  /**
   * Waits forValidateByoipRange
   *
   * @param request the request to send
   * @return response returns ValidateByoipRangeResponse, GetWorkRequestResponse tuple
   */
  public async forValidateByoipRange(
    request: serviceRequests.ValidateByoipRangeRequest
  ): Promise<{
    response: serviceResponses.ValidateByoipRangeResponse;
    workRequestResponse: responses.GetWorkRequestResponse;
  }> {
    const validateByoipRangeResponse = await this.client.validateByoipRange(request);
    const getWorkRequestResponse = await waitForWorkRequest(
      this.config,
      this.workRequestClient,
      validateByoipRangeResponse.opcWorkRequestId
    );
    return { response: validateByoipRangeResponse, workRequestResponse: getWorkRequestResponse };
  }
}
